<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雪峰的blog</title>
  <icon>https://www.gravatar.com/avatar/00bbf828835d0686e9010b2a2e951bdd</icon>
  <subtitle>善于总结, 乐于分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zxfcumtcs.github.io/"/>
  <updated>2018-12-23T16:21:35.228Z</updated>
  <id>http://zxfcumtcs.github.io/</id>
  
  <author>
    <name>赵雪峰</name>
    <email>zxfcumtcs@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 高效开发解决方案</title>
    <link href="http://zxfcumtcs.github.io/2018/12/22/Efficient-Development-Solutions/"/>
    <id>http://zxfcumtcs.github.io/2018/12/22/Efficient-Development-Solutions/</id>
    <published>2018-12-22T09:36:54.000Z</published>
    <updated>2018-12-23T16:21:35.228Z</updated>
    
    <content type="html"><![CDATA[<p>本文作为 QQ 阅读 7.0 改版总结，从架构、页面元素模块化、UI 组件化、基于 iOS 系统响应链的事件处理、业务模板化等方面阐述了一套高效的列表类应用开发解决方案。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><hr><p>QQ 阅读迎来了7.0版本，作为惯例大版本需要大动作——『UI大改版』。<br>本文主要是对这次改版的一个总结并提炼出一套通用的『列表类业务』开发解决方案。<br>本文将从以下几个方面展开讨论：</p><ul><li>架构</li><li>页面元素模块化</li><li>UI 组件化</li><li>基于响应链的事件处理</li><li>业务模板化</li></ul><blockquote><p>本文部分内容来自<a href="https://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/">列表类应用场景模板化</a>和<a href="https://zxfcumtcs.github.io/2017/03/04/CustomUIControls/">自定义 UI 组件库</a></p></blockquote><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><hr><p>列表类业务应该说是大多数 App 的主要业务场景，如朋友圈、新闻类 App 首页、各类个性化推荐页、微博首页以及我们的书城等等。</p><p>列表类业务其流程主要是：</p><ul><li>从网络或本地磁盘获取数据；</li><li>再将数据以列表(<code>UITableView</code>、<code>UICollectionView</code>)形式展示出来；</li><li>最主要的交互就是点击进入次级页面。</li></ul><p>对于列表类业务每个项目团队可能都有一套架构，在 QQ 阅读不断迭代的过程中也演化出一套架构。<br><img src="/img/ListSceneClassDiagram.png" alt=""><br><img src="/img/ListSceneTimingDiagram.png" alt=""><br>上面分别是我们这套架构的关键类图和时序图。整体上是由经典 MVC 模式演化而来：</p><ul><li>Manager(Interface)：对应 MVC 中的 Model 『层』，主要负责数据的获取、管理等业务逻辑；</li><li>Controller：各个模块的协调枢纽，页面的承载主体；</li><li>Cell\View：对应 MVC 中的 View，仅仅负责 UI 布局、展示逻辑；</li><li>ViewModel(Interface)：View 与具体业务的中间抽象层，使两者解耦，达到 View 只负责 UI 布局的目的，最终实现 View 的高可复用性；</li><li>Module(Interface)： 称其为『业务模块』，一个页面由多个不同或相同类型的模块组成。</li></ul><h1 id="页面元素模块化"><a href="#页面元素模块化" class="headerlink" title="页面元素模块化"></a>页面元素模块化</h1><hr><p>MVC 模式饱受诟病的一点就是：Controller 经常会变得过于臃肿(Massive View Controller)。<br>为了解决这一问题，业界提出了多种解决方案，大部分都是通过添加中间层，将 Controller 的功能分解到中间层上，如 MVP (Model View Presenter) 模式。</p><p>为了解决 Controller 臃肿问题，在我们的架构中将页面元素抽象成一个个的 Module。<br><img src="/img/bookcitymodules.png" alt=""><br>如上图，红色虚线分隔的就是不同的 Module。从此，页面的生成过程就是拼接组装 Module 的过程。</p><p>在 TableView 中一个 Module 对应一个 section。<br>Module 的职责主要有：</p><ul><li>解析、存储业务数据(如今日必读 Module 需要负责解析、存储今日必读这块业务数据)；</li><li>为 TableView 提供数据(即实现<code>UITableViewDataSource</code>协议)；</li><li>处理用户事件；</li><li>埋点；</li><li>…</li></ul><p>——即负责『模块』的所有逻辑(与 React Component 类似)。</p><h2 id="Manager-与-Module"><a href="#Manager-与-Module" class="headerlink" title="Manager 与 Module"></a>Manager 与 Module</h2><p>通过上述分析可知，Module 解析、存储业务数据，Manager 存储、管理 Module。</p><p>这种做法也存在弊端，由于将解析业务数据、控制 UI 展示的逻辑(创建 cell 等)都放在了 Module 中。使得 Module 违反了『单一职责原则』。</p><blockquote><p>『单一职责原则』(SRP)作为面向对象设计的五大原则『SOLID』之一，很容易理解，也很难把握！『就好像生活中的各种”适量”，适量放点盐、适量加点水…』<br> Bob大叔在《敏捷软件开发》中，将类的单一职责原则描述为『应该仅有一个引起它变化的原因』。</p></blockquote><p>在 Module 中，业务数据解析、UI 展示就是两个可变的因素——『同样的 UI 用于展示不同的网络协议返回的数据、同一协议返回的数据展示为不用的 UI』。<br>在 QQ 阅读中，书籍列表页就属于『同样的 UI 展示不同协议返回的数据』：<br><img src="/img/BookList.jpeg" alt=""><br>针对这种情况，无非就是将其中一个变化因子抽取出来，如将业务数据解析抽取为一个单独的类。<br>由于 Module 中这两个变化因子变动的概率并不大，为了降低复杂度，只有在真正需要时才将这两者分离开。</p><blockquote><p>『敏捷开发』的原则之一就是尽量保持代码简单、并在必要时进行重构，防止代码变坏。</p></blockquote><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    QRBaseModule *module = [<span class="keyword">self</span>.manager moduleAtIndex:indexPath.section];</span><br><span class="line">    <span class="keyword">return</span> [module heightForRow:indexPath.row];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    QRBaseModule *module = [<span class="keyword">self</span>.manager moduleAtIndex:section];</span><br><span class="line">    <span class="keyword">return</span> [module numberOfRows];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    QRBaseModule *module = [<span class="keyword">self</span>.manager moduleAtIndex:indexPath.section];</span><br><span class="line">    <span class="keyword">return</span> [module cellForRow:indexPath.row tableView:tableView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.manager moduleCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码，模块化后<code>UITableViewDelegate</code>、<code>UITableViewDataSource</code>的大部分方法都转发给相应的 Module 去处理，大大简化了 Controller 的复杂度。</p><p>另外，在页面上增删任何元素都只需在 Manager 中增删相应的 Module 即可，Controller 无需任何改动——在 Controller 层面遵守了开放-封闭原则『OCP』。</p><blockquote><p>模块化不仅简化了 Controller，同时也提高了代码的复用性。Module 可以在不同页面间复用。如果这些逻辑全部放在 Controller 里，基本没有复用性可言。</p></blockquote><p>模块化有没有缺点？<br>答案是肯定的😒<br>模块化会增加类的数量、方法的数量(每个 Module 都要实现<code>UITableViewDelegate</code>、<code>UITableViewDataSource</code>的部分方法)。</p><p>当然啦，个人认为利大于弊😊</p><h1 id="UI-组件化"><a href="#UI-组件化" class="headerlink" title="UI 组件化"></a>UI 组件化</h1><hr><p>QQ 阅读7.0改版，UI 修改的工作量占大头，涉及200多个页面的修改。<br>此时，充分体现出 UI 复用的重要性。</p><p>虽然，我们很早就提出通过 View-ViewModel 的方式实现 UI 组件化，提高复用性。<br>遗憾的是，由于历史原因，在我们的工程中依然存在大量重复的实现，即『同一 UI 样式，N 份实现』。这对于 UI 大改版是灾难性了！——「不仅工作量成倍增加，还有漏改的可能性」</p><p>为了避免灾难再次上演(8.0、9.0…)，此次改版过程中，我们严格要求所有 UI 都必须以 View-ViewModel 模式做成 UI 组件。</p><h2 id="UI-组件"><a href="#UI-组件" class="headerlink" title="UI 组件"></a>UI 组件</h2><p>在继续之前，我们简单描述一下什么是 UI 组件：</p><ul><li>可复用的 UI 单元；</li><li>UI 组件可包含子 UI 组件；</li></ul><p>同时，我们将 UI 组件分为外部 UI 组件、内部 UI 组件：</p><ul><li><p>外部 UI 组件——与视觉对接，默认含有上下左右边距，为了提高其复用性，需实现<code>QRExternalUIComponent</code>协议，使得业务方可灵活控制其边距；</p><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">QRExternalUIComponent</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setEdgeInsets:(<span class="built_in">UIEdgeInsets</span>)edgeInsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p>内部 UI 组件——肯定是子 UI 组件，用于构造更大的 UI 组件，为了提高其复用性，同时控制复杂度，切边实现。</p></li></ul><p><img src="/img/fourbookUIComponent.png" alt=""><br>如上图，整体是一个四书的对外 UI 组件，含有视觉要求的上下左右边距，业务方可直接使用。<br>其中，红色虚线框住的则是一个内部组件，切边实现——没有上下左右边距，四书组件就是由4个这样的内部组件拼接而成。</p><h2 id="复用粒度"><a href="#复用粒度" class="headerlink" title="复用粒度"></a>复用粒度</h2><p><strong><em>复用没把握好火候就变成耦合了。</em></strong><br><strong>例1.</strong><br><img src="/img/banner1.jpeg" alt=""><br><img src="/img/banner2.jpeg" alt=""><br>我们书城顶部 banner 有如上图的推书样式、通栏广告图样式、还有柱状图动画样式。<br>在实现的时候，通通将这些样式塞到一个类里面，通过<code>if...else...</code>区分，这就是严重的耦合，给后面的维护造成很大的困难。<br><strong>例2.</strong><br><img src="/img/fourbook.jpeg" alt=""><br><img src="/img/threebook.jpeg" alt=""><br>三书与四书 UI 也是通过<code>if...else...</code>区分，内部还要处理六书、八书的情况，还要兼容 iPad，内部实现异常复杂，导致大家都不敢去碰这块代码。</p><p>为此，我们制定了如下规则：</p><ul><li>UI 布局相同才复用内部实现，所谓布局相同是指 UI 组件在结构上是相同的，如左边都是一个书封，右边都是两行文字，但书封大小、文字字号不同，则认为布局相同；</li><li><p>UI 布局相同，内部细节不同的，通过 <strong><em>Template Method 模式</em></strong>实现代码复用，但对外提供的 UI 组件是独立的(简化业务层的使用)；</p><blockquote><p>Template Method: Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.<br>此例中 UI 布局就是 Template Method 中的算法结构，而布局的细节则可以通过子类去控制。</p></blockquote></li><li><p>横向展示数量可扩展、纵向固定不变，如三书、六书是同一个 UI 组件，四书、八书是同一个，因为它们可以通过传入的数量控制展示。</p></li></ul><h2 id="隔离变化"><a href="#隔离变化" class="headerlink" title="隔离变化"></a>隔离变化</h2><p>我们经常吐槽 QQ 阅读 UI 的多样性在业界能排 Top1。<br><img src="/img/singlebook.jpeg" alt=""><br>如上图单书组件，其中红框框住的部分就有15、16种变<strong><em>幻</em></strong>。<br>为此，我们将这部分抽取出来，作为单书组件的一个子组件由使用方负责构造该子组件并传给单书组件去展示。</p><p>好了，下面进入本节的正题，如何构造出复用性高的 UI 组件。</p><h2 id="以-View-ViewModel-形式构建-UI-组件"><a href="#以-View-ViewModel-形式构建-UI-组件" class="headerlink" title="以 View-ViewModel 形式构建 UI 组件"></a>以 View-ViewModel 形式构建 UI 组件</h2><p>高可复用的 UI 组件，至少要满足以下两点：</p><ul><li>UI 组件不能与具体业务数据相绑定；</li><li>UI 组件内部不能处理业务逻辑——其本职工作仅是 UI 布局。</li></ul><p>总之，UI 组件要与业务解耦。<br>此时，MVVM 模式进入我们的视线，在该模式中 ViewModel 的存在是不是很好的解决了上面的问题。<br>在 MVVM 模式中，ViewModel 向上为 View 提供展示数据（该数据已经在 ViewModel 中处理好了，View 无需任何处理，只要展示即可），向下接收来自业务层的数据，处理相关的业务展示逻辑。</p><p>可以看出，ViewModel 作为中间层很好地将业务与 UI 隔离开。<br>说到 MVVM，很多同学并不喜欢，觉得其中的 Data-Binding 很麻烦，但我们构建 UI 组件时用到的是 View-ViewModel 结构，并不要求一定是 MVVM，在 MVC 等模式下也可使用。</p><p>同时，我们采用的是面向接口的模式，View 对外依赖的是接口（protocol），而不是某个具体的 ViewModel。每个 UI 组件其结构如下：<br><img src="/img/ViewViewModel.png" alt=""><br>如上图所示，若某个 UI 组件被多个业务所复用，可以根据需求定义多个 ViewModel 以处理不同的业务逻辑，每个 ViewModel 都实现<code>ViewModelProtocol</code>协议为 View 提供数据。</p><p>如上文提到的单书 UI，我们抽取为一个组件<code>QRLeftPictureRightTextView</code>：<br><img src="/img/QRLeftPictureRightTextView.png" alt=""><img src="/img/QRLeftPictureRightTextViewModel.png" alt=""><br>该组件在信息流以及书城都有用到，为此定义了两个 ViewModel，以处理各自的业务逻辑：<br><img src="/img/QRLeftPictureRightText.jpg" alt=""></p><p>至此，UI 组件化部分的内容基本结束。<br>在 QQ 阅读7.0版本中，实现了『同一 UI 样式，只有一份实现』，个人看来是一件很有意义的事情：</p><ul><li>提高开发效率，不必重复造轮子，工程代码得到很好的规范；</li><li>减轻了设计师的工作，对于复用的组件，设计师只需在设计稿中标出组件编号即可；</li><li>降低了开发与设计师的沟通成本；</li><li>为下次大改版奠定了很好的基础。</li></ul><blockquote><p>Module 与 UI 组件在两个不同的层面实现复用。</p></blockquote><h1 id="基于响应链的事件处理"><a href="#基于响应链的事件处理" class="headerlink" title="基于响应链的事件处理"></a>基于响应链的事件处理</h1><hr><p>现有的事件处理方案有两大痛点，于是提出了基于响应链『Chain of Responsibility』的事件处理方案。</p><ul><li><p>痛点1<br><img src="/img/ViewHierarchy.png" alt=""><br>大多数场景下 View 的层级结构如上图所示。我们知道，View 一般不处理用户事件，需要逐级向上传递给 Controller，因此需要沿着上图的层级结构逐级传递处理事件的 delegate。这种单调、重复、琐碎的代码非常令人不悦：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell.delegate <span class="built_in">=</span> controller;</span><br><span class="line">view.delegate <span class="built_in">=</span> cell;</span><br><span class="line">…</span><br></pre></td></tr></table></figure></li><li><p>痛点2<br>随着版本的迭代，不同类型的 cell/view 极有可能出现不同的事件处理接口，如下图所示：<br><img src="/img/celldelegate.jpeg" alt=""><br>这严重违反了面向对象设计的开闭原则『OCP』——每增加一种 cell 类型此处都需要修改。</p></li></ul><p>尤其是第一点一直困扰着我。直到前不久在《Design Patterns》一书中看到在介绍『Chain of Responsibility』模式时的一句话：『Using existing links works well when the links support the chain you need. It saves you from defining links explicitly, and it saves space』。<br><code>UIResponder</code> 中的 <code>nextResponder</code>不正是这个『existing links』吗！<br>最上层 View 的事件通过<code>nextResponder</code>链就可以顺利传到 ViewController 中，从而也就省去了 delegate 的逐级传递了，痛点1、2随之化解。<br>为此，我们为 <code>UIResponder</code>添加了传递、处理事件的分类：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZSCEvent</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) __kindof <span class="built_in">UIResponder</span> *sender;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *indexPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *userInfo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIResponder</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIResponder</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.nextResponder respondEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>UIResponder</code>的实现只是简单地将事件传递给<code>nextResponder</code>。<br>由于 View 不包含业务数据，所以事件传递的过程中需要不断添加一些信息。</p><blockquote><p>因此，我们将<code>ZSCEvent#userInfo</code>定义为 mutable。正常情况下外露接口一般都是 immutable。</p></blockquote><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableViewCell</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.nextResponder respondEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>如，在<code>UITableViewCell</code>的<code>respondEvent:</code>中需要将<code>sender</code>设置为<code>self</code>，以便在<code>UIViewController</code>中可以通过<code>cell</code>找到对应的 Module。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([event.sender isKindOfClass:<span class="built_in">UITableViewCell</span>.class], <span class="string">@"event sender must be UITableViewCell"</span>);</span><br><span class="line">    <span class="keyword">if</span> (![event.sender isKindOfClass:<span class="built_in">UITableViewCell</span>.class]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = [_tableView indexPathForCell:event.sender];</span><br><span class="line">    <span class="keyword">id</span>&lt;ZSModule&gt; module = [<span class="keyword">self</span>.manager moduleAtIndex:indexPath.section];</span><br><span class="line">    </span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    event.indexPath = indexPath;</span><br><span class="line">    [event.userInfo setObject:_tableView</span><br><span class="line">                       forKey:ZSCEventUserInfoKeys.tableView];</span><br><span class="line">    </span><br><span class="line">    [module handleEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 View 中的事件处理代码可以这样：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_clickedButton:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    ZSCEvent *event = [[ZSCEvent alloc] init];</span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    [event.userInfo setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"clickedButton"</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> respondEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果一个 cell 中有多个事件需要处理，就需要在<code>userInfo</code>中加以区分，如上面代码第<code>5</code>行。</p></blockquote><p>总之，通过<code>UIResponder</code>的<code>nextResponder</code>响应链，不必再在 view 的层级间传递 delegate，减少了琐碎的代码，提高了开发效率。同时也统一规范了事件处理方案。</p><h1 id="业务模板化"><a href="#业务模板化" class="headerlink" title="业务模板化"></a>业务模板化</h1><hr><p><a href="https://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/">列表类应用场景模板化</a>一文对此有详细的描述，在此就不赘述了。<br>其效果还是不错的。<br>很多二级页，由于 Module 是完全复用的，通过模板化脚本<strong><em>半小时</em></strong>就能做好一个二级页✌️。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>简单、高效一直是软件开发、工程管理追求的目标，本文从实际项目经验出发，从架构、解耦、复用等角度总结出一套开发解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文作为 QQ 阅读 7.0 改版总结，从架构、页面元素模块化、UI 组件化、基于 iOS 系统响应链的事件处理、业务模板化等方面阐述了一套高效的列表类应用开发解决方案。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="架构" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="UI 组件" scheme="http://zxfcumtcs.github.io/tags/UI-%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>以 SOLID 为友</title>
    <link href="http://zxfcumtcs.github.io/2018/10/04/solid/"/>
    <id>http://zxfcumtcs.github.io/2018/10/04/solid/</id>
    <published>2018-10-04T10:07:41.000Z</published>
    <updated>2018-12-08T08:41:32.866Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细分析了面向对象设计五大原则 S(单一职责原则『SRP』)、O(开放-封闭原则 『OCP』)、L(Liskov 替换原则『LSP』)、I(接口隔离原则『ISP』)、D(依赖倒置原则『DIP』)，并假以实例辅之。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>软件设计五大原则『SOLID』以及23种经典设计模式自成型以来已有些年头，目前在实际开发中对待它们有两种较为极端的态度：敬而远之、嗤之以鼻。<br>显然，笔者用了『极端』二字表明并不赞同这样的观点。<br>SOLID 以及经典设计模式是前人在长期的软件开发中总结出来的宝贵实践经验，值得我们学习和借鉴。当然，这并不意味着我们要时刻把它们挂在嘴边，以彰显我们的『内力』，也并不意味着就要把它们作为『最高律令』、『不可逾越的红线』早早地就套用在软件开发的过程中(这无疑将增加开发的复杂性)。<br><strong><em>应将其作为解决问题的方案。</em></strong><br>此时，有必要再谈谈『敏捷开发』：<br>在移动互联网时代大家都是以『小步快跑、快速迭代、快速试错』的节奏与时间赛跑、抢占流量。『敏捷开发』因而被时常提及，遗憾的是其大多数时候也仅是停留在嘴边。<br>在移动互联网时代，笔者认为敏捷开发的核心有两点：</p><ul><li>不做过度设计，始终尽力保持代码简洁、易理解、好维护(不用一开始就套用各种原则、设计模式，徒增复杂)；</li><li>拥抱变化，无论是因需求还是其他原因引起变化导致现有代码结构不能满足需要时，要积极地对代码进行重构，始终保持良好的代码结构，对代码的腐朽保持零容忍(出现问题后可借鉴 SOLID、设计模式等去解决问题)。</li></ul><p>从上述两点可以看出：<strong>敏捷开发是一个持续的过程，而非一个心血来潮的事件。</strong></p><blockquote><p>ps：重构不一定是翻天覆地的大改，重命名变量、分解复杂方法等等都是重构。</p></blockquote><p>本文将以 SOLID 五大设计原则为主线，辅以设计模式为解决方案，谈谈 QQ 阅读、iOS 系统 API 在代码设计上的得失(失主要是对 QQ 阅读个别代码的反思)。</p><h1 id="单一职责原则『SRP』"><a href="#单一职责原则『SRP』" class="headerlink" title="单一职责原则『SRP』"></a>单一职责原则『SRP』</h1><hr><p>SRP 非常好理解，与『内聚性』表达的是同样的关注点。<br>SRP 在 SOLID 五大原则中可以说是最简单、最基础的原则。然而在实际开发中，对 SRP 的把握又是最难的。单一职责，到底什么是职责？单一的粒度如何？总之不好把握，就像生活中的各种适量『煮饭时适量加点水、做菜时适量放点盐』(经常让人抓狂 v_v)。<br>Bob 大叔在《敏捷软件开发》一书中将职责定义为：<strong><em>变化的原因</em></strong>，单一职责即为：<strong><em>仅有一个引起实体(模块、类、方法等)变化的原因</em></strong>。在把握单一职责时，这不失为一个很好的抓手，通过观察、思考设计的实体是否有一个以上的变化原因来判断其职责是否单一。</p><blockquote><p>后文为叙述方便，如无特别说明，实体指模块、类、方法等功能代码块。</p></blockquote><p>笔者认为 SRP 作为最基础的设计原则，主要有两点收益：</p><ul><li>降低实体的复杂度，提升可维护性；</li><li>提高实体的可复用性，当一个实体中耦合了多个职责时，其可复用性必然受到影响。即使多处复用了，其中一个职责的变化对复用其他职责的实体也会造成意想不到的影响，这不是我们想看到的。这也是 Bob 大叔将职责定义为『变化』的原因。</li></ul><h2 id="例1-UIView-与-CALayer"><a href="#例1-UIView-与-CALayer" class="headerlink" title="例1 UIView 与 CALayer"></a>例1 UIView 与 CALayer</h2><p>在 UIView 的层级结构中，我们知道每个 View 背后都有一个 CALayer 与之对应。<br>其中，UIView 的主要职责是处理用户交互，CALayer 则是布局、渲染以及动画等。<br>Apple 之所以要设计 UIView 与 CALayer 两套体系，就是为了使它们的职责更加单一，能更好的复用。<br>在 iOS 与 Mac OS 上，用户交互处理方式有本质的区别，然而在布局、渲染、动画等方面又是一致的。因此，通过将上述职责分离，CALayer 可以很好地在 iOS 与 Mac OS 间复用，而用户交互的处理则各自独立，于是有了 UIKit、AppKit。</p><h2 id="例2-View-与-ViewModel"><a href="#例2-View-与-ViewModel" class="headerlink" title="例2 View 与 ViewModel"></a>例2 View 与 ViewModel</h2><p>例1中的 View 与 Layer 属于系统实现层面，在应用层面 UIView 的职责是明确的、单一的：<strong>UI 布局</strong>。然而在实际开发中有大量展示相关的业务逻辑写到了 View 里面，严重影响了 View 的可复用性。究其原因，在非 MVVM 模式下，展示逻辑只能放在 Controller 中，势必造成 Controller 过于臃肿。于是，在 QQ 阅读中我们提出以 View-ViewModel 模式构建 UI 组件，将展示逻辑放到 ViewModel 中，View 仅处理布局逻辑。目前看效果良好，View 的逻辑更加清晰、可复用性得到很大提高。详细信息请参看<a href="https://zxfcumtcs.github.io/2017/03/04/CustomUIControls/">『自定义 UI 组件库』</a>一文。</p><h1 id="开放-封闭原则-『OCP』"><a href="#开放-封闭原则-『OCP』" class="headerlink" title="开放-封闭原则 『OCP』"></a>开放-封闭原则 『OCP』</h1><hr><p>『唯有变化才是永恒』，对于软件开发来说更是如此，一个模块、类、方法等实体几乎不可能在第一个版本开发出来后就一直保持不变。因此，变化是开发人员必须要面对的问题(可谓爱之恨之)。<br>OCP 就是用于指导我们如何应对变化。<br>OCP 的含义是：『对扩展开放，对修改封闭』。<br>具体说，实体的功能可以不断扩展(变化)，但实体的源码不允许修改。<br>看似十分矛盾！就像『东西可以随便买，但钱不允许花』。<br>仔细分析，OCP 的重点是<strong>扩展新功能</strong>，也就是扩展新功能时可以添加新代码，但不能修改已有代码。因为对已有代码的修改带来的影响是难于预料的，如果修改导致链锁反应，后果更是灾难性的。<br>如何做到？<br><strong>关键在抽象</strong>。<br>『面向接口编程，而非实现编程』这是我们经常挂在嘴边的话。<br>面向接口编程，也就是说依赖的是抽象接口，为的就是可以灵活的替换接口背后的实现。这不正是 OCP 需要的吗！</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>在23种经典设计模式中『Template Method 模式』以及『Strategy 模式』都可以很好地实现 OCP，其中 Template Method 模式的实现依赖于继承，Strategy 模式使用的委托(接口)。</p><h3 id="Template-Method-模式"><a href="#Template-Method-模式" class="headerlink" title="Template Method 模式"></a>Template Method 模式</h3><p><img src="/img/TemplateMethod.png" alt=""><br>Template Method 模式类图如上图所示(来自 GoF 的《Design patterns》)。<br>Template Method 模式在抽象基类中定义 <code>TemplateMethod</code>方法，但该方法并不做实际工作，只是调用其它方法(<code>PrimitiveOperation...</code>，C++中须是虚函数)来完成具体的工作。<br>可见，<code>TemplateMethod</code>方法只是定义了一个任务或算法的骨架、执行步骤。<br>因此，可以通过派生新的子类，并实现<code>PrimitiveOperation...</code>方法来扩展功能。</p><h3 id="Strategy-模式"><a href="#Strategy-模式" class="headerlink" title="Strategy 模式"></a>Strategy 模式</h3><p><img src="/img/Strategy.png" alt=""><br>Strategy 模式类图如上图所示(来自 GoF 的《Design patterns》)。<br>Strategy 模式是典型的面向接口编程，通过接口使得业务层(使用方)与实现细节完全解耦，从而可以很方便地通过扩展实现来扩展新功能，而无须对业务层进行修改。<br>纵观 Template Method 与 Strategy 模式，前者通过继承并重写方法(C++中的虚函数)来扩展新功能，后者通过新增实现了特定接口的类开添加新功能。<br>两者无谓优劣，不同的场景使用不同的方案。但是，继承会增加复杂度，这是共识，在使用 Template Method 模式时需要考虑到这点。</p><h2 id="例1-QQ-阅读登录模块"><a href="#例1-QQ-阅读登录模块" class="headerlink" title="例1 QQ 阅读登录模块"></a>例1 QQ 阅读登录模块</h2><p>QQ 阅读起初只有 QQ 一种登录方式，突然有一天 Apple 爸爸说不得强制用户必须登录才能使用 App。无奈之下，我们添加了游客登录模式。<br><img src="/img/OldLoginClassDiagram.png" alt=""><br>上图就是增加游客登录后的结构简图。QQ 登录、游客登录看似相安无事。<br>但，<strong>众多业务模块</strong>直接与两种登录方式交互，严重破坏了 OCP。<br>后果如何？<br>后果是严重的！后面如果要增加其他登录方式，所有与登录态有关的模块全都要改一遍！</p><blockquote><p>问题出在哪里？笔者认为最初业务层直接与 QQ 登录交互并无大碍，关键是在添加游客登录时需要察觉到其中的问题，并立即做出重构，而不是在现有代码基础上糊乱堆叠代码。</p></blockquote><p>果不其然，没多久产品要求添加微信登录。于是趁机对登录做了一次彻底的重构。<br><img src="/img/NewLoginClassDiagram.png" alt=""><br>重构过程中，我们添加了『鉴权中心』模块<code>QRAuthenticatonCenter</code>统一处理登录相关的问题，同时使用了 Strategy 模式将各种登录方式的实现细节与<code>QRAuthenticatonCenter</code>以及业务层隔离开来。<br>不久之后，我们又添加了起点登录、QQ 登录也由原来腾讯内部的 Wlogin 登录方式切换到统一互联登录。<br>针对这两个变动，业务层无任何修改，<code>QRAuthenticatonCenter</code>也只是添加了初始化<code>QRYWAuthenticator</code>、<code>QROpenQQAuthenticator</code>的代码。变动的主要工作就是按照<code>QRAuthenticatorDelegate</code>接口分别去实现<code>QRYWAuthenticator</code>以及<code>QROpenQQAuthenticator</code>。</p><blockquote><p>通过 Abstract Factory 模式，可以使得在添加新登录方式时<code>QRAuthenticatonCenter</code>也无需修改，但笔者认为在该场景下其带来的收益不足以弥补其复杂性，即弊大于利，故弃之。</p></blockquote><p>上述可见，通过 Strategy 模式重构后的登录模块实现了 OCP，也在后续迭代变更过程中充分享受了其带来的收益。</p><h2 id="例2-QQ-阅读引擎模块"><a href="#例2-QQ-阅读引擎模块" class="headerlink" title="例2 QQ 阅读引擎模块"></a>例2 QQ 阅读引擎模块</h2><p>QQ 阅读的 txt 引擎是整个工程里面最核心，也是最古老的一个模块。<br>起初，引擎里面有两种类型的段落：文字、空段落，并通过一个<code>int</code>型变量<code>type</code>加以表示。<br>随着迭代，越来越多非内容本身的交互性元素加入阅读页，如：作者的话、大神说等等。目前<code>type</code>的值已扩展到十五、六类之多，每添加一种新类型都要在最核心的引擎里面修改一、二十处，可谓如覆薄冰。<br>这就是一个严重违反 OCP，并产生严重后果的例子。<br>找到了问题所在，重构方案也就变得明了：通过 Strategy 模式，将每种类型段落的逻辑抽取成一个类，并遵守相同的接口，txt 引擎依赖抽象接口，使之遵守 OCP。</p><h1 id="Liskov-替换原则『LSP』"><a href="#Liskov-替换原则『LSP』" class="headerlink" title="Liskov 替换原则『LSP』"></a>Liskov 替换原则『LSP』</h1><hr><p>LSP：子类型必须能够替换其基类型。<br>直白点，就是任何使用基类类型的地方(如调用方法时的入参)都能替换成其子类类型，而不会出现意想不到的错误。<br>看完 LSP 的定义，不禁要问：其有何用？<br>为了回答这个问题，不防从反面思考一下：若不遵守 LSP 如何？<br>以方法参数为例：若方法 <code>M</code> 有一个类型为类 <code>B</code> 的参数，如果类 <code>B</code> 的子类没有遵守 LSP，在调用方法 <code>M</code> 时传入了一个类 <code>B</code> 的子类，<code>M</code> 会出错。此时，为了不出错，方法 <code>M</code> 势必要对 <code>B</code> 的子类作特殊处理(<code>if...else...</code>)。<br>熟悉的味道！这是不是违反了 OCP！</p><blockquote><p>引自《敏捷软件开发》：对于 LSP 的违反往往会导致以明显违反 OCP 的方式使用运行时类型识别『RTTI』。</p></blockquote><h2 id="例1-正方形与长方形"><a href="#例1-正方形与长方形" class="headerlink" title="例1 正方形与长方形"></a>例1 正方形与长方形</h2><p>Bob 大叔在《敏捷软件开发》中有一个关于正方形和长方形的例子。<br>『正方形是一种特殊的长方形』，这可谓是常识。因此，让正方形类<code>Square</code>继承自长方形类<code>Rectangle</code>再合理不过。<br>然而在对待长度、宽度上，正方形与长方形似乎不那么一致：<br>正方形的长、宽必须相等，因此<code>Square</code>类必须重写其基类<code>Rectangle</code>的<code>setWidth</code>、<code>setHeight</code>方法来保证每次调用这两个方法后正方形的长宽依然相等。这看上去似乎也并无不妥，然而在下面这个方法中就有问题了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Rectangle &amp;r)</span> </span>&#123;</span><br><span class="line">    r.setWidth(<span class="number">5</span>);</span><br><span class="line">    r.setHeight(<span class="number">4</span>);</span><br><span class="line">    assert(r.area() == <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数<code>g</code>对于长方形的认知完全正确，然而若调用函数<code>g</code>时传入的是个<code>Square</code>类型的引用，就出错了！<br>很明显，<code>Square</code>与<code>Rectangle</code>间的继承关系违反了 LSP。</p><blockquote><p>引自《敏捷软件开发》：LSP 让我们得出一个非常重要的结论：一个模型，如果孤立地看，并不具有真正意义上的有效性。<strong>模型的有效性只能通过它的客户程序来表现。</strong>在考虑一个特定设计是否恰当时，不能完全孤立地来看这个解决方案。必须要根据该设计的使用者所做出的合理假设来审视它。<br><strong><em>因此，是否违反 LSP，在很大程度上取决于客户程序。</em></strong></p></blockquote><p><code>Square</code>与<code>Rectangle</code>间的继承之所以会违反 LSP，是因为在设置长、宽的行为上它们间不具备”IS-A”关系。</p><blockquote><p>引自《敏捷软件开发》：从行为方式的角度来看，<code>Square</code>不是<code>Rectangle</code>，对象的行为方式才是软件真正所关注的问题。LSP 清楚地指出，OOD 中 IS-A 关系是就行为方式而言的，行为方式是可以进行合理假设的，是客户程序所依赖的。</p></blockquote><h2 id="LSP-与多态"><a href="#LSP-与多态" class="headerlink" title="LSP 与多态"></a>LSP 与多态</h2><p>讨论 LSP 的前提就是多态，否则无从谈起。<br>然而，多态本质上就是子类的方法覆盖基类的虚函数。这与 LSP 要求的子类可以替换基类是否矛盾？因为通过基类指针最终调用的是子类的方法。<br>答案自是不矛盾，相反 LSP 能够更好地指导我们如何使用继承。<br>为了满足 LSP，子类只能对基类的功能进行扩展，而不能『篡改』。<br>这不正是『继承』的本质内涵吗！</p><p>因此，LSP至少有三点作用：</p><ul><li>实现 OCP 的重要保障之一；</li><li>降低继承带来的复杂度，继承只能扩展基类的功能，而非『篡改』(可以无差别的对待基类及其所有子类)；</li><li>在决定使用继承前，可以更好地判别两者是否真具有”IS-A”的关系。</li></ul><h2 id="启发式判断规则与改进方案"><a href="#启发式判断规则与改进方案" class="headerlink" title="启发式判断规则与改进方案"></a>启发式判断规则与改进方案</h2><p>LSP 有时是很微妙的，在开发过程中往往难于察觉。<br>Bob 大叔提出两个启发式规则供大家参考：</p><ul><li><p>派生类存在退化函数，如下述代码基类<code>Base</code>中的方法<code>f</code>是有功能的，但到其子类<code>Derived</code>中<code>f</code>退化为空方法，这往往预示违反了 LSP，值得警惕：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/*some code*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> calss Derived : Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从派生类中抛出异常，即从派生类的方法中抛出了基类不会抛出的异常，这往往是调用方不曾预料的。</p></li></ul><p>违反 LSP 说明继承已经不适合了，此时可以将这对『父子』中公共的代码提取出来。<br>之后要么让他们成为『兄弟』，都从提取的代码派生、要么以组合的方式集成提取的代码。</p><h1 id="接口隔离原则『ISP』"><a href="#接口隔离原则『ISP』" class="headerlink" title="接口隔离原则『ISP』"></a>接口隔离原则『ISP』</h1><hr><p> ISP：不应迫使客户程序依赖于它们不需要的接口。即，客户程序依赖的类中不应该含有其不需要的方法，从而降低系统的复杂度，减少类之间的耦合。<br>相反，若某客户程序依赖的类含有大量其不需要的方法，而这些方法又是其他客户程序所需的，当这些方法因需求需要变化时或需要添加新方法时，势必会殃及不需要这些方法的客户程序，从而增加系统的耦合度。<br>怎么解决？<br>当然是『隔离、拆分』接口了！<br>在支持接口/协议的语言(如Objective-C)中，很好处理，将类的公共方法分解到多个接口中；<br>而在像 C++ 这样不支持接口的语言中，可通过多继承、委托等方式分解接口。</p><h2 id="例1-UITableView-之-DataSource、Delegate"><a href="#例1-UITableView-之-DataSource、Delegate" class="headerlink" title="例1 UITableView 之 DataSource、Delegate"></a>例1 UITableView 之 DataSource、Delegate</h2><p>iOS 开发对 UITableView 恐是再熟悉不过了，其提供了两套接口：<code>UITableViewDataSource</code>、<code>UITableViewDelegate</code>。<br>从场景上说，这两套接口都是为 UITableView 提供服务的。<br>之所以要把它们分开，就是为了可以将为 UITableView 提供数据、处理用户交互的职责拆分到不同的类中。</p><h2 id="例2-QQ-阅读登录接口"><a href="#例2-QQ-阅读登录接口" class="headerlink" title="例2 QQ 阅读登录接口"></a>例2 QQ 阅读登录接口</h2><p>在『OCP』一节，简要介绍了 QQ 阅读的登录模块，我们知道具体的登录细节由<code>QRQQAuthenticator</code>、<code>QRWechatAuthenticator</code>以及<code>QRGuestAuthenticator</code>等处理。这些<code>Authenticator</code>都实现了<code>QRAuthenticatorDelegate</code>接口：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">QRAuthenticatorDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主动登录</span></span><br><span class="line">- (<span class="keyword">void</span>)authenticateWithCompletion:(QRAuthenticateCompletion)completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 续期</span></span><br><span class="line">- (<span class="keyword">void</span>)refreshTokenWithCompletion:(QRAuthenticateCompletion)completion;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>然而，对于 QQ 登录，在没有安装 QQ 时，需要<code>QRQQAuthenticator</code>作特殊处理。<br>由于这样的特殊处理只是 QQ 登录需要，因此把对应的接口放到<code>QRAuthenticatorDelegate</code>中是不合适的。<br>最终，我们将其定义为独立的接口<code>QRQQManuallyAuthenticationDelegate</code>：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">QRQQManuallyAuthenticationDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)manuallyAuthenticateWithAccount:(Account *)account;</span><br><span class="line">- (<span class="keyword">void</span>)checkVerifyCode:(<span class="built_in">NSString</span> *)verifyCode account:(Account *)account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>并让<code>QRQQAuthenticator</code>实现这两个接口：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QRQQAuthenticator</span> : <span class="title">NSObject</span>&lt;<span class="title">QRAuthenticatorDelegate</span>, <span class="title">QRQQManuallyAuthenticationDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>而<code>QRWechatAuthenticator</code>、<code>QRGuestAuthenticator</code>等只需实现<code>QRAuthenticatorDelegate</code>即可。</p><blockquote><p>对于 ISP 大家可能会有疑问：根据 SRP，类的职责应该是单一的，为何需要实现多个接口？<br>在现实中，确实存在从接口层面内聚性较低的类。如，例2中的<code>QRQQAuthenticator</code>类，正常的登录、续期需要处理，手动登录同样需要处理，在接口上就不具备高内聚的特征。<br>ISP 就是用于在此情况下指导如何拆分接口。</p></blockquote><h1 id="依赖倒置原则『DIP』"><a href="#依赖倒置原则『DIP』" class="headerlink" title="依赖倒置原则『DIP』"></a>依赖倒置原则『DIP』</h1><hr><p>在开发中，较大的模块一般会由几位同学协同开发，分工一般会按分层的方式进行。<br>此时，经常会听到负责低层模块的同学向负责高层模块的同学说：『我给你提供了这这几个方法，代码已提交，你看一下。』<br>从 DIP 的角度看，犯了两个错误！<br>其一，在制定双方接口上低层模块起了主导作用；其二，两者间缺少抽象。<br>DIP：</p><ul><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；</li><li>抽象不应该依赖于细节，细节应该依赖于抽象。</li></ul><p>依赖倒置原则其中的『倒置』强调的就是高层模块与低层模块间的关系：<strong>高层模块作为需求方提出需求(提出接口)，低层模块去实现高层模块提出的需求(接口)。</strong><br>为何？</p><ul><li>高层模块不应知道低层模块的细节；</li><li>若是由低层模块制定接口，很可能不由自主地将实现细节曝露在接口中，这是我们不希望看到的。</li></ul><h2 id="例1-分页加载"><a href="#例1-分页加载" class="headerlink" title="例1 分页加载"></a>例1 分页加载</h2><p>在<a href="https://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/">列表类应用场景模板化</a>一文中，我们提到『大多数 App 的大多数应用场景都是列表类的』，分页加载是列表类应用场景的标配。<br>那么在制定接口时，若由低层模块(Model)负责，很可能会将分页的细节曝露在接口中：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestMoreDataWithPageStamp:(<span class="built_in">NSInteger</span>)pageStamp completion:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *, <span class="keyword">id</span>))completion;</span><br></pre></td></tr></table></figure></p><p>很明显，<code>pageStamp</code>是 Model 与服务端交互的细节，是高层模块不关心，也不应关心的问题。<br>若是由高层模块(Controller)提出需求(接口），接口可能会是这样：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestMoreDataWithCompletion:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *, <span class="keyword">id</span>))completion;</span><br></pre></td></tr></table></figure></p><p>当然，这个例子较简单，稍有经验的开发人员也不会在接口中曝露pageStamp信息。<br>但，由低层模块制定接口会曝露细节的问题值得关注。</p><h2 id="例2-通过抽象解耦高、低层模块"><a href="#例2-通过抽象解耦高、低层模块" class="headerlink" title="例2 通过抽象解耦高、低层模块"></a>例2 通过抽象解耦高、低层模块</h2><p>同时，DIP 提出高层模块与低层模块不能直接有依赖关系，它们都应依赖于抽象(接口)。<br>如此可使得高层模块与低层模块解耦，促使高层模块具有更好的可复用性。<br><img src="/img/ListSceneClassDiagram.png" alt=""><br>上图是在<a href="https://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/">『列表类应用场景模板化』</a>一文中介绍的列表类模块的类图。<br>其中，Controller 与 Manager 、Controller 与 Module 间都是面向接口编程(依赖于抽象)。<br>在 QQ 阅读中，书籍分为 txt 和精排两种格式，它们都支持批量下载。在展示、用户交互上两者并无太大区别，但背后的业务逻辑却大不相同。<br>因此，批量下载的 Controller 可以复用，但 Manager 不可。<br>通过 DIP 可以很方便的隔离 Controller 与 Manager，使批量下载的 Controller 在两种格式间复用。</p><p>DIP 可以说是 SOLID 中实现成本最小的原则，但其带来的收益却十分可观，因此，DIP 应该是我们自始至终都应遵守的原则。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>综观 S、O、L、I、D 五大原则，本质上它们都是帮助我们降低软件系统的复杂度。只不过，各自关注的维度不同：</p><ul><li>SRP：要求软件实体(模块、类、方法)只有单一的职责，降低实体的复杂度，提高实体的内聚性；</li><li>OCP：要求软件实体对扩展开放、对修改封闭，使得软件系统在扩展功能时，减少对系统已有部分的影响；</li><li>LSP：对继承关系提出要求，子类须可替换基类，降低继承带来的复杂度以及减少误用继承的可能；</li><li>ISP：将复杂接口拆分开来，避免强迫高层模块依赖于其不需要的接口，减少不必要的耦合；</li><li>DIP：避免由低层模块制定接口时无意曝露低层细节，通过抽象解耦高层与低层模块。</li></ul><p>正如本文标题，『以 SOLID 为友』，笔者认为真正的朋友无须天天挂在嘴边、嘘寒问暖，而是在有困难时能雪中送炭。<br>SOLID 之于开发亦是如此，无须天天挂在嘴边，而是在遇到问题时，能通过它们解决问题。</p><p>参考资料：<br><a href="https://book.douban.com/subject/1140457/" target="_blank" rel="noopener">《敏捷软件开发——原则、模式与实践》</a><br><a href="https://book.douban.com/subject/1436745/" target="_blank" rel="noopener">《Design Patterns: Elements of Reusable Object-Oriented Software》</a><br><a href="https://book.douban.com/subject/1229923/" target="_blank" rel="noopener">《重构——改善既有代码的设计》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细分析了面向对象设计五大原则 S(单一职责原则『SRP』)、O(开放-封闭原则 『OCP』)、L(Liskov 替换原则『LSP』)、I(接口隔离原则『ISP』)、D(依赖倒置原则『DIP』)，并假以实例辅之。&lt;br&gt;
    
    </summary>
    
    
      <category term="OOD" scheme="http://zxfcumtcs.github.io/tags/OOD/"/>
    
      <category term="设计模式" scheme="http://zxfcumtcs.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="敏捷开发" scheme="http://zxfcumtcs.github.io/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>列表类应用场景模板化</title>
    <link href="http://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/"/>
    <id>http://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/</id>
    <published>2018-09-17T15:05:02.000Z</published>
    <updated>2018-12-15T10:16:34.640Z</updated>
    
    <content type="html"><![CDATA[<p>由于列表类应用场景具有固定的流程和模式，本文首先简要介绍了 QQ 阅读中列表类应用场景的架构，然后提出对这一场景进行模板化，以便提高开发效率、减少沟通理解成本。<br>同时，提出一套基于 『Chain of Responsibility』 的事件处理方案，也在一定程度上提高了开发效率，减少了琐碎代码量。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>2009年作为移动互联网开发元年至今已过去十年，移动客户端开发技术也已从拓荒时代进化到成熟稳定阶段。十年间，数以万计的 App 被创造出来。然而，细观市面上的 App 会发现大多数及至绝大多数 App 的大多数及至绝大多数应用场景都是列表类的。<br>所谓列表类应用场景主要有以下几个特征：</p><ul><li>以 UITableView 展示多条数据；</li><li>数据不变，仅用于展示，或只有很少的状态变化；</li><li>没有复杂的用户交互(如：UGC)。</li></ul><p>从上述特征可知，所有列表类应用场景都具有『相同的代码结构』，也就意味着我们经常在做一些重复性的工作。<br>同时，『相同的代码结构』也意味着可以将其模板化。通过模板化列表类应用场景至少有以下两点收益：</p><ul><li>提高工作效率，减少重复性劳动；</li><li>统一代码结构，减少项目组内理解沟通成本。</li></ul><h1 id="QQ-阅读列表类应用场景架构简述"><a href="#QQ-阅读列表类应用场景架构简述" class="headerlink" title="QQ 阅读列表类应用场景架构简述"></a>QQ 阅读列表类应用场景架构简述</h1><hr><p>列表类应用场景其流程无外乎：从网络或本地磁盘获取数据，再将数据以列表(tableview)的形式展示出来，其中最主要的交互就是点击进入次级页面。<br>每个项目团队可能都有一套用于列表类场景的架构，在 QQ 阅读不断迭代的过程中我们也演化出了一套相关的架构。本文会以这套架构为例讲述模板化的思路。</p><blockquote><p>使用什么样的架构不是重点，重点是将使用的架构模板化的思路。</p></blockquote><p><img src="/img/ListSceneClassDiagram.png" alt=""><br><img src="/img/ListSceneTimingDiagram.png" alt=""><br>上图分别是我们这套架构的关键类图和时序图。整体上是由经典 MVC 模式演化而来：</p><ul><li>Manager(Interface)：对应 MVC 中的 Model 『层』，主要负责数据的获取、管理等；</li><li>Controller：各个模块的协调枢纽；</li><li>Cell/View：对应 MVC 中的 View，仅仅负责 UI 布局逻辑；</li><li>ViewModel：处理 UI 展示相关的业务逻辑(详细信息请参看之前的文章<a href="https://zxfcumtcs.github.io/2017/03/04/CustomUIControls/">『自定义 UI 组件库』</a>)；</li><li>Module(Interface)： 将其称之为『业务模块』，一个页面由多个不同或相同类型的模块组成。如 QQ 阅读精选页的『今日必读』、『今日秒杀』等都是模块。</li></ul><p><img src="/img/RecommendedToday.jpeg" alt=""><br><img src="/img/TodaySecondKill.jpeg" alt=""><br>当然 Module 也可以是一个简单的样式：<br><img src="/img/SimpleStyle.jpeg" alt=""><br>在 TableView 中一个 Module 对应一个 section。Module 的职责主要有：网络数据的解析、 为 TableView datasource 提供数据(如：创建 cell 等)、处理用户事件——即负责『模块』的所有业务逻辑(与 React Component 类似)。</p><blockquote><p>Module 的存在主要是减轻 Controller 的负担。</p></blockquote><p>通常情况下，Manager(Model)存储的是纯粹的业务数据(从网络拉取的数据)，这样就需要在业务数据与 Module『模块』 间建立映射关系。为了省去这层映射，直接由 Module 解析、存储业务数据。<br>这种做法也存在弊端，由于将网络数据的解析、控制 UI 展示的逻辑(创建 cell 等)都放在了 Module 中。使得 Module 违反了『单一职责原则』。</p><blockquote><p>『单一职责原则』(SRP)作为面向对象设计的五大原则『SOLID』之一，很容易理解，也很难把握！『就好像生活中的各种”适量”，适量放点盐、适量加点水…』<br> Bob大叔在《敏捷软件开发》中，将类的单一职责原则描述为『应该仅有一个引起它变化的原因』。</p></blockquote><p>在 Module 中，网络数据解析、UI 展示就是两个可变的原因——『同样的 UI 用于展示不同的网络协议返回的数据、同一协议返回的数据展示为不用的 UI』。<br>在 QQ 阅读中，书籍列表页就属于『同样的 UI 展示不同协议返回的数据』：<br><img src="/img/BookList.jpeg" alt=""><br>针对这种情况，无非就是将其中一个变化因子抽取出来，可以将网络数据解析抽取为一个单独的类。<br>由于Module 中这两个变化因子变动的概率并不大，为了降低复杂度，在模板中并没有将这两者分离开。</p><blockquote><p>『敏捷开发』的原则之一就是尽量保持代码简单、并在必要时进行重构，防止代码变坏。</p></blockquote><h1 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h1><hr><p>通过上述介绍可知，Controller、Manager、API 的代码基本是固定的——可以模板化，另外 View-ViewModel 是可以高度复用的。所以模板化后新增一个列表类应用场景的主要工作集中在 Module 上。</p><blockquote><p>所谓模板化就是提供一套代码模板，在实例化时将模板中的『Template』关键字替换成业务名。</p></blockquote><p>我们这套模板中有：Manager、Module、View 以及 API 四个目录，ZSTemplateManager.m(.h)、ZSTemplateViewController.m(.h) 以及 ZSTemplateAPI.m(.h)六个文件，其中可以模板化的代码主要有：</p><ul><li>Controller：设置 tableview(含下拉、上拉、datasource、delegate)、设置导航栏、错误\空数据处理、向 manager 发送请求数据的调用、事件处理等；</li><li>Manager：管理 module、向 API 发送网络请求、缓存处理等；</li><li>API：发送网络请求。</li></ul><p>也就是模板化后上述功能可以通过转换脚本一键生成，不用重复地写这些代码。尤其是 Controller 基本可以直接使用。</p><blockquote><p>转换脚本、demo 已提交到 github 上<a href="https://github.com/zxfcumtcs/ZSTemplatedListScene" target="_blank" rel="noopener">『ZSTemplatedListScene』</a>。转换脚本的功能就是将模板中的『Template』关键字替换为业务名(包括代码和文件名中的)。如，demo 中的通信录业务：<img src="/img/transformsh.jpeg" alt="">注：demo 中的模板仅是个『demo』，其中的网络请求、缓存等功能可替换为项目中统一的模块。</p></blockquote><p>总之，通过转换脚本可以一键生成部分代码，提高了开发效率。同时，通过模板也规范了代码结构，减少了项目组沟通理解成本。</p><h1 id="基于-Chain-of-Responsibility-事件处理方案"><a href="#基于-Chain-of-Responsibility-事件处理方案" class="headerlink" title="基于 Chain of Responsibility 事件处理方案"></a>基于 Chain of Responsibility 事件处理方案</h1><hr><p>目前的事件处理有2个痛点，于是才有了基于 Chain of Responsibility 的事件处理方案。</p><ul><li><p>痛点1<br><img src="/img/ViewHierarchy.png" alt=""><br>大多数场景下 View 的层级结构如上图所示。我们知道，View 一般不处理用户事件，需要逐级传递给 Controller，因此需要沿着上图的层级结构逐级传递处理事件的 delegate。这种单调重复琐碎的代码有种令人不悦的感觉：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell.delegate <span class="built_in">=</span> controller;</span><br><span class="line">view.delegate <span class="built_in">=</span> cell;</span><br><span class="line">…</span><br></pre></td></tr></table></figure></li><li><p>痛点2<br>随着版本的迭代，不同类型的 cell/view 极有可能出现不同的事件处理接口，如下图所示：<br><img src="/img/celldelegate.jpeg" alt=""><br>这严重违反了面向对象设计的开闭原则(Open-Closed)——每增加一种 cell 类型此处都需要修改。</p></li></ul><p>尤其是第一点一直困扰着我。直到前不久在《Design Patterns》一书中看到在介绍『Chain of Responsibility』模式时的一句话：『Using existing links works well when the links support the chain you need. It saves you from defining links explicitly, and it saves space』。<br><code>UIResponder</code> 中的 <code>nextResponder</code>不正是这个『existing links』吗！<br>最上层 View 的事件通过<code>nextResponder</code>链就可以顺利传到 ViewController 中，从而也就省去了 delegate 的逐级传递了，痛点1、2随之化解。<br>为此，我们为 <code>UIResponder</code>添加了传递、处理事件的分类：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZSCEvent</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) __kindof <span class="built_in">UIResponder</span> *sender;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *indexPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *userInfo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIResponder</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIResponder</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.nextResponder respondEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>UIResponder</code>的实现只是简单地将事件传递给<code>nextResponder</code>。<br>由于 View 不包含业务数据，所以事件传递的过程中需要不断添加一些信息。</p><blockquote><p>因此，我们将<code>ZSCEvent#userInfo</code>定义为 mutable。正常情况下外露接口一般都是 immutable。</p></blockquote><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableViewCell</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.nextResponder respondEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>如，在<code>UITableViewCell</code>的<code>respondEvent:</code>中需要将<code>sender</code>设置为<code>self</code>，以便在<code>UIViewController</code>中可以通过<code>cell</code>找到对应的 module。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([event.sender isKindOfClass:<span class="built_in">UITableViewCell</span>.class], <span class="string">@"event sender must be UITableViewCell"</span>);</span><br><span class="line">    <span class="keyword">if</span> (![event.sender isKindOfClass:<span class="built_in">UITableViewCell</span>.class]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = [_tableView indexPathForCell:event.sender];</span><br><span class="line">    <span class="keyword">id</span>&lt;ZSModule&gt; module = [<span class="keyword">self</span>.manager moduleAtIndex:indexPath.section];</span><br><span class="line">    </span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    event.indexPath = indexPath;</span><br><span class="line">    [event.userInfo setObject:_tableView</span><br><span class="line">                       forKey:ZSCEventUserInfoKeys.tableView];</span><br><span class="line">    </span><br><span class="line">    [module handleEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 View 中的事件处理代码可以这样：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_clickedButton:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    ZSCEvent *event = [[ZSCEvent alloc] init];</span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    [event.userInfo setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"clickedButton"</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> respondEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果一个 cell 中有多个事件需要处理，就需要在<code>userInfo</code>中加以区分，如上面代第<code>5</code>行。</p></blockquote><p>总之，通过<code>UIResponder</code>的<code>nextResponder</code>响应链，不必再在 view 的层级间传递 delegate，减少了琐碎的代码，提高了开发效率。同时也统一规范了事件处理方案。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>提升开发效率、规范代码结构一直是我们追求的目标。文本通过对列表类应用场景模板化以及通过『Chain of  Responsibility』机制处理用户事件，在一定程度上提高了开发效率并规范了代码结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于列表类应用场景具有固定的流程和模式，本文首先简要介绍了 QQ 阅读中列表类应用场景的架构，然后提出对这一场景进行模板化，以便提高开发效率、减少沟通理解成本。&lt;br&gt;同时，提出一套基于 『Chain of Responsibility』 的事件处理方案，也在一定程度上提高了开发效率，减少了琐碎代码量。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="架构" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>简述 ReactNative Bundle</title>
    <link href="http://zxfcumtcs.github.io/2018/05/11/RNBundle/"/>
    <id>http://zxfcumtcs.github.io/2018/05/11/RNBundle/</id>
    <published>2018-05-11T15:04:48.000Z</published>
    <updated>2018-12-08T08:41:32.860Z</updated>
    
    <content type="html"><![CDATA[<p>本文因项目实际问题而起，简要分析了 RN Bundle 的结构。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="引"><a href="#引" class="headerlink" title="引"></a>引</h1><hr><p>原本计划在完成『<a href="https://zxfcumtcs.github.io/2018/02/03/RNRendering/">ReactNative源码解析——渲染机制详解</a>』一文后，暂停 RN 相关的总结分享，谁料项目中通过RN分包同时加载两个业务 bundle 时出错了！索性对 RN Bundle 研究一番，遂总结出此文。</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>使用 ReactNative 开发的业务，无论是通过内置还是动态下发的方式发布，都需要将业务 JavaScript 代码打包成 bundle。<br>JavaScript 作为一门静态脚本语言，为何需要打包这个过程？<br>打包主要有以下几个用途：</p><ul><li>开发 RN 业务时，一般会使用 JSX 语法『糖』描述 UI 视图，然而标准的 JS 引擎显然不支持 JSX，所以需要将 JSX 语法转换成标准的 JS 语法；</li><li>开发 RN 业务时，通常使用的是 ES 6，目前 iOS、Android 上的 JS 引擎还不支持 ES 6，因此需要转换；</li><li>JS 业务代码会依赖多个不同的模块(JS 文件)，RN 在打包时将所有依赖的模块打包到一个 bundle 文件中，较好地解决了这种复杂的依赖关系；</li><li>JS 代码的混淆。</li></ul><blockquote><p>RN 打包过程中的转码主要依赖 <a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 实现。</p></blockquote><h1 id="ReactNative-Bundle"><a href="#ReactNative-Bundle" class="headerlink" title="ReactNative Bundle"></a>ReactNative Bundle</h1><hr><p>RN Bundle 从本质上讲是一个 JS 文件，其主要由三部分组成：polyfills、module 定义、require 调用。<br><img src="/img/RNBundle.png" alt=""></p><h2 id="Polyfills"><a href="#Polyfills" class="headerlink" title="Polyfills"></a>Polyfills</h2><p>polyfills 部分主要是在 JS context 中做一些准备工作，如：声明 ES 6 语法中新增接口、定义模块方法(如：模块声明方法<code>__d</code>、模块引用方法<code>require</code>等)、设置<code>global.__DEV__</code>变量等。<br><img src="/img/Polyfills.jpeg" alt=""><br>如上图，polyfills 都闭包方法，定义的同时被调用。<br>polyfill具体规则定义在node_modules/metro-bundler/src/defaults.js中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">exports.polyfills = [</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Object.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/console.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/error-guard.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Number.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/String.prototype.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Array.prototype.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Array.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Object.es7.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/babelHelpers.js'</span>)];</span><br></pre></td></tr></table></figure></p><blockquote><p>defaults.js中还有其他有意思的信息^_^</p></blockquote><h2 id="module-definitions"><a href="#module-definitions" class="headerlink" title="module definitions"></a>module definitions</h2><p>为了更直观的了解 RN Bundle 中模块的定义，我们先来看一个例子：<br><img src="/img/RNDemo.jpeg" alt=""><br>如上图一个非常简单的 RN Demo，在打包生成的 bundle 中变成如下的格式：<br><img src="/img/RNMoudleBundle.jpeg" alt=""><br>很明显，为了看懂上图所示的打包结果，必须先了解一下<code>__d</code>为何物，细心的同学，可能已经在 polyfills 小节中发现了<code>__d</code>的定义(第<code>12</code>行)，即<code>__d</code>就是<code>define</code>方法，其完整的源码定义在：<code>node_modules/metro-bundler/src/Resolver/polyfills/require.js</code>中(代码略有删减)：<br><figure class="highlight js"><figcaption><span>node_modules/metro-bundler/src/Resolver/polyfills/require.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">global.require = <span class="built_in">require</span>;</span><br><span class="line">global.__d = define;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> modules = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">factory, moduleId, dependencyMap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (moduleId <span class="keyword">in</span> modules) &#123;</span><br><span class="line">        <span class="comment">// that are already loaded</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    modules[moduleId] = &#123;</span><br><span class="line">        dependencyMap,</span><br><span class="line">        exports: <span class="literal">undefined</span>,</span><br><span class="line">        factory,</span><br><span class="line">        hasError: <span class="literal">false</span>,</span><br><span class="line">        isInitialized: <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到<code>define</code>方法前三个参数分别为：<code>factory</code> 方法、module ID以及dependencyMap。<br><strong>调用<code>define</code>方法定义模块，实质就是以 moduleID 为 key 向模块注册表(<code>modules</code>)中注册模块相关的信息(<code>exports</code>、模块<code>factory</code>方法、<code>isInitialized</code>等)。</strong><br>好了，下面我们再次回到 RN Bundle 中 module definition。</p><h3 id="module-ID"><a href="#module-ID" class="headerlink" title="module ID"></a>module ID</h3><p>在 RN 中，为了唯一标识每个模块，解决模块间的依赖问题，在打包生成 bundle 时，为每个 module 生成一个唯一的 moduleID，moudleID 为从0开始递增的数字。<br>另外，RN 在打包 bundle 时，按模块间依赖关系深度遍历(弦外之音就是，根组件的 moduleID 为0)。</p><h3 id="module-factory"><a href="#module-factory" class="headerlink" title="module factory"></a>module factory</h3><p>从上图可知，module factory 方法主要做了以下几件事：</p><ul><li><strong>所有 <code>import</code> 转换为<code>require</code>方法调用(<code>import</code>是 ES 6新增语法，需要转换)(第<code>58</code>、<code>60</code>行)；</strong></li><li><strong>创建组件类(第<code>62~83</code>行)，其中最关键的方法就是<code>render</code>；</strong></li><li><strong>导出(exports)组件类(第<code>85</code>行)；</strong></li><li><strong>注册根组件(第<code>87~89</code>行)，详细信息请参看<a href="https://zxfcumtcs.github.io/2018/02/03/RNRendering/">ReactNative源码解析——渲染机制详解</a>一文。</strong></li></ul><blockquote><p>通过 module factory 中的 <code>render</code>方法，再次看到 JSX 标签被转换成了<code>createElement</code>方法调用。</p></blockquote><h2 id="require-calls"><a href="#require-calls" class="headerlink" title="require calls"></a>require calls</h2><p>RN Bundle 最后部分是 require calls：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;<span class="built_in">require</span>(<span class="number">50</span>);  <span class="comment">// InitializeCore.js</span></span><br><span class="line">;<span class="built_in">require</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p><code>require</code>方法参数为 moduleID，RN Bundle 最后这两个<code>require</code>调用分别加载了<code>InitializeCore</code>以及<code>RNDemo</code>(根组件)模块。<br>下面我们来看看，<code>require</code>具体做了哪些事(与模块定义方法<code>define</code>定义在同一文件中)：<br><figure class="highlight js"><figcaption><span>node_modules/metro-bundler/src/Resolver/polyfills/require.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = modules[moduleId];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.isInitialized ?</span><br><span class="line">    <span class="built_in">module</span>.exports :</span><br><span class="line">    guardedLoadModule(moduleIdReallyIsNumber, <span class="built_in">module</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">guardedLoadModule</span>(<span class="params">moduleId, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadModuleImplementation(moduleId, <span class="built_in">module</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadModuleImplementation</span>(<span class="params">moduleId, module</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">module</span>.isInitialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> exports = <span class="built_in">module</span>.exports = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> _module = <span class="built_in">module</span>;</span><br><span class="line">    <span class="keyword">const</span> factory = _module.factory, dependencyMap = _module.dependencyMap;</span><br><span class="line">    <span class="keyword">const</span> moduleObject = &#123; exports &#125;;</span><br><span class="line">    factory(global, <span class="built_in">require</span>, moduleObject, exports, dependencyMap);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports = moduleObject.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上代码所示，<code>require</code>方法首先判断所要加载的模块是否已经存在并初始化完成。若是，则直接返回模块的<code>exports</code>，否则调用<code>guardedLoadModule</code>方法(最终调用的是<code>loadModuleImplementation</code>方法)。<br><code>loadModuleImplementation</code>方法获得模块的<code>factory</code>方法并调用，最终返回模块的<code>exports</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从上文的分析可知，加载一个 RN Bundle，主要完成三件事：</p><ul><li>准备 JS 执行环境(polyfills)；</li><li>定义所有需要的模块(module define)；</li><li>加载<code>InitializeCore</code>以及根组件模块(require)。</li></ul><p>通过上文分析，应该能清楚的区分模块定义与加载的关系：</p><ul><li>模块定义(define)：将模块相关的信息(其中最重要的就是<code>factory</code>方法)添加到模块注册表中，仅此而已；</li><li>模块加载(require)：在 JS context 中调用模块<code>factory</code>方法，创建模块类并在组件注册表中注册根组件。</li></ul><p>以盖房子作比喻：</p><ul><li>模块定义：将盖房子需要的材料运入场地；</li><li>模块加载：真正地将房子盖起来。</li></ul><p>ps：上文所示的 RN Bundle 都是开发环境下打出来的(打包命令中<code>--dev</code>为 true)，这样的 Bundle 是没有经过混淆的，其可读性较好。经过混淆的 Bundle，大概长这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;e.__DEV__=!<span class="number">1</span>,e.__BUNDLE_START_TIME__=e.nativePerformanceNow?e.nativePerformanceNow():<span class="built_in">Date</span>.now()&#125;(<span class="string">"undefined"</span>!=<span class="keyword">typeof</span> global?global:<span class="string">"undefined"</span>!=<span class="keyword">typeof</span> self?self:<span class="keyword">this</span>);</span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;<span class="string">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">r,e,t</span>)</span>&#123;e <span class="keyword">in</span> u||(u[e]=&#123;<span class="attr">dependencyMap</span>:t,<span class="attr">exports</span>:<span class="keyword">void</span> <span class="number">0</span>,<span class="attr">factory</span>:r,<span class="attr">hasError</span>:!<span class="number">1</span>,<span class="attr">isInitialized</span>:!<span class="number">1</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">r</span>)</span>&#123;<span class="keyword">var</span> e=r,t=u[e];<span class="keyword">return</span> t&amp;&amp;t.isInitialized?t.exports:i(e,t)&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">if</span>(!c&amp;&amp;r.ErrorUtils)&#123;c=!<span class="number">0</span>;<span class="keyword">var</span> i=<span class="keyword">void</span> <span class="number">0</span>;<span class="keyword">try</span>&#123;i=n(e,t)&#125;<span class="keyword">catch</span>(e)&#123;r.ErrorUtils.reportFatalError(e)&#125;<span class="keyword">return</span> c=!<span class="number">1</span>,i&#125;<span class="keyword">return</span> n(e,t)&#125;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">e,i</span>)</span>&#123;<span class="keyword">var</span> n=r.nativeRequire;<span class="keyword">if</span>(!i&amp;&amp;n&amp;&amp;(n(e),i=u[e]),!i)<span class="keyword">throw</span> o(e);<span class="keyword">if</span>(i.hasError)<span class="keyword">throw</span> a(e,i.error);i.isInitialized=!<span class="number">0</span>;<span class="keyword">var</span> c=i.exports=&#123;&#125;,d=i,s=d.factory,f=d.dependencyMap;<span class="keyword">try</span>&#123;<span class="keyword">var</span> l=&#123;<span class="attr">exports</span>:c&#125;;<span class="keyword">return</span> s(r,t,l,c,f),i.factory=<span class="keyword">void</span> <span class="number">0</span>,i.dependencyMap=<span class="keyword">void</span> <span class="number">0</span>,i.exports=l.exports&#125;<span class="keyword">catch</span>(r)&#123;<span class="keyword">throw</span> i.hasError=!<span class="number">0</span>,i.error=r,i.isInitialized=!<span class="number">1</span>,i.exports=<span class="keyword">void</span> <span class="number">0</span>,r&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">r</span>)</span>&#123;<span class="keyword">var</span> e=<span class="string">'Requiring unknown module "'</span>+r+<span class="string">'".'</span>;<span class="keyword">return</span> <span class="built_in">Error</span>(e)&#125;<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">r,e</span>)</span>&#123;<span class="keyword">var</span> t=r;<span class="keyword">return</span> <span class="built_in">Error</span>(<span class="string">'Requiring module "'</span>+t+<span class="string">'", which threw an exception: '</span>+e)&#125;r.require=t,r.__d=e;<span class="keyword">var</span> u=<span class="built_in">Object</span>.create(<span class="literal">null</span>),c=!<span class="number">1</span>&#125;(<span class="string">"undefined"</span>!=<span class="keyword">typeof</span> global?global:<span class="string">"undefined"</span>!=<span class="keyword">typeof</span> self?self:<span class="keyword">this</span>);</span><br><span class="line">__d(<span class="function"><span class="keyword">function</span>(<span class="params">e,t,r,l</span>)</span>&#123;<span class="built_in">Object</span>.defineProperty(l,<span class="string">"__esModule"</span>,&#123;<span class="attr">value</span>:!<span class="number">0</span>&#125;);<span class="keyword">var</span> n=t(<span class="number">12</span>),s=babelHelpers.interopRequireDefault(n),a=t(<span class="number">24</span>),o=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> babelHelpers.classCallCheck(<span class="keyword">this</span>,t),babelHelpers.possibleConstructorReturn(<span class="keyword">this</span>,(t.__proto__||<span class="built_in">Object</span>.getPrototypeOf(t)).apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>))&#125;<span class="keyword">return</span> babelHelpers.inherits(t,e),babelHelpers.createClass(t,[&#123;<span class="attr">key</span>:<span class="string">"render"</span>,<span class="attr">value</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> s.default.createElement(a.View,&#123;<span class="attr">style</span>:styles.container&#125;,s.default.createElement(a.Text,<span class="literal">null</span>,<span class="string">"This is a demo"</span>))&#125;&#125;]),t&#125;(s.default.Component);l.default=o,a.AppRegistry.registerComponent(<span class="string">"RNDemo"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> o&#125;)&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><hr><p>好了，本文既然是因问题而起，最后简要介绍一下遇到的问题：<br><img src="/img/RNDemoError.jpeg" alt=""><br>问题的描述很清楚是根组件没有注册，由于刚刚分析完 RN 的渲染机制，知道这个错误描述的出处(来自<code>AppRegistry</code>模块的<code>runApplication</code>方法)：<br><img src="/img/runApplicationError.jpeg" alt=""><br>问题也很明显是在组件注册表<code>runnables</code>中找不到要运行的根组件。<br>起初我们怀疑是因为两个业务 bundle 有冲突在加载时出错了。<br>但 debug 下来并没有出错提示。<br>最终请教相关人士，得知是两个业务 bundle ID 一样，导致第二个 bundle 没有被正确定义(<code>define</code>方法首先通过要定义的模块 ID 判断该 ID 是否已注册，若已注册直接返回)。</p><blockquote><p>两个业务 bundle ID 会一样与我们使用的拆包方案有关。</p></blockquote><p>问题清楚了，修改就简单了，在此不细述了。</p><blockquote><p>通过这个问题，也说明了对底层实现方案了解的必要性。了解的越深，在遇到问题时思考的视角就会越广。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文因项目实际问题而起，简要分析了 RN Bundle 的结构。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="框架" scheme="http://zxfcumtcs.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ReactNative" scheme="http://zxfcumtcs.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative源码解析——渲染机制详解</title>
    <link href="http://zxfcumtcs.github.io/2018/02/03/RNRendering/"/>
    <id>http://zxfcumtcs.github.io/2018/02/03/RNRendering/</id>
    <published>2018-02-03T03:09:19.000Z</published>
    <updated>2018-12-08T08:41:32.862Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过解读 ReactNative 源码，简要分析了 ReactNative 通过 JS 创建、控制 Native 界面的过程。同时，为了完整性，我们也简单介绍了 JSX、 React Element 以及 React Component 等基本概念。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>目前移动端开发模式主要有：Native、Web、Hybrid 三种。其中，由 Web、Hybrid 开发的页面与 Native 有本质的区别，其最终呈现给用户的是 html 页面。<br>React Native 作为近几年新兴的开发模式，由于具有跨平台、动态更新等特性，备受关注。</p><blockquote><p>Build native mobile apps using JavaScript and React</p></blockquote><p>React Native 官方给出的定义，高度概括了其特征：</p><ul><li>RN 开发的 App 是以 React 为框架，通过 JS 实现业务逻辑；</li><li>最终开发出来的页面是纯 Native 的(即呈现给用户的是货真价实的 Native 页面)。</li></ul><p>RN 如何通过 JS 构造 Natvie 页面，正是本文分析的主题。</p><h1 id="JSX-amp-React-Element-amp-React-Component"><a href="#JSX-amp-React-Element-amp-React-Component" class="headerlink" title="JSX &amp; React Element &amp; React Component"></a>JSX &amp; React Element &amp; React Component</h1><hr><p>在开始前，有必要先简要介绍一下 JSX 、React Element 以及 React Component，三者都是来自 React 框架。</p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>JSX 可以简单理解为 JavaScript + XML 的语法糖，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;</span><br><span class="line">          Welcome to React Native!</span><br><span class="line">        &lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于 JSX 仅是一种语法糖，将 JSX 打包生成 bundle 时，通过 Babel JSX 会被转换成标准的 JavaScript 语法。上述 JSX 代码转换后如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(</span><br><span class="line">      View,</span><br><span class="line">      &#123; <span class="attr">style</span>: styles.container &#125;,</span><br><span class="line">      React.createElement(</span><br><span class="line">        Text,</span><br><span class="line">        &#123; <span class="attr">style</span>: styles.welcome &#125;,</span><br><span class="line">        <span class="string">'Welcome to React Native!'</span></span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p> 通过 <a href="https://babeljs.io/repl/#?presets=react&amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA" target="_blank" rel="noopener">『online Babel compiler』</a>可在线实时演示 JSX to JavaScript 的转换。</p></blockquote><p><strong>通过上述转换前后对比可知，JSX 中每个标签都会转换成 <code>React.createElement</code> 调用。</strong></p><blockquote><p>JSX 并不是必须的，可直接调用<code>React.createElement</code>。当然，更加推荐使用 JSX，因其可以更好、更清晰地表达视图层次结构。另外，JSX 是在打包过程中被转换成标准 JavaScript，因此不会有性能问题。</p></blockquote><h2 id="React-Element"><a href="#React-Element" class="headerlink" title="React Element"></a>React Element</h2><blockquote><p>Elements are the smallest building blocks of React apps.</p></blockquote><p>Element(元素)，是 React 中最小的构建单元，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br></pre></td></tr></table></figure></p><h2 id="React-Component"><a href="#React-Component" class="headerlink" title="React Component"></a>React Component</h2><p>组件 (Component) 在 React 中是一个非常重要的概念，就像在 OOP 世界里一切皆对象，在 React 中一切皆 Component。</p><blockquote><p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. ——<a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">『React.Component』</a><br>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display. Instead of artificially separating technologies by putting markup and logic in separate files, React separates concerns with loosely coupled units called “components” that contain both.——<a href="https://reactjs.org/docs/introducing-jsx.html#why-jsx" target="_blank" rel="noopener">『Why JSX?』</a></p></blockquote><p>从 React 官方的这两个描述可以总结一下 React Component 的特征：</p><ul><li>独立的、可复用的 UI 单元；</li><li>除了 UI 渲染，根据<a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">『Separation of Concerns (SoC)』</a>设计原则，Component 还需要处理其他业务逻辑，如：用户事件、状态变化、数据展示预处理等。</li></ul><blockquote><p>与此相反，在 Native 开发中，为了提高可复用性，强调将 UI 渲染 (View) 与业务逻辑 (ViewModel) 分离，同时用户事件处理需要在 Controller 中完成。而 React Component 其实更强调的是<strong>独立</strong>与<strong>分离</strong>。</p></blockquote><p>我们在自定义 Component 时，一般继承自抽象基类<code>React.Component</code>，同时需要实现<code>render()</code>方法。通过<code>render()</code>方法可知，React Component 是由 React Element 构成的。</p><blockquote><p>关于 Component 定义、使用相关的细节问题，在此不再赘述，详情可参考<a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">React.Component</a>、<a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">Components and Props</a></p></blockquote><p>在 RN 中，根组件(root components)需要通过<code>AppRegistry#registerComponent</code>方法进行注册。所谓根组件，可以简单理解为 Native to RN 的入口，Native 在加载 RN bundle 之后可通过<code>AppRegistry#runApplication</code>方法运行指定的根组件，从而进入 RN 的世界。</p><h1 id="Native-UI-Components"><a href="#Native-UI-Components" class="headerlink" title="Native UI Components"></a>Native UI Components</h1><hr><p>我们知道，通过 RN 实现的功能最终呈现给用户的是纯 Native 页面，这些 Native 页面实质是通过预定义的 Native UI Component 组装而成的。<br>因此，更进一步，分析 RN 的渲染机制，就是分析<strong>如何通过 JS 组装、控制  Native UI Component 生成 Native 界面</strong>。<br>没错，继续之前，先简要说说 Native UI Components。</p><h2 id="iOS-MapView-example"><a href="#iOS-MapView-example" class="headerlink" title="iOS MapView example"></a>iOS MapView example</h2><p>了解新事物，最简单的方式莫过于从例子入手(来自RN 官方：<a href="https://facebook.github.io/react-native/docs/native-components-ios.html" target="_blank" rel="noopener">Native UI Components</a>)：<br>该例子封装一个 iOS MapView 组件给 RN 使用。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code 1</span></span><br><span class="line"><span class="comment">// RNTMapManager.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;MapKit/MapKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;React/RCTViewManager.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RNTMapManager</span> : <span class="title">RCTViewManager</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RNTMapManager</span></span></span><br><span class="line"></span><br><span class="line">RCT_EXPORT_MODULE()</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">MKMapView</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, <span class="built_in">BOOL</span>)</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code 2</span></span><br><span class="line"><span class="comment">// MapView.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; requireNativeComponent &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// requireNativeComponent automatically resolves 'RNTMap' to 'RNTMapManager'</span></span><br><span class="line"><span class="built_in">module</span>.exports = requireNativeComponent(<span class="string">'RNTMap'</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyApp.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MapView <span class="keyword">from</span> <span class="string">'./MapView.js'</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;MapView zoomEnabled=&#123;false&#125; style=&#123;&#123;flex: 1&#125;&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例所示：</p><ul><li><code>MapView</code>(Native UI Component) 需要通过<code>RNTMapManager</code>(<code>RCTViewManager</code>子类)进行管理；</li><li><code>RNTMapManager</code>作为曝露给 RN 的 Native Module，需要添加<code>RCT_EXPORT_MODULE</code>宏；</li><li><code>RNTMapManager</code>需要实现<code>- (UIView *)view</code>方法，用于导出其管理的<code>MapView</code>(UI Component)；</li><li><code>RNTMapManager</code>可以通过<code>RCT_EXPORT_VIEW_PROPERTY</code>宏导出其管理的<code>MapView</code>的属性。</li></ul><p>RN 侧，通过<code>requireNativeComponent</code>方法引入 Native UI Component，实际引入的是 Native UI Component Manager。上例中即是<code>RNTMapManager</code>(Code 2 第<code>7</code>行)。</p><blockquote><p>Native UI Component Manager 在命名上必须以<code>Manager</code>为后缀，在 RN 中引用时省略此后缀(如 Code 2 中第7行所示)。<br>为了描述方便，后文将 Native UI Component Manager 简称为<code>RCTComponentManager</code>，是<code>RCTViewManager</code>的子类。<br>Code 2中第16行使用的<code>zoomEnabled</code>即是 Code 1中第19行导出的属性。</p></blockquote><h2 id="RCTUIManager"><a href="#RCTUIManager" class="headerlink" title="RCTUIManager"></a>RCTUIManager</h2><p>在前一小节示例中，引入了<code>RCTViewManager</code>，此时有必要介绍一下<code>RCTUIManager</code>。<br><img src="/img/RCTUIManager.png" alt=""><br>可以看到，<code>RCTViewManager</code>、<code>RCTUIManager</code>都实现了<code>RCTBridgeModule</code>协议，即都是曝露给 JS 的 Native Module。在<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">『ReactNative源码解析——通信机制详解(1/2)』</a>一文中，详细介绍了 <code>RCTBridge</code> 是如何管理  Native Module 的，在此不再赘述。<br>在 JS to Native 的渲染流程中，<code>RCTUIManager</code>起到重要作用：包括 Native View 的创建、布局、移除等操作都是通过<code>RCTUIManager</code>完成的。<br><img src="/img/RCTUIManager_setBridge.jpg" alt=""><br>通过上述<code>RCTUIManager#setBridge:</code>方法可知：所有的<code>RCTComponentManager</code>都会以<code>RCTComponentData</code>格式储存在<code>RCTUIManager-&gt;_componentDataByName</code>中。</p><blockquote><p><code>RCTUIManager</code>通过<code>RCTComponentData</code>操作<code>RCTComponentManager</code>，包括创建 component、为 component 设置属性等，具体内容后文会详细介绍。</p></blockquote><h2 id="RCT-View"><a href="#RCT-View" class="headerlink" title="RCT***View"></a>RCT***View</h2><p>在阅读 RN 源码过程中，会发现几个名称相似的 『view』：<code>RCTRootView</code>、<code>RCTRootContentView</code>、<code>RCTView</code>、<code>RCTShadowView</code>以及<code>RCTRootShadowView</code>，它们间的关系如下类图所示：<br><img src="/img/RCT*View.png" alt=""></p><ul><li><code>RCTView</code>——在 RN 中一个较基础的类，主要处理了 view 的 clipe、border等基础功能，UI 组件根据需要可继承自它(如：<code>RCTScrollView</code>)，也可不继承(如：<code>RCTText</code>)；</li><li><p><code>RCTRootView</code>——RN 的入口，也是这几个『view』中唯一曝露给外界的接口。下述引用来自 RN 源码中对<code>RCTRootView</code>的注解。很明显，<code>RCTRootView</code>是『React-managed』view 的载体(root)；此外，在屏幕上可以同时有多个<code>RCTRootViews</code>。</p><blockquote><p>Native view used to host React-managed views within the app.<br>Can be used just like any ordinary UIView.<br>You can have multiple RCTRootViews on screen at once, all controlled by the same JavaScript application.</p></blockquote></li><li><p><code>RCTRootContentView</code>——从其名称即可知其特点『root+content view』，其是所有 RN UI 元素的载体，其本身作为 subview 添加到<code>RCTRootView</code>上；</p></li><li><p><code>RCTShadowView</code>——在 RN 中，每个 UI 组件(view)实例都对应一个<code>RCTShadowView</code>(或其派生类)实例(类似于 <code>UIView</code> 与 <code>CALayer</code> 的关系)，从上面类图可知，虽然其命名以<code>View</code>结尾，但实质并非 View(继承自<code>NSObject</code>)。其主要功能是通过 <a href="https://github.com/facebook/yoga" target="_blank" rel="noopener">facebook-Yoga</a>在子线程(<code>shadow thread</code>)进行布局相关的计算。</p><blockquote><p>在实践中，我们发现同一功能，RN 实现的帧率往往比 Native 实现的更好(也就是更流畅)，与 RN 通过<code>RCTShadowView</code>在子线程进行布局计算密不可分。</p></blockquote></li><li><p><code>RCTRootShadowView</code>——继承自<code>RCTShadowView</code>，与<code>RCTRootContentView</code>一一对应。</p></li></ul><h1 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h1><hr><h2 id="RCTRootView"><a href="#RCTRootView" class="headerlink" title="RCTRootView"></a>RCTRootView</h2><p><code>RCTRootView</code>是 RN 应用(或者说 RN 模块)的入口，分析就从<code>RCTRootView</code>开始。<br><img src="/img/RCTRootView_initializer.jpeg" alt=""><br>如上图所示，<code>RCTRootView</code>提供了两个 initializer 方法，分别接受 <code>RCTBridge</code>(Designated initializer)以及 JSBundleURL(Convenience initializer)。<br>在初始化过程中，<code>RCTBridge</code>(<code>RCTCxxBridge</code>)异步加 JS Bundle，加载完成后会以通知(RCTJavaScriptDidLoadNotification)的形式告知<code>RCTRootView</code>：<br><img src="/img/RCTRootView_bundleFinishedLoading.jpeg" alt=""><br>在<code>RCTRootView#bundleFinishedLoading:</code>方法中，创建了<code>RCTRootContentView</code>并作为 subview 添加到<code>RCTRootView</code>上，同时调用了<code>runApplication</code>方法：<br><img src="/img/RCTRootView_runApplication.jpeg" alt=""><br><code>RCTRootView#runApplication:</code> 方法以 <code>_moduleName</code>、<code>_contentView.reactTag</code> 以及 <code>_appProperties</code>为参数调用 JS 模块<code>AppRegistry</code>的<code>runApplication</code>方法。<br>对<code>AppRegistry</code>不陌生吧^_^，『前文讲过，RN root components 都需要通过<code>AppRegistry</code>模块的<code>registerComponent</code>方法进行注册』。</p><h2 id="AppRegistry"><a href="#AppRegistry" class="headerlink" title="AppRegistry"></a>AppRegistry</h2><p>我们先从 component 注册说起：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code 3</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">Props</span>&gt; </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;</span><br><span class="line">          Welcome to React Native!</span><br><span class="line">        &lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">AppRegistry.registerComponent(<span class="string">'RNDemo'</span>, () =&gt; App);</span><br></pre></td></tr></table></figure></p><p>上述 Code 3定义了一个组件<code>App</code>，并通过<code>AppRegistry.registerComponent</code>方法进行了注册，使其成为根组件 (即可以在 Native 中直接调用)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code 4 (代码有删减，下同)</span></span><br><span class="line">registerComponent(</span><br><span class="line">  appKey: string,</span><br><span class="line">  componentProvider: ComponentProvider,</span><br><span class="line">): string &#123;</span><br><span class="line">  runnables[appKey] = &#123;</span><br><span class="line">    componentProvider,</span><br><span class="line">    run: <span class="function">(<span class="params">appParameters</span>) =&gt;</span></span><br><span class="line">      renderApplication(</span><br><span class="line">        componentProviderInstrumentationHook(componentProvider),</span><br><span class="line">        appParameters.initialProps,</span><br><span class="line">        appParameters.rootTag,</span><br><span class="line">        wrapperComponentProvider &amp;&amp; wrapperComponentProvider(appParameters),</span><br><span class="line">      )</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> appKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 通过 Code 4可知，组件最终存放在了组件注册表<code>runnables</code>中，其中最关键的信息是以<code>run</code>为 key 存储的箭头方法(第<code>8~14</code>行)，即最终对<code>renderApplication</code>方法的调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code 5</span></span><br><span class="line">runApplication(appKey: string, <span class="attr">appParameters</span>: any): <span class="keyword">void</span> &#123;</span><br><span class="line">  runnables[appKey].run(appParameters);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>在<code>RCTRootView#runApplication:</code> 方法中调用的<code>AppRegistry#runApplication</code>方法更加简单了，直接从组件注册表中取出相应的方法执行(最终调用<code>renderApplication</code>方法)。</p><blockquote><p>定义根组件时调用<code>AppRegistry.registerComponent</code>方法的 key 与在<code>RCTRootView#runApplication:</code>中调用<code>AppRegistry#runApplication</code>时的 key 需要一致(在例子中都是<code>RNDemo</code>)。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code 6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderApplication</span>&lt;<span class="title">Props</span>: <span class="title">Object</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  RootComponent: ReactClass&lt;Props&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  initialProps: Props,</span></span></span><br><span class="line"><span class="function"><span class="params">  rootTag: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  WrapperComponent?: ?ReactClass&lt;*&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactNative.render(</span><br><span class="line">    &lt;AppContainer rootTag=&#123;rootTag&#125; WrapperComponent=&#123;WrapperComponent&#125;&gt;</span><br><span class="line">      &lt;RootComponent &#123;...initialProps&#125; rootTag=&#123;rootTag&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/AppContainer&gt;,</span></span><br><span class="line"><span class="regexp">    rootTag,</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>renderApplication</code>最终调用了<code>ReactNative.render</code>，注意其参数：并不是直接使用我们传入的<code>RootComponent</code>，而是在其外面包了一层——<code>AppContainer</code>。</p><blockquote><p><code>AppContainer</code>是一个 React Component，像 debug 工具 Inspector、YellowBox 以及我们最不愿看到的出错时的红色界面都是在该组件中加载的。</p></blockquote><p>还记得，前文讲过，JSX 语法中的标签在打包生成 bundle 时会被转换成对<code>React.createElement</code>方法的调用吗？<br><img src="/img/ReactNative_render_createElement.jpeg" alt=""><br>通过上图的 debug 堆栈再次证明了这一点，<code>ReactNative#render</code>方法的第<code>35</code>行，原本是通过 JSX 语法形式对<code>RootComponent</code>的引用，但如右侧堆栈所示，实际是对<code>React.createElement</code>方法的调用。</p><h2 id="createView"><a href="#createView" class="headerlink" title="createView"></a>createView</h2><p><img src="/img/runapplication.jpeg" alt=""><br>通过上图所示长长…的调用堆栈后，来到了<code>UIManager.createView</code>，其调用的就是 Native module：<code>RCTUIManager</code>的<code>createView:viewName:rootTag:props:</code>方法(Native view 当然要在 Native 环境下创建了^_^)：<br><img src="/img/RCTUIManager_createView.jpeg" alt=""></p><blockquote><p>对<code>RCTComponentData</code>不陌生吧，前文讲过在<code>RCTUIManager#setBridge:</code>方法可知：所有的<code>RCTComponentManager</code>都会以<code>RCTComponentData</code>格式储存在<code>RCTUIManager-&gt;_componentDataByName</code>中。</p></blockquote><p>如上代码所示，首先会创建与 view 对应的 shadowView(第<code>902</code>行)，并存入 shadowView 注册表<code>_shadowViewRegistry</code>中。</p><blockquote><p>shadowView 的主要功能是通过<a href="https://github.com/facebook/yoga" target="_blank" rel="noopener">facebook-Yoga</a>进行布局相关的计算，一般情况下直接使用<code>RCTShadowView</code>类即可，若有特殊需求可从<code>RCTShadowView</code>类派生子类。RN提供的众多 UI 组件中，从<code>RCTShadowView</code>类派生的有(感兴趣的可以去看看这些派生类具体实现了哪些功能)：<br><img src="/img/RCTShadowViewSubClass.jpeg" alt=""></p></blockquote><p>第<code>912~920</code>行，在主线程创建了目标 view，并添加到 view 注册表<code>_viewRegistry</code>中(注意此时并没有添加视图层级树中，即调用<code>addSubview:</code>)。</p><h2 id="View-Property"><a href="#View-Property" class="headerlink" title="View Property"></a>View Property</h2><p>通过<code>RCT_EXPORT_VIEW_PROPERTY</code>宏，可以将 Native UI Component 的属性曝露给 RN，如在<code>RCTViewManager</code>中曝露的<code>backgroundColor</code>属性：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCT_EXPORT_VIEW_PROPERTY(backgroundColor, <span class="built_in">UIColor</span>)</span><br></pre></td></tr></table></figure></p><p><code>RCT_EXPORT_VIEW_PROPERTY</code>宏接受两个参数分别是要曝露的属性名以及属性类型，将其展开如下(是不是有种熟悉的味道，Native module 曝露给 RN 的方法也是通过类似的手法实现的)：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)propConfig_backgroundColor  &#123; </span><br><span class="line"><span class="keyword">return</span> @[<span class="string">@"UIColor"</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>除了<code>RCT_EXPORT_VIEW_PROPERTY</code>，还有另外两个宏<code>RCT_REMAP_VIEW_PROPERTY</code>、<code>RCT_CUSTOM_VIEW_PROPERTY</code>，其核心思想是一样的，在此就不赘述了。</p></blockquote><p>之后在 JSX 的标签中就可以使用 view 曝露的属性：<br><img src="/img/AppComponent.jpeg" alt=""><br><img src="/img/UIManagerCreate.jpeg" alt=""><br><img src="/img/updatePayload.jpeg" alt=""><br><img src="/img/createView_props.jpeg" alt=""><br>如图所示，在 JSX 中给 view 设置的属性被转换为<code>UIManager.createView</code>的第四个参数，最终也就传到了 Native module：<code>RCTUIManager</code>的<code>createView:viewName:rootTag:props:</code>方法中。<br>在前一小节(createView)中展示了<code>RCTUIManager</code>的<code>createView:viewName:rootTag:props:</code>方法，其第<code>918</code>行调用了<code>RCTComponentData</code>的<code>setProps:forView:</code>方法，即为 view 的属性赋值。由于篇幅关系，具体赋值过程在此不细述，核心是通过<code>RCT_EXPORT_VIEW_PROPERTY</code>宏生成的<code>propConfig_*</code>方法获取属性的类型，再将 JS 传过来的值进行相应的类型转换后赋给目标 view。</p><blockquote><p>在<code>RCTUIManager#createView:viewName:rootTag:props:</code>的第<code>904</code>行，调用了<code>RCTComponentData#setProps:forShadowView:</code>方法，即为 shadowView 的属性赋值。我们知道，shadowView 的主要作用是布局计算，通过<code>RCT_EXPORT_SHADOW_PROPERTY</code>宏曝露相关属性：<br><img src="/img/RCT_EXPORT_SHADOW_PROPERTY.jpeg" alt=""><br>可以看到，其曝露的属性也都是与布局相关的。</p></blockquote><p>是时候出个序列图，回顾一下整体流程了：<br><img src="/img/RNRender.png" alt=""><br>前文已提到，<code>RCTUIManager#createView:viewName:rootTag:props:</code>只是创建了目标 view 并添加到<code>_viewRegistry</code>中(仅此而以)。<br>从上图可以看到，JS 中的<code>ReactNativeBaseComponent</code>模块在调用<code>RCTUIManager</code>的<code>createView:viewName:rootTag:props:</code>方法创建目标 view 之后，还会调用<code>RCTUIManager</code>的<code>setChildren:reactTags:</code>方法：<br><img src="/img/setChildren.jpeg" alt=""><br>如上图源码所示，<code>setChildren:reactTags:</code>分别针对<code>_shadowViewRegistry</code>以及<code>_viewRegistry</code>(在 UIBlock 中完成调用)调用了静态方法：<code>RCTSetChildren</code>。<br>其中，shadowview 最终会调用到<code>RCTShadowView#insertReactSubview:atIndex:</code>方法：<br><img src="/img/RCTShadowViewinsertReactSubview.jpeg" alt=""><br>在该方法中，做的最核心的事情莫过于在YGNode树中插入相应的子节点(第<code>421</code>行)。<br>对于 view，最终会调用到<code>UIView+Rect</code>的<code>insertReactSubview:atIndex:</code>方法：<br><img src="/img/UIViewinsertReactSubview.jpeg" alt=""><br>在该方法中，按照层级顺序(index)将subView 添加到AssociatedObject <code>reactSubviews</code>中，还是没有真正添加到视图层级树中！</p><h2 id="Pending-UI-Block"><a href="#Pending-UI-Block" class="headerlink" title="Pending UI Block"></a>Pending UI Block</h2><p>阅读<code>RCTUIManager</code>的源码会发现，所有 JS to Native 的 UI 操作都不会立即执行，而是先添加到<code>UIManager-&gt;_pendingUIBlocks</code>中，<br>那么，<code>_pendingUIBlocks</code>中的 block 什么时候会执行呢？<br>在<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">『ReactNative源码解析——通信机制详解(1/2)』</a>一文中，我们介绍过为了提高效率，在 RN 中使用了批处理的方式：<br><img src="/img/didUpdateReactSubviews.jpeg" alt=""><br>如上图，JS 在完成一批操作后，会通知 Native，此时会调用<code>RCTUIManager#flushUIBlocks</code>方法。<br>同时，可以看到<code>RCTUIManager#flushUIBlocks</code>最终会调用<code>UIView+Rect</code>的<code>didUpdateReactSubviews</code>方法，如其源码所示，在该方法中完成了 view 添加到视图层级树的操作：<br><img src="/img/UIViewdidUpdateReactSubviews.jpeg" alt=""><br>如<code>flushUIBlocks</code>方法源码所示，最终会在主线程执行 UI block：<br><img src="/img/flushUIBlocks.jpeg" alt=""><br>至此，RN 中整个渲染流程基本完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过解读 ReactNative 源码，简要分析了 ReactNative 通过 JS 创建、控制 Native 界面的过程。同时，为了完整性，我们也简单介绍了 JSX、 React Element 以及 React Component 等基本概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="框架" scheme="http://zxfcumtcs.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ReactNative" scheme="http://zxfcumtcs.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative源码解析——通信机制详解(补充条款)</title>
    <link href="http://zxfcumtcs.github.io/2017/11/22/RNCommunicationMechanism-AdditionalTerms/"/>
    <id>http://zxfcumtcs.github.io/2017/11/22/RNCommunicationMechanism-AdditionalTerms/</id>
    <published>2017-11-22T15:13:53.000Z</published>
    <updated>2018-12-08T08:41:32.860Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过分析 RN 源码，简要介绍了 JS to Native 的 callback 实现原理以及 RN 中的三个重要线程。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h1><hr><p>前两篇文章<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a>、<a href="https://zxfcumtcs.github.io/2017/10/12/ReactNativeCommunicationMechanism2/">ReactNative源码解析——通信机制详解(2/2)</a>分别介绍了 RN 通信机制中的 JS to Native、Native to JS 的执行流程。为了集中注意力抓住主要流程，当时没有分析调用过程中的 callback 问题，下面简要分析一下 JS to Native callback 的实现原理。</p><blockquote><p>文中所列代码均做了简化处理。</p></blockquote><p>首先，来看一个具体的例子：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RCT_EXPORT_METHOD(showShareActionSheetWithOptions:(<span class="built_in">NSDictionary</span> *)options</span><br><span class="line">                  failureCallback:(RCTResponseErrorBlock)failureCallback</span><br><span class="line">                  successCallback:(RCTResponseSenderBlock)successCallback)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIActivityViewController</span> *shareController =</span><br><span class="line">    [[<span class="built_in">UIActivityViewController</span> alloc] initWithActivityItems:items applicationActivities:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    shareController.completionWithItemsHandler = </span><br><span class="line">    ^(<span class="built_in">NSString</span> *activityType, </span><br><span class="line">       <span class="built_in">BOOL</span> completed, </span><br><span class="line">       __unused <span class="built_in">NSArray</span> *returnedItems, </span><br><span class="line">       <span class="built_in">NSError</span> *activityError) &#123;</span><br><span class="line">           <span class="keyword">if</span> (activityError) &#123;</span><br><span class="line">               failureCallback(activityError);</span><br><span class="line">           &#125; </span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               successCallback(@[@(completed), RCTNullIfNil(activityType)]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>showShareActionSheetWithOptions:failureCallback:successCallback:</code>是<code>RCTActionSheetManager</code>曝露给 JS 的方法之一，其包含两个 callback：<code>failureCallback</code>、<code>successCallback</code>。<br>其中，<code>RCTResponseErrorBlock</code>、<code>RCTResponseSenderBlock</code>的定义如下：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type of a block that is capable of sending a response to a bridged</span></span><br><span class="line"><span class="comment"> * operation. Use this for returning callback methods to JS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^RCTResponseSenderBlock)(<span class="built_in">NSArray</span> *response);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type of a block that is capable of sending an error response to a</span></span><br><span class="line"><span class="comment"> * bridged operation. Use this for returning error information to JS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^RCTResponseErrorBlock)(<span class="built_in">NSError</span> *error);</span><br></pre></td></tr></table></figure></p><p>JS 中的调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ActionSheetIOS.showShareActionSheetWithOptions(&#123;</span><br><span class="line">        url: uri,</span><br><span class="line">        excludedActivityTypes: [</span><br><span class="line">          <span class="string">'com.apple.UIKit.activity.PostToTwitter'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      (error) =&gt; alert(error),</span><br><span class="line">      (completed, method) =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> text;</span><br><span class="line">        <span class="keyword">if</span> (completed) &#123;</span><br><span class="line">          text = <span class="string">`Shared via <span class="subst">$&#123;method&#125;</span>`</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          text = <span class="string">'You didn\'t share'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;text&#125;);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></p><p>上述代码的第<code>7</code>行、<code>8~16</code>行，分别设置了两个 fail、success callback。</p><p><img src="/img/RCTModuleMethodinvokeWithBridge.jpg" alt=""><br>上图所示是 JS to Native 中最终在 Native 侧调用相应方法的调用栈，在<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a>中提到过，但限于篇幅没有展开讨论。</p><p>今天的分析就从<code>RCTModuleMethod#invokeWithBridge:module:arguments:</code>开始。</p><h2 id="RCTModuleMethod-invokeWithBridge"><a href="#RCTModuleMethod-invokeWithBridge" class="headerlink" title="RCTModuleMethod#invokeWithBridge:"></a>RCTModuleMethod#invokeWithBridge:</h2><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)invokeWithBridge:(RCTBridge *)bridge</span><br><span class="line">                module:(<span class="keyword">id</span>)module</span><br><span class="line">             arguments:(<span class="built_in">NSArray</span> *)arguments</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_argumentBlocks == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> processMethodSignature];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set arguments</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> json <span class="keyword">in</span> arguments) &#123;</span><br><span class="line">        RCTArgumentBlock block = _argumentBlocks[index];</span><br><span class="line">        <span class="keyword">if</span> (!block(bridge, index, RCTNilIfNull(json))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke method</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    [_invocation invokeWithTarget:module];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>invokeWithBridge:module:arguments:</code>内部(第<code>6</code>行)调用了<code>processMethodSignature</code>方法，从名称可知该方法是处理『方法签名』的(被处理的方法当然是被 JS 调用的 Native method 了)：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)processMethodSignature</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;RCTMethodArgument *&gt; *arguments;</span><br><span class="line">    _selector = RCTParseMethodSignature(_methodInfo-&gt;objcName, &amp;arguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create method invocation</span></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *methodSignature =  [_moduleClass instanceMethodSignatureForSelector:_selector];</span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:methodSignature];</span><br><span class="line">    invocation.selector = _selector;</span><br><span class="line">    _invocation = invocation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process arguments</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> numberOfArguments = methodSignature.numberOfArguments;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;RCTArgumentBlock&gt; *argumentBlocks =</span><br><span class="line">    [[<span class="built_in">NSMutableArray</span> alloc] initWithCapacity:numberOfArguments - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">2</span>; i &lt; numberOfArguments; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *objcType = [methodSignature getArgumentTypeAtIndex:i];</span><br><span class="line">        RCTMethodArgument *argument = arguments[i - <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *typeName = argument.type;</span><br><span class="line">        SEL selector = RCTConvertSelectorForType(typeName);</span><br><span class="line">        <span class="keyword">if</span> ([RCTConvert respondsToSelector:selector]) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (objcType[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">case</span> _C_CHR: &#123;</span><br><span class="line">                    <span class="keyword">char</span> (*convert)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>) = (<span class="keyword">typeof</span>(convert))objc_msgSend;</span><br><span class="line">                    [argumentBlocks addObject:^(__unused RCTBridge *bridge, <span class="built_in">NSUInteger</span> index, <span class="keyword">id</span> json) &#123;</span><br><span class="line">                        <span class="keyword">char</span> value = convert([RCTConvert <span class="keyword">class</span>], selector, json);</span><br><span class="line">                        [invocation setArgument:&amp;value atIndex:(index) + <span class="number">2</span>];</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">YES</span>;&#125;];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ([typeName isEqualToString:<span class="string">@"RCTResponseSenderBlock"</span>]) &#123;</span><br><span class="line">            [argumentBlocks addObject:^(__unused RCTBridge *bridge, <span class="built_in">NSUInteger</span> index, <span class="keyword">id</span> json) &#123;</span><br><span class="line">                <span class="keyword">void</span> (^block)(<span class="built_in">NSArray</span> *) = ^(<span class="built_in">NSArray</span> *args) &#123;</span><br><span class="line">                    [bridge enqueueCallback:json args:args];</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">id</span> value = json ? [block <span class="keyword">copy</span>] : (<span class="keyword">id</span>)^(__unused <span class="built_in">NSArray</span> *_)&#123;&#125;;</span><br><span class="line">                <span class="built_in">CFBridgingRetain</span>(value);</span><br><span class="line"></span><br><span class="line">                [invocation setArgument:&amp;value atIndex:(index) + <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    _argumentBlocks = argumentBlocks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>processMethodSignature</code>方法主要做的工作：</p><ul><li>从被调方法的名称(字符串)中解析出 selector 以及<code>RCTMethodArgument</code>格式的参数(第<code>4</code>行)；</li><li>根据第一步中解析出的 selector 生成methodSignature、invocation(第<code>7~10</code>行)；</li><li>为每个参数生成一个 block(<code>argumentBlock</code>)，并添加到<code>argumentBlocks</code>数组中：<br>  1. 若参数的类型在 JS 与 Native 间可以转换(如：基础类型、字符串、数组等)(第<code>23~34</code>行)，在<code>argumentBlock</code>中完成 JS 类型参数 to Native 类型参数的转换(第<code>28</code>行)，并将得到的结果设置到<code>invocation</code>上(第<code>29</code>行)；<br>  2. 若参数类型是 block(如：<code>RCTResponseSenderBlock</code>、<code>RCTResponseErrorBlock</code>等)(第<code>35~46</code>行)，则在<code>argumentBlock</code>中生成一个 bolck，用作调用方法时的实参(因为 block 类型无法从 JS 直接传给 Native)，在该 block 中调用了<code>bridge</code>的<code>enqueueCallback:args:</code>方法。</li></ul><p>再回到<code>RCTModuleMethod#invokeWithBridge:module:arguments:</code>方法，第<code>12~18</code>行，执行了<code>processMethodSignature</code>方法为每个参数生成的 block，最终的效果就是将 JS 侧传入的参数值转换成 Native 类型并设置到<code>invocation</code>上。</p><p>通过上述分析可知，对于 block 类型的参数(callback)最终会调用了<code>RCTCxxBridge#enqueueCallback:args:</code>方法。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSCExecutor::invokeCallback(<span class="keyword">const</span> <span class="keyword">double</span> callbackId, <span class="keyword">const</span> folly::dynamic&amp; arguments) &#123;</span><br><span class="line">    auto result = [&amp;] &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">return</span> m_invokeCallbackAndReturnFlushedQueueJS-&gt;callAsFunction(&#123;</span><br><span class="line">                Value::makeNumber(m_context, callbackId),</span><br><span class="line">                Value::fromDynamic(m_context, std::move(arguments))</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (...) &#123;&#125;</span><br><span class="line">    &#125;();</span><br><span class="line">    callNativeModules(std::move(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>沿调用链最终来到<code>JSCExecutor::invokeCallback</code>，第<code>4</code>行通过 hook，实际调用的是 JS 侧的<code>MessageQueue#invokeCallbackAndReturnFlushedQueue</code>方法。<br>下面我们来看看 JS 侧如何处理 callback。</p><h2 id="NativeModules-genMethod"><a href="#NativeModules-genMethod" class="headerlink" title="NativeModules#genMethod"></a>NativeModules#genMethod</h2><p>还记得<code>genMethod</code>方法吗？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genMethod</span>(<span class="params">moduleID: number, methodID: number, type: MethodType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="literal">null</span>;</span><br><span class="line">    fn = <span class="function"><span class="keyword">function</span>(<span class="params">...args: Array&lt;any&gt;</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> lastArg = args.length &gt; <span class="number">0</span> ? args[args.length - <span class="number">1</span>] : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> secondLastArg = args.length &gt; <span class="number">1</span> ? args[args.length - <span class="number">2</span>] : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> hasSuccessCallback = <span class="keyword">typeof</span> lastArg === <span class="string">'function'</span>;</span><br><span class="line">        <span class="keyword">const</span> hasErrorCallback = <span class="keyword">typeof</span> secondLastArg === <span class="string">'function'</span>;</span><br><span class="line">        <span class="keyword">const</span> onSuccess = hasSuccessCallback ? lastArg : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> onFail = hasErrorCallback ? secondLastArg : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> callbackCount = hasSuccessCallback + hasErrorCallback;</span><br><span class="line">        args = args.slice(<span class="number">0</span>, args.length - callbackCount);</span><br><span class="line">        BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess);</span><br><span class="line">    &#125;;</span><br><span class="line">    fn.type = type;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a>一文中介绍过，JS 在调用 Native 方法时，会在 JS 侧动态生成一个对应的 JS 方法。<br>在<code>genMethod</code>方法的第<code>4~9</code>行，处理了调用参数的最后2个，判断是否是 callback 类型(function 类型)。<br>从上述处理代码中可以得出：</p><ul><li>对于 callback 类型的参数，作了特殊处理，将其从参数列表中剥离出来；</li><li>一个方法最多只能有两个 callback 类型的参数；</li><li>callback 类型的参数只能位于参数列表的最后。</li></ul><p>下面再来看看<code>MessageQueue.enqueueNativeCall</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enqueueNativeCall(</span><br><span class="line">    moduleID: number,</span><br><span class="line">    methodID: number,</span><br><span class="line">    params: any[],</span><br><span class="line">    onFail: ?<span class="built_in">Function</span>,</span><br><span class="line">    onSucc: ?<span class="built_in">Function</span>,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (onFail || onSucc) &#123;</span><br><span class="line">        <span class="comment">// Encode callIDs into pairs of callback identifiers by shifting left and using the rightmost bit</span></span><br><span class="line">        <span class="comment">// to indicate fail (0) or success (1)</span></span><br><span class="line">        <span class="comment">// eslint-disable-next-line no-bitwise</span></span><br><span class="line">        onFail &amp;&amp; params.push(<span class="keyword">this</span>._callID &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// eslint-disable-next-line no-bitwise</span></span><br><span class="line">        onSucc &amp;&amp; params.push((<span class="keyword">this</span>._callID &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>._successCallbacks[<span class="keyword">this</span>._callID] = onSucc;</span><br><span class="line">        <span class="keyword">this</span>._failureCallbacks[<span class="keyword">this</span>._callID] = onFail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._callID++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到：</p><ul><li>对于 callback 类型的参数，在 JS 与 Native 间传递的是 callbackID(<code>_successCallbacks</code>、<code>_failureCallbacks</code>中的下标)；</li><li>JS 侧的 callback function 存储在<code>_successCallbacks</code>、<code>_failureCallbacks</code>中。</li></ul><p>我们再回到调用流程中的<code>MessageQueue#invokeCallbackAndReturnFlushedQueue</code>方法，在该方法中调用了<code>__invokeCallback</code>方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__invokeCallback(cbID: number, <span class="attr">args</span>: any[]) &#123;</span><br><span class="line">    <span class="comment">// The rightmost bit of cbID indicates fail (0) or success (1), the other bits are the callID shifted left.</span></span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-bitwise</span></span><br><span class="line">    <span class="keyword">const</span> callID = cbID &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-bitwise</span></span><br><span class="line">    <span class="keyword">const</span> isSuccess = cbID &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> callback = isSuccess</span><br><span class="line">      ? <span class="keyword">this</span>._successCallbacks[callID]</span><br><span class="line">      : <span class="keyword">this</span>._failureCallbacks[callID];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!callback) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._successCallbacks[callID] = <span class="keyword">this</span>._failureCallbacks[callID] = <span class="literal">null</span>;</span><br><span class="line">    callback(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>__invokeCallback</code>方法中，通过 cbID 在<code>_successCallbacks</code>、<code>_failureCallbacks</code>中找到相应的 callback function，并执行。至此，callback 的流程全部结束。</p><blockquote><p>RN 通过 callbackID 的最后一位是0还是1，确定callback 是 success 还是 fail。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>JS 与 Native 间传递的是 callbackID；</li><li>callback 参数只能位于方法参数列表的最后面并且最多只能有2个；</li><li>RN 通过 callbackID 二进制的最后一位是0还是1，确定是 success 还是 fail；</li><li>由于 JS callback function 无法直接传递给 Native，Native 侧会生成一个 block。</li></ul><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><hr><p>在 RN 中，有3类线程需要关注：</p><ul><li>JS Thread；</li><li>Native Module Thread；</li><li>UI Manager Thread(Shadow Thread)。</li></ul><h2 id="JS-Thread"><a href="#JS-Thread" class="headerlink" title="JS Thread"></a>JS Thread</h2><p>JS Thread 是 JS 执行以及 JS 与 Native 通信线程。<br>简单讲，Native 在此线程执行 JS 代码，JS 调用 Native 接口也发生在此线程上。<br>JS Thread 的初始化发生在<code>RCTCxxBridge#start</code>方法中：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_jsThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:[<span class="keyword">self</span> <span class="keyword">class</span>]</span><br><span class="line">                                                   selector:<span class="keyword">@selector</span>(runRunLoop)</span><br><span class="line">                                                     object:<span class="literal">nil</span>];</span><br><span class="line">_jsThread.name = RCTJSThreadName;</span><br><span class="line">_jsThread.qualityOfService = <span class="built_in">NSOperationQualityOfServiceUserInteractive</span>;</span><br><span class="line">[_jsThread start];</span><br></pre></td></tr></table></figure></p><p>在阅读 RN 源码时可能会发现<code>RCTMessageThread</code>类，它是对 JS Thread 的 C++封装。具体源码就不列了。<br>还会发现<code>RCTJSThread</code>变量：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> RCTJSThread;</span><br><span class="line">RCTJSThread = (<span class="keyword">id</span>)kCFNull;</span><br></pre></td></tr></table></figure></p><blockquote><p>NOTE: RCTJSThread is not a real libdispatch queue</p></blockquote><p><code>RCTJSThread</code>的作用只是用于标识，确保需要在 JSThread 上执行的操作能在该线程上执行：<br><img src="/img/RCTJSThread.png" alt=""> <img src="/img/dispatchJSThread.png" alt=""></p><h2 id="Native-module-Thread"><a href="#Native-module-Thread" class="headerlink" title="Native module Thread"></a>Native module Thread</h2><p>JS 在调用 Native 方法时，Native 方法在哪个线程上执行？<br>Native Module 可以实现<code>methodQueue</code>方法，指定执行队列：<code>- (dispatch_queue_t)methodQueue</code>。<br>那如果 Native Module 没有实现<code>methodQueue</code>方法，会如何？<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUpMethodQueue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> implementsMethodQueue = [_instance respondsToSelector:<span class="keyword">@selector</span>(methodQueue)];</span><br><span class="line">    <span class="keyword">if</span> (implementsMethodQueue &amp;&amp; _bridge.valid) &#123;</span><br><span class="line">        _methodQueue = _instance.methodQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_methodQueue &amp;&amp; _bridge.valid) &#123;</span><br><span class="line">        <span class="comment">// Create new queue (store queueName, as it isn't retained by dispatch_queue)</span></span><br><span class="line">        _queueName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"com.facebook.react.%@Queue"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">        _methodQueue = dispatch_queue_create(_queueName.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>RCTModuleData#setUpMethodQueue</code>方法中可以看到：若Native Module 没有实现<code>methodQueue</code>方法，则为该 Native Module 生成一个串行队列。<br>那么在实现 <code>Native module#methodQueue</code> 方法时需要注意什么？<br>来了解一下 RN 自带的 module 实现情况：</p><ul><li>main thread — 如 RCTActionSheetManager，在接口中有 UI 操作；</li><li>JSThread — 如 RCTTiming、RCTEventDispatcher，实时性要求较高的<br>(慎用，This can have serious implications for performance, so only use this if you’re sure it’s what you need)；</li><li>UI Manager thread — 如 RCTUIManager、RCTViewManager，UI 组件；</li><li>Custom thread — 如 RCTAsyncLocalStorage，耗时操作。</li></ul><h2 id="UI-Manager-Thread-Shadow-Thread"><a href="#UI-Manager-Thread-Shadow-Thread" class="headerlink" title="UI Manager Thread(Shadow Thread)"></a>UI Manager Thread(Shadow Thread)</h2><p>UI Manager Thread，UI 组件(UI module)接口执行线程。<br>UI 不应该在 main thread？<br>RN 为了提高效率(如: 帧率)，会先在UI Manager Thread做一些预处理操作(如计算 frame)，最终在渲染上屏时会切到 main thread。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> RCTGetUIManagerQueue(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> shadowQueue;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSOperation</span> instancesRespondToSelector:<span class="keyword">@selector</span>(qualityOfService)]) &#123;</span><br><span class="line">            dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INTERACTIVE, <span class="number">0</span>);</span><br><span class="line">            shadowQueue = dispatch_queue_create(RCTUIManagerQueueName, attr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            shadowQueue = dispatch_queue_create(RCTUIManagerQueueName, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">            dispatch_set_target_queue(shadowQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> shadowQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，UI Manager Thread 是一个高优先级的串行队列。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li>所有 JS 代码都会在独立线程 JSThread 上执行；</li><li>可通过 methodQueue 方法自定义 Native module 执行线程；</li><li>为了提高效率，所有 UI 组件都会在 UI Manager thread 上预处理，再在 main thread 上渲染上屏。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过分析 RN 源码，简要介绍了 JS to Native 的 callback 实现原理以及 RN 中的三个重要线程。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="框架" scheme="http://zxfcumtcs.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ReactNative" scheme="http://zxfcumtcs.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative源码解析——通信机制详解(2/2)</title>
    <link href="http://zxfcumtcs.github.io/2017/10/12/ReactNativeCommunicationMechanism2/"/>
    <id>http://zxfcumtcs.github.io/2017/10/12/ReactNativeCommunicationMechanism2/</id>
    <published>2017-10-12T15:04:38.000Z</published>
    <updated>2018-12-08T08:41:32.862Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过分析源码，逐步解析 ReactNative 中 Native to JS 的通信机制。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Native-to-JS"><a href="#Native-to-JS" class="headerlink" title="Native to JS"></a>Native to JS</h1><hr><p>在『<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a>』一文中通过 RN 源码逐步分析了 JS to Native 的通信机制，整个过程相当还是比较复杂。本文同样通过解析源码，逐步分析 Native to JS 的过程。<br>相比 JS to Native，Native to JS 简单不少。<br><img src="/img/RNClassDiagram.png" alt=""><br>这是我们在『<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a>』一文中给出的 RN 关键类类图。<br><img src="/img/NativeToJSTimingDiagram.png" alt=""><br>上图是 Native to JS 的时序图，<code>RCTBridge</code> 作为 RN 对外接口，Native 调用 JS 的方法自然也需要从此发出。上图中的方法调用链比较简单，不一一分析。<br>在『<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a>』中，我们知道<code>NativeToJsBridge</code>是 Native to JS 的桥接，<code>NativeToJsBridge</code>做的最重要的一件事就是线程管理——使所有的 JS 调用都在指定的线程上执行。(RN中关于线程问题，后面会另开文章专门讨论。)<br><code>JSCExecutor</code>是 RN 中 JS 执行引擎，今天的分析就从此开始。<br>JS to Native 的流程进入<code>JSCExecutor::callFunction</code>。</p><h2 id="JSCExecutor-callFunction"><a href="#JSCExecutor-callFunction" class="headerlink" title="JSCExecutor::callFunction"></a>JSCExecutor::callFunction</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSCExecutor::callFunction(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; moduleId, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; methodId, <span class="keyword">const</span> folly::dynamic&amp; arguments) &#123;</span><br><span class="line">    <span class="keyword">auto</span> result = [&amp;] &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_callFunctionReturnResultAndFlushedQueueJS) &#123;</span><br><span class="line">            bindBridge();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_callFunctionReturnFlushedQueueJS-&gt;callAsFunction(&#123;</span><br><span class="line">            Value(m_context, String::createExpectingAscii(m_context, moduleId)),</span><br><span class="line">            Value(m_context, String::createExpectingAscii(m_context, methodId)),</span><br><span class="line">            Value::fromDynamic(m_context, <span class="built_in">std</span>::move(arguments))</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line">    callNativeModules(<span class="built_in">std</span>::move(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>callFunction</code>方法中，首先判断环境是否准备好(第<code>3</code>行)，若尚未准备好，则进入<code>bindBridge</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSCExecutor::bindBridge() <span class="keyword">throw</span>(JSException) &#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(m_bindFlag, [<span class="keyword">this</span>] &#123;</span><br><span class="line">        <span class="keyword">auto</span> global = Object::getGlobalObject(m_context);</span><br><span class="line">        <span class="keyword">auto</span> batchedBridgeValue = global.getProperty(<span class="string">"__fbBatchedBridge"</span>);</span><br><span class="line">        <span class="keyword">auto</span> batchedBridge = batchedBridgeValue.asObject();</span><br><span class="line">        m_callFunctionReturnFlushedQueueJS = batchedBridge.getProperty(<span class="string">"callFunctionReturnFlushedQueue"</span>).asObject();</span><br><span class="line">        m_callFunctionReturnResultAndFlushedQueueJS = batchedBridge.getProperty(<span class="string">"callFunctionReturnResultAndFlushedQueue"</span>).asObject();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>bindBridge</code>方法主要完成一些初始化准备工作：从 JS 则获取<code>batchedBridge</code> object 以及若干个方法(<code>m_callFunctionReturnFlushedQueueJS</code>等)。<br>在<code>BatchedBridge.js</code>中可以找到<code>__fbBatchedBridge</code>的定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BatchedBridge = <span class="keyword">new</span> MessageQueue();</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(global, <span class="string">'__fbBatchedBridge'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  value: BatchedBridge,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>可以看到，在 Native 里面拿到的<code>batchedBridge</code>是一个<code>MessageQueue</code>类型的 JS object。<br><code>m_callFunctionReturnFlushedQueueJS</code>则是 JS 类<code>MessageQueue</code>的<code>callFunctionReturnFlushedQueue</code>方法。<br>回到<code>JSCExecutor::callFunction</code>，在第<code>6</code>行执行了<code>callFunctionReturnFlushedQueue</code>方法。</p><h2 id="MessageQueue-callFunctionReturnFlushedQueue-JS"><a href="#MessageQueue-callFunctionReturnFlushedQueue-JS" class="headerlink" title="MessageQueue.callFunctionReturnFlushedQueue(JS)"></a>MessageQueue.callFunctionReturnFlushedQueue(JS)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">callFunctionReturnFlushedQueue(<span class="built_in">module</span>: string, <span class="attr">method</span>: string, <span class="attr">args</span>: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">this</span>.__guard(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.__callFunction(<span class="built_in">module</span>, method, args);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.flushedQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callFunctionReturnFlushedQueue</code>方法调用了内部的<code>__callFunction</code>方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__callFunction(<span class="built_in">module</span>: string, <span class="attr">method</span>: string, <span class="attr">args</span>: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">this</span>._lastFlush = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">this</span>._eventLoopStartTime = <span class="keyword">this</span>._lastFlush;</span><br><span class="line">    <span class="keyword">const</span> moduleMethods = <span class="keyword">this</span>._getCallableModule(<span class="built_in">module</span>);</span><br><span class="line">    <span class="keyword">const</span> result = moduleMethods[method].apply(moduleMethods, args);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><code>__callFunction</code>通过 <code>moduleName</code>在 JS Module 注册表中找到该 module，并调用相应的方法。</p><blockquote><p>PS: <code>JSCExecutor::callFunction</code>-&gt;<code>MessageQueue.callFunctionReturnFlushedQueue</code>这套接口不会将要调用的 JS 方法的返回值传给 Native 侧。<br>如需返回 JS 方法的返回值，可调用另外一套接口：<code>JSCExecutor::callFunctionSyncWithValue</code>-&gt;<code>MessageQueue.callFunctionReturnResultAndFlushedQueue</code>。<br>but，在<code>callFunctionSyncWithValue</code>方法的声明处有注释：<strong><em>『This method is experimental, and may be modified or removed』</em></strong></p></blockquote><h2 id="JS-Module-注册表"><a href="#JS-Module-注册表" class="headerlink" title="JS Module 注册表"></a>JS Module 注册表</h2><p>上一节，我们提到 JS Modulde 注册表(<code>_lazyCallableModules</code>)，所有曝露给 Native 的 JS Module都需要注册。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">registerCallableModule(name: string, <span class="attr">module</span>: <span class="built_in">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>._lazyCallableModules[name] = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">module</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">registerLazyCallableModule(name: string, <span class="attr">factory</span>: <span class="function"><span class="params">void</span> =&gt;</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span>: <span class="built_in">Object</span>;</span><br><span class="line">  <span class="keyword">let</span> getValue: ?(<span class="function"><span class="params">void</span> =&gt;</span> <span class="built_in">Object</span>) = factory;</span><br><span class="line">  <span class="keyword">this</span>._lazyCallableModules[name] = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getValue) &#123;</span><br><span class="line">      <span class="built_in">module</span> = getValue();</span><br><span class="line">      getValue = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_getCallableModule(name: string) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._lazyCallableModules[name]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>JS Module 注册表支持懒加载。</p></blockquote><p>可通过<code>registerCallableModule</code>或<code>registerLazyCallableModule</code>接口注册。<br>如在RCTEventEmitter.js中注册的消息模块<code>RCTEventEmitter</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BatchedBridge.registerCallableModule(<span class="string">'RCTEventEmitter'</span>, eventEmitter);</span><br></pre></td></tr></table></figure></p><p>在InitializeCore.js中注册的基础模块(懒加载)：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'Systrace'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'Systrace'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'JSTimers'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'JSTimers'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'HeapCapture'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'HeapCapture'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'SamplingProfiler'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'SamplingProfiler'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'RCTLog'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'RCTLog'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'RCTDeviceEventEmitter'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'RCTDeviceEventEmitter'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'RCTNativeAppEventEmitter'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'RCTNativeAppEventEmitter'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'PerformanceLogger'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'PerformanceLogger'</span>));</span><br></pre></td></tr></table></figure></p><p>至此，Native to JS 的流程基本结束。<br>but，事情并没有结束。<br>前面讲到，<code>callFunctionReturnFlushedQueue</code>不会返回所调 JS 方法的返回值，但它确有返回值(从 JS 传给 Native)：<br><figure class="highlight js"><figcaption><span>// callFunctionReturnFlushedQueue的 return 语句</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.flushedQueue();</span><br></pre></td></tr></table></figure></p><p>在分析 JS to Native 时介绍过，出于性能考虑所有从 JS to Native 的调用都会先入队，只有满足一定的条件(离上一次 flush queue 大于5ms)才会被执行。<br>所有 Native to JS的调用，在其结束时都会触发一次 flush queue 的操作，即 flush 所有入队的 JS to Native 的调用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Native to JS 的通信过程相对比较简单，总结主要有两点：</p><ul><li>所有曝露给 Native 的 JS Module 都需要提前注册；</li><li>在 Native to JS 调用结束时，会触发 flush JS to Native Queue 的操作。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>RN 中 Native 与 JS 的通信机制基本分析完成，总结主要有以下几点：</p><ul><li>RN 项目中涉及多种语言，但 Native 与 JS 的通信发生在<code>C++</code>与<code>JavaScript</code>间；</li><li>双方具体负责通信的分别是：Native 的<code>JSCExecutor</code>与 JS 的<code>MessageQueue</code>；</li><li>在 Native 侧维护了一份曝露给 JS 的 module 注册表，在 JS 侧维护了一份曝露给 Native 的 module 注册表；</li><li>RN 中 Native to JS 的通信没有使用<code>JavaScriptCore</code>提供的机制(<code>block</code>、<code>JSExport</code>)，而是自己实现了一套跨平台通信机制。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://facebook.github.io/react-native/docs/getting-started.html" target="_blank" rel="noopener">React Native Docs</a><br><a href="http://awhisper.github.io/2016/06/24/ReactNative%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">ReactNative iOS源码解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过分析源码，逐步解析 ReactNative 中 Native to JS 的通信机制。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="框架" scheme="http://zxfcumtcs.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ReactNative" scheme="http://zxfcumtcs.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative源码解析——通信机制详解(1/2)</title>
    <link href="http://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/"/>
    <id>http://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/</id>
    <published>2017-10-08T11:19:59.000Z</published>
    <updated>2018-12-08T08:41:32.862Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过分析源码，逐步解析 ReactNative 中 JS to Native 的通信机制。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>本文详细分析了 JS to Native 的调用过程，包括：ReactNative 的初始化、native module 注册、JS 获取 native module 信息、JS 调用 native module。</p><blockquote><p>本文分析的源码基于 ReactNative 0.47，为了叙述方便后文将 ReactNative 简称为 RN。<br>另外，为了精减篇幅聚焦重点，文中所列源码均做过简化，删除非关键代码。<br>由于本文具体分析的是 iOS 侧的实现，故后文所有内容都是针对 iOS 平台(其中有一大部分是共用的)。</p></blockquote><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><hr><blockquote><p>阅读源码大概有两类目的，一是想通过源码了解某个实现细节；二是想了解其实现的整体结构、原理。对于第一种情形可以直接深入源码，快速抓住关注点；而后者如果也一股脑扎入源码，很容易陷入各种实现细节而迷失方向(尤其是大型源码)。此时，应先了解代码整体结构，抓住关键路径，必要时辅以类图。</p></blockquote><p>本文讨论的 RN 通信机制是整个 RN 的核心，贯穿始末，涉及<code>Objective-C</code>/<code>Java</code>、<code>C++</code>、<code>JavaScript</code>间的交互。因此，在深入分析前有必要先了解一下 RN 整体结构以及关键类的类图。<br><img src="/img/RNLanguageComposition.jpeg" alt=""><br>RN 最大的优势在于<strong><em>跨平台、热更新</em></strong>。因此，RN 库本身也需要在多个平台(iOS、Android)上运行，从上图可知，在 RN 中 <code>C++</code>与<code>JS</code>部分的实现为多平台共用，在此基础上再分化为各平台实现。其中，iOS 平台特有的实现(<code>Objective-C</code>、<code>C++</code>)主要集中在 React 下，以<code>C++</code>语言实现的共有部分在 ReactCommon 下：<br><img src="/img/ReactReactCommon.png" alt=""><br>JS侧与本文关系紧密的内容主要集中在：<br><img src="/img/BatchedBridgePath.jpg" alt="">下的<code>BatchedBridge.js</code>、<code>MessageQueue.js</code>以及<code>NativeModules.js</code>中。</p><p>我们先大概了解几个关键类及其间的关系，对整体结构有个大致印象：<br><img src="/img/RNClassDiagram.png" alt=""><br>如上图：</p><ul><li><code>RCTBridge</code>与<code>RCTCxxBridge</code>属于 iOS 平台特有，前者是 RN 对业务层接口(图中其他类都属于内部类，业务层无感知)，具体工作在其子类<code>RCTCxxBridge</code>中完成；</li><li>整个 RN 的核心在跨平台的 C++层，其中很多类的功能从其名称即可略知一二，后文也会有详细的描述；</li><li>在 RN 中肯定少不了 JS 的支持，从上图可知，JS 与 Native 的通信发生在 <code>JavaScript</code> 与 <code>C++</code>间，这也是本文分析的重点。</li></ul><p>说到通信，无外乎 JS to Native、Native to JS，本篇我们重点分析JS to Native。</p><h1 id="JavaScript—-gt-Native"><a href="#JavaScript—-gt-Native" class="headerlink" title="JavaScript—&gt;Native"></a>JavaScript—&gt;Native</h1><hr><p>通过 Apple 推出的 <code>JavaScriptCore</code>，要实现 JS to Native 的通信并非难事，主要有两条途径：</p><ul><li><code>block</code>——在 RN 这样复杂的应用场景中<code>block</code>显得有些力不从心；</li><li><code>JSExport</code>协议——通过实现该协议可以向 JS 曝露 Native 接口(但不具备跨平台能力)。</li></ul><p>因此，RN 并没有使用 <code>JavaScriptCore</code>提供的这两种方式，而是自己实现了一套通信机制。<br>我们先从一个简单的例子入手：<code>CalendarManager</code>封装了 iOS 平台的日历控件，供 JS 调用。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CalendarManager.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;React/RCTBridgeModule.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CalendarManager</span> : <span class="title">NSObject</span> &lt;<span class="title">RCTBridgeModule</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CalendarManager.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CalendarManager</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To export a module named CalendarManager</span></span><br><span class="line">RCT_EXPORT_MODULE();</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(addEvent:(<span class="built_in">NSString</span> *)name location:(<span class="built_in">NSString</span> *)location) &#123;</span><br><span class="line">    RCTLogInfo(<span class="string">@"Pretending to create an event %@ at %@"</span>, name, location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们知道，要将 Native module(类、接口)曝露给 JS，module需要实现<code>RCTBridgeModule</code>协议，并且在实现中要插入<code>RCT_EXPORT_MODULE</code>宏。具体曝露的方法也需要通过<code>RCT_EXPORT_METHOD</code>宏定义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="keyword">import</span> &#123; NativeModules &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">var</span> CalendarManager = NativeModules.CalendarManager;</span><br><span class="line">CalendarManager.addEvent(<span class="string">'Birthday Party'</span>, <span class="string">'4 Privet Drive, Surrey'</span>);</span><br></pre></td></tr></table></figure></p><p>此时，在 JS 中就可以通过<code>NativeModules.CalendarManager.addEvent(...)</code>方式调用 Native 接口了。<br>下面将对这一过程逐一分析，先来了解上面提到的两个关键的宏：</p><h2 id="RCT-EXPORT-MODULE"><a href="#RCT-EXPORT-MODULE" class="headerlink" title="RCT_EXPORT_MODULE"></a>RCT_EXPORT_MODULE</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCT_EXPORT_MODULE(js_name) \</span></span><br><span class="line"><span class="function">RCT_EXTERN <span class="keyword">void</span> <span class="title">RCTRegisterModule</span><span class="params">(Class)</span></span>; \</span><br><span class="line">+ (NSString *)moduleName &#123; <span class="keyword">return</span> @#js_name; &#125; \</span><br><span class="line">+ (<span class="keyword">void</span>)load &#123; RCTRegisterModule(self); &#125;</span><br></pre></td></tr></table></figure><p>可以看到，添加<code>RCT_EXPORT_MODULE</code>宏，相当定义了<code>load</code>、<code>moduleName</code>方法。正是在<code>load</code>方法中调用了<code>RCTRegisterModule</code>方法注册 Module(会影响 App 启动速度^_^)。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RCTRegisterModule(Class moduleClass) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        RCTModuleClasses = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Register module</span></span><br><span class="line">    [RCTModuleClasses addObject:moduleClass];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>RCTRegisterModule</code>只是简单收集所有需要曝露给 JS 的类。</p></blockquote><h2 id="RCT-EXPORT-METHOD"><a href="#RCT-EXPORT-METHOD" class="headerlink" title="RCT_EXPORT_METHOD"></a>RCT_EXPORT_METHOD</h2><p>曝露给 JS 的接口需要通过<code>RCT_EXPORT_METHOD</code>宏来定义，上文中：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RCT_EXPORT_METHOD(addEvent:(<span class="built_in">NSString</span> *)name location:(<span class="built_in">NSString</span> *)location) &#123;</span><br><span class="line">    RCTLogInfo(<span class="string">@"Pretending to create an event %@ at %@"</span>, name, location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终展开后的样子(由于篇幅关系具体的展开过程不作描述)：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)__rct_export__531 &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@""</span>, <span class="string">@"addEvent:(NSString *)name location:(NSString *)location"</span>, @NO];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)addEvent:(<span class="built_in">NSString</span> *)name location:(<span class="built_in">NSString</span> *)location &#123;</span><br><span class="line">    RCTLogInfo(<span class="string">@"Pretending to create an event %@ at %@"</span>, name, location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到通过宏添加了一个新方法，其命名规则：<code>__rct_export__</code>+<code>__LINE__</code>+<code>__COUNTER__</code>。同时注意到，所有曝露给 JS 的方法返回值都是 <code>void</code>，要返回结果时，需通过 callback 方式实现。</p><blockquote><p>优雅、巧妙地使用宏充满技巧。</p></blockquote><p>上面介绍的<code>RCT_EXPORT_MODULE</code>以及<code>RCT_EXPORT_METHOD</code>宏属于编译阶段的处理，下面我们从执行角度一步一步进行分析。<br><img src="/img/RNTimingDiagram.png" alt=""><br>上图是RN 初始化过程的时序图，我们将沿着图中的步骤逐步分析。</p><h2 id="注册NativeModule"><a href="#注册NativeModule" class="headerlink" title="注册NativeModule"></a>注册NativeModule</h2><p><img src="/img/RCTCxxBrigdeInitModulesWithDispatchGroup.png" alt=""><br>通过上述坐标，最终定位到<code>RCTCxxBridge._initModulesWithDispatchGroup</code>：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_initModulesWithDispatchGroup:(dispatch_group_t)dispatchGroup</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;Class&gt; *moduleClassesByID = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;RCTModuleData *&gt; *moduleDataByID = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSString</span> *, RCTModuleData *&gt; *moduleDataByName = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up moduleData for automatically-exported modules</span></span><br><span class="line">    <span class="keyword">for</span> (Class moduleClass <span class="keyword">in</span> RCTGetModuleClasses()) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *moduleName = RCTBridgeModuleNameForClass(moduleClass);</span><br><span class="line">        moduleData = [[RCTModuleData alloc] initWithModuleClass:moduleClass bridge:<span class="keyword">self</span>];</span><br><span class="line">       </span><br><span class="line">        moduleDataByName[moduleName] = moduleData;</span><br><span class="line">        [moduleClassesByID addObject:moduleClass];</span><br><span class="line">        [moduleDataByID addObject:moduleData];       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store modules</span></span><br><span class="line">    _moduleDataByID = [moduleDataByID <span class="keyword">copy</span>];</span><br><span class="line">    _moduleDataByName = [moduleDataByName <span class="keyword">copy</span>];</span><br><span class="line">    _moduleClassesByID = [moduleClassesByID <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>上述代码第<code>8</code>行<code>RCTGetModuleClasses()</code>即是获取通过<code>RCTRegisterModule</code>注册的 module 类(即所有曝露给 JS 的类)；</li><li>通过<code>RCTRegisterModule</code>注册的 module 默认使用<code>init</code>方法进行初始化，若某个 module 的初始化需要参数，可通过<code>RCTBridgeDelegate</code>-&gt;<code>extraModulesForBridge</code>或<code>moduleProvider</code>提供已初始化的 module 实例。</li></ul><p>至此，所有需要曝露给 JS 的 module 都已注册完成，并以<code>RCTModuleData</code>格式存储在<code>RCTCxxBridge</code>中。</p><blockquote><p>大部分 module 都是懒加载，只有那些需要在主线程完成初始化以及有常量需要导出的 module才会在注册时实例化。</p></blockquote><h2 id="Instance"><a href="#Instance" class="headerlink" title="Instance"></a>Instance</h2><p><img src="/img/JSCExecutor.png" alt=""><br>坐标定位到<code>RCTCxxBridge._initializeBridge</code>方法中：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_initializeBridge:(std::shared_ptr&lt;JSExecutorFactory&gt;)executorFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_reactInstance) &#123;</span><br><span class="line">        _reactInstance-&gt;initializeBridge(</span><br><span class="line">          std::unique_ptr&lt;RCTInstanceCallback&gt;(new RCTInstanceCallback(<span class="keyword">self</span>)),</span><br><span class="line">          executorFactory,</span><br><span class="line">          _jsMessageThread,</span><br><span class="line">          [<span class="keyword">self</span> _buildModuleRegistry]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>_initializeBridge</code>方法做的最重要的事情就是初始化<code>Instance</code>实例<code>_reactInstance</code>，此过程将所有曝露给 JS 的 module 由<code>RCTModuleData</code>格式转化为<code>ModuleRegistry</code>格式传入<code>Instance</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ModuleRegistry&gt;)_buildModuleRegistry</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> registry = <span class="built_in">std</span>::make_shared&lt;ModuleRegistry&gt;(createNativeModules(_moduleDataByID, self, _reactInstance));</span><br><span class="line">    <span class="keyword">return</span> registry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时，有必要介绍与 NativeModule 有关的几个类：<br><img src="/img/NativeModuleClassDiagram.png" alt=""></p><ul><li><code>JSCNativeModules</code>——<code>C++</code>类，在<code>JSCExecutor</code>中使用；</li><li><code>ModuleRegistry</code>——<code>C++</code>类，是<code>NativeModule</code>的集合；</li><li><code>NativeModule</code>——<code>C++</code>抽象类，定义了与 NativeModule 有关的接口；</li><li><code>RCTNativeModule</code>——实现了<code>NativeModule</code>中定义的接口；</li><li><code>RCTModuleData</code>——<code>OC</code>类，是存储曝露的moudle 的数据结构；</li><li><code>RCTBridgeMethod</code>——<code>OC</code>类，是存储曝露给 JS 接口(方法)的数据结构。</li></ul><p><code>Instance</code>是一个中转类，没有做太多的事情，我们继续向前。</p><h2 id="NativeToJsBridge"><a href="#NativeToJsBridge" class="headerlink" title="NativeToJsBridge"></a>NativeToJsBridge</h2><p>此时，来到<code>Instance::initializeBridge</code>-&gt;<code>NativeToJsBridge::NativeToJsBridge</code>，很明显<code>NativeToJsBridge</code>是 Native to JS 的桥接。<br>所有从 Native 到 JS 的调用都是从<code>NativeToJsBridge</code>中的接口发出去的。<br>在其构造函数中会初始化两个成员变量：</p><ul><li><code>m_executor</code>—<code>JSExecutor</code>类型的指针，从上文可知<code>JSExecutor</code>是个 <code>C++</code>抽象类，<code>m_executor</code>实际指向<code>JSCExecutor</code>的实例，作为 JS 的引擎，无论是 Native to JS 还是 JS to Native 最终都需要该类来处理，后面我们会逐一分析；</li><li><code>m_delegate</code>—<code>JsToNativeBridge</code>类型的指针，顾名思义，JS to Native 的桥接，该成员变量仅用于初始化<code>JSCExecutor</code>实例。</li></ul><h2 id="JSCExecutor"><a href="#JSCExecutor" class="headerlink" title="JSCExecutor"></a>JSCExecutor</h2><p>坐标定位到<code>NativeToJsBridge::NativeToJsBridge</code>-&gt;<code>JSCExecutor::JSCExecutor</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JSCExecutor::JSCExecutor(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ExecutorDelegate&gt; delegate,</span><br><span class="line">                         <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MessageQueueThread&gt; messageQueueThread,</span><br><span class="line">                         <span class="keyword">const</span> folly::dynamic&amp; jscConfig) <span class="keyword">throw</span>(JSException) :</span><br><span class="line">                         m_delegate(delegate),</span><br><span class="line">                         m_messageQueueThread(messageQueueThread),</span><br><span class="line">                         m_nativeModules(delegate ? delegate-&gt;getModuleRegistry() : <span class="literal">nullptr</span>),</span><br><span class="line">                         m_jscConfig(jscConfig) &#123;</span><br><span class="line">    initOnJSVMThread();</span><br><span class="line">    installGlobalProxy(m_context, <span class="string">"nativeModuleProxy"</span>,</span><br><span class="line">                       exceptionWrapMethod&lt;&amp;JSCExecutor::getNativeModule&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>JSCExecutor</code>的构造函数做了一条非常重要的事情：<strong><em>在 JS Context 中设置了一个全局代理<code>nativeModuleProxy</code>，其最终指向<code>JSCExecutor</code>类的<code>getNativeModule</code>方法</em></strong>。<br>至于说<code>nativeModuleProxy</code>为什么非常重要，留个悬念，后文再解，我们先看看<code>installGlobalProxy</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">installGlobalProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    JSGlobalContextRef ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">    JSObjectGetPropertyCallback callback)</span> </span>&#123;</span><br><span class="line">  JSClassDefinition proxyClassDefintion = kJSClassDefinitionEmpty;</span><br><span class="line">  proxyClassDefintion.attributes |= kJSClassAttributeNoAutomaticPrototype;</span><br><span class="line">  proxyClassDefintion.getProperty = callback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> isCustomJSC = isCustomJSCPtr(ctx);</span><br><span class="line">  JSClassRef proxyClass = JSC_JSClassCreate(isCustomJSC, &amp;proxyClassDefintion);</span><br><span class="line">  JSObjectRef proxyObj = JSC_JSObjectMake(ctx, proxyClass, <span class="literal">nullptr</span>);</span><br><span class="line">  JSC_JSClassRelease(isCustomJSC, proxyClass);</span><br><span class="line"></span><br><span class="line">  Object::getGlobalObject(ctx).setProperty(name, Value(ctx, proxyObj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结合上面两段代码总结一下：</p><ul><li><code>nativeModuleProxy</code>在JS Context 中是一个具有<code>JSObjectGetPropertyCallback</code>属性的对象(object)；</li><li><code>JSObjectGetPropertyCallback</code>非常神奇，其特点是在 JS 中访问对象属性(object.propertyName)时会触发 callback；</li><li><code>nativeModuleProxy</code>对应的 callback 最终会调用<code>JSCExecutor::getNativeModule</code>。</li></ul><p>在<code>JSCExecutor</code>构造函数中还调用了<code>initOnJSVMThread</code>方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSCExecutor::initOnJSVMThread()  &#123;</span><br><span class="line">    installNativeHook&lt;&amp;JSCExecutor::nativeFlushQueueImmediate&gt;(<span class="string">"nativeFlushQueueImmediate"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>initOnJSVMThread</code>方法中有个值得关注的点：在 JS Context 中 hook 了<code>JSCExecutor::nativeFlushQueueImmediate</code>。<br>简单讲，hook 后，在 JS 中调用<code>global.nativeFlushQueueImmediate(...)</code>，实际调用 Native 的<code>JSCExecutor::nativeFlushQueueImmediate</code>方法。<br>另外，在构造函数中也将native module 注册信息转换为<code>JSCNativeModules</code>格式存储了下来。</p><h2 id="JsToNativeBridge"><a href="#JsToNativeBridge" class="headerlink" title="JsToNativeBridge"></a>JsToNativeBridge</h2><p>坐标定位到<code>NativeToJsBridge::NativeToJsBridge</code>-&gt;<code>JsToNativeBridge::JsToNativeBridge</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JsToNativeBridge(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ModuleRegistry&gt; registry,</span><br><span class="line">                 <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;InstanceCallback&gt; callback)</span><br><span class="line">  : m_registry(registry)</span><br><span class="line">  , m_callback(callback) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>沿着调用链一路下来，最终 module 注册信息传入<code>JsToNativeBridge</code>，随后 JS to Native 的调用将用到这份信息。<br>至此，RN 初始化过程中与本文讨论的通信机制相关的内容基本结束。总结下来大概有几点：</p><ul><li>收集了所有曝露给 JS 的 module(也可称之为生成了一份 native module 注册表)；</li><li>在 JS Context 中设置了<code>nativeModuleProxy</code>以及<code>nativeFlushQueueImmediate</code>；</li><li>初始化了相关的类，如：<code>NativeToJsBridge</code>、<code>JsToNativeBridge</code>以及<code>JSCExecutor</code>等。</li></ul><p>现在可以说是『万事具备，只欠东风』——由 JS 发起对 Native 的调用了。<br>下面我们沿着调用路径继续往下分析。</p><h2 id="JS-NativeModules"><a href="#JS-NativeModules" class="headerlink" title="JS NativeModules"></a>JS NativeModules</h2><blockquote><p>这小节我们在 JS 中^-^</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="keyword">import</span> &#123; NativeModules &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">var</span> CalendarManager = NativeModules.CalendarManager;</span><br><span class="line">CalendarManager.addEvent(<span class="string">'Birthday Party'</span>, <span class="string">'4 Privet Drive, Surrey'</span>);</span><br></pre></td></tr></table></figure><p>回到之前那个例子，其调用的是<code>CalendarManager</code>module 的<code>addEvent:location:</code>方法。<br>展开上面的调用，最终的形式是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NativeModules.CalendarManager.addEvent(<span class="string">'Birthday Party'</span>, <span class="string">'4 Privet Drive, Surrey'</span>)</span><br></pre></td></tr></table></figure></p><p><code>NativeModules</code>定义在node_modules-&gt;react-native-&gt;Libraries-&gt;BatchedBridge-&gt;NativeModules.js。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> NativeModules : &#123;[moduleName: string]: <span class="built_in">Object</span>&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (global.nativeModuleProxy) &#123;</span><br><span class="line">  NativeModules = global.nativeModuleProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>nativeModuleProxy</code>正是上文提到的，由 Native 注入 JS 的具有<code>JSObjectGetPropertyCallback</code>属性的 object。<br>因此，JS 中的<code>NativeModules.CalendarManager</code>(取属性值)等价于调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSCExecutor::getNativeModule(NativeModules, `CalendarManager`)</span><br></pre></td></tr></table></figure></p><p>格式化：<br>JS中<code>NativeModules.moduleName</code> 等价于 Native 的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSCExecutor::getNativeModule(NativeModules, `moduleName`)</span><br></pre></td></tr></table></figure></p><p>也这是为什么说<code>nativeModuleProxy</code>非常重要的原因，所有从 JS to Native 的调用都需要其作为中间代理。<br>此时，又要切入 Native 环境了。</p><h2 id="ModuleRegistry-getConfig"><a href="#ModuleRegistry-getConfig" class="headerlink" title="ModuleRegistry::getConfig"></a>ModuleRegistry::getConfig</h2><p>由于接下来马上要用到 nativemodule 的信息，在此先提前准备好。<br>定位到<code>ModuleRegistry::getConfig</code>，通过上文可知在<code>ModuleRegistry</code>中存储了 nativemodule 的信息，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">folly::Optional&lt;ModuleConfig&gt; ModuleRegistry::getConfig(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) &#123;</span><br><span class="line">    <span class="keyword">auto</span> it = modulesByName_.find(name);</span><br><span class="line">    NativeModule* <span class="keyword">module</span> = modules_[it-&gt;second].get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string name, object constants, array methodNames (methodId is index), [array promiseMethodIds], [array syncMethodIds]</span></span><br><span class="line">    folly::dynamic config = folly::dynamic::<span class="built_in">array</span>(name);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MethodDescriptor&gt; methods = <span class="keyword">module</span>-&gt;getMethods();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; descriptor : methods) &#123;</span><br><span class="line">        methodNames.push_back(<span class="built_in">std</span>::move(descriptor.name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!methodNames.empty()) &#123;</span><br><span class="line">        config.push_back(<span class="built_in">std</span>::move(methodNames));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ModuleConfig(&#123;it-&gt;second, config&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>getConfig</code>方法最终将 native module 信息组装成一个数组，其格式：<br>[modulename, module 导出的 constants, [methodNames], [promiseMethodIds], [syncMethodIds]]<br>下面是<code>RCTWebSocketModule</code>导出的信息：<br><img src="/img/NativeModuleConfig.jpg" alt=""></p><p>在这过程中<code>RCTModuleData.methods</code>起到关键作用：<br>ModuleRegistry::getConfig-&gt;RCTNativeModule::getMethods-&gt;RCTModuleData.methods<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RCTModuleData.m</span></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;RCTBridgeMethod&gt;&gt; *)methods</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_methods) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&lt;RCTBridgeMethod&gt;&gt; *moduleMethods = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount;</span><br><span class="line">        Class cls = _moduleClass;</span><br><span class="line">        <span class="keyword">while</span> (cls &amp;&amp; cls != [<span class="built_in">NSObject</span> <span class="keyword">class</span>] &amp;&amp; cls != [<span class="built_in">NSProxy</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">            Method *methods = class_copyMethodList(object_getClass(cls), &amp;methodCount);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">                Method method = methods[i];</span><br><span class="line">                SEL selector = method_getName(method);</span><br><span class="line">                <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(selector) hasPrefix:<span class="string">@"__rct_export__"</span>]) &#123;</span><br><span class="line">                    IMP imp = method_getImplementation(method);</span><br><span class="line">                    <span class="built_in">NSArray</span> *entries = ((<span class="built_in">NSArray</span> *(*)(<span class="keyword">id</span>, SEL))imp)(_moduleClass, selector);</span><br><span class="line">                    <span class="keyword">id</span>&lt;RCTBridgeMethod&gt; moduleMethod =</span><br><span class="line">                    [[RCTModuleMethod alloc] initWithMethodSignature:entries[<span class="number">1</span>]</span><br><span class="line">                                                JSMethodName:entries[<span class="number">0</span>]</span><br><span class="line">                                                      isSync:((<span class="built_in">NSNumber</span> *)entries[<span class="number">2</span>]).boolValue</span><br><span class="line">                                                 moduleClass:_moduleClass];</span><br><span class="line"></span><br><span class="line">                    [moduleMethods addObject:moduleMethod];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _methods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>__rct_export__</code>是不是很熟悉，<code>RCTModuleData.methods</code>会遍历所有以<code>__rct_export__</code>为前缀的方法并执行以导出曝露给 JS 的接口。</p><h2 id="JSCNativeModules-createModule"><a href="#JSCNativeModules-createModule" class="headerlink" title="JSCNativeModules::createModule"></a>JSCNativeModules::createModule</h2><p>书接前文，JS to Native<br>NativeModules.moduleName(JS)-&gt;JSCExecutor::getNativeModule-&gt;JSCNativeModules::getModule-&gt;JSCNativeModules::createModule<br>沿调用链来到<code>JSCNativeModules::createModule</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">folly::Optional&lt;Object&gt; JSCNativeModules::createModule(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, JSContextRef context) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!m_genNativeModuleJS) &#123;</span><br><span class="line">    <span class="keyword">auto</span> global = Object::getGlobalObject(context);</span><br><span class="line">    m_genNativeModuleJS = global.getProperty(<span class="string">"__fbGenNativeModule"</span>).asObject();</span><br><span class="line">    m_genNativeModuleJS-&gt;makeProtected();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> result = m_moduleRegistry-&gt;getConfig(name);</span><br><span class="line">  Value moduleInfo = m_genNativeModuleJS-&gt;callAsFunction(&#123;</span><br><span class="line">    Value::fromDynamic(context, result-&gt;config),</span><br><span class="line">    Value::makeNumber(context, result-&gt;index)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  folly::Optional&lt;Object&gt; <span class="keyword">module</span>(moduleInfo.asObject().getProperty(<span class="string">"module"</span>).asObject());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">module</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 在<code>createModule</code>方法中，通过<code>ModuleRegistry::getConfig</code>(第<code>8</code>行)拿到了要调用的 native module 的信息(包括导出的常量、曝露的接口等)。<br>同时获取了 JS Context 中名为<code>__fbGenNativeModule</code>的属性(第<code>4</code>行)，从名称可知其作用是生成 JS 端的 Native Module 信息。<br><code>__fbGenNativeModule</code>定义在<code>NativeModules.js</code>中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export this method as a global so we can call it from native</span></span><br><span class="line">global.__fbGenNativeModule = genModule;</span><br></pre></td></tr></table></figure></p><h2 id="NativeModules-genModule"><a href="#NativeModules-genModule" class="headerlink" title="NativeModules.genModule"></a>NativeModules.genModule</h2><p>NativeModules.moduleName(JS)-&gt;JSCExecutor::getNativeModule-&gt;JSCNativeModules::getModule-&gt;JSCNativeModules::createModule-&gt;NativeModules. genModule(JS)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genModule</span>(<span class="params">config: ?ModuleConfig, moduleID: number</span>): ?</span>&#123;name: string, <span class="built_in">module</span>?: <span class="built_in">Object</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">const</span> [moduleName, constants, methods, promiseMethods, syncMethods] = config;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = &#123;&#125;;</span><br><span class="line">    methods &amp;&amp; methods.forEach(<span class="function">(<span class="params">methodName, methodID</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> methodType = isPromise ? <span class="string">'promise'</span> : isSync ? <span class="string">'sync'</span> : <span class="string">'async'</span>;</span><br><span class="line">        <span class="built_in">module</span>[methodName] = genMethod(moduleID, methodID, methodType);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="built_in">module</span>, constants);</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: moduleName, <span class="built_in">module</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>genModule</code>会遍历传入的<code>methods</code>数组，分别调用<code>genMethod</code>生成 JS 侧的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genMethod</span>(<span class="params">moduleID: number, methodID: number, type: MethodType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="literal">null</span>;</span><br><span class="line">    fn = <span class="function"><span class="keyword">function</span>(<span class="params">...args: Array&lt;any&gt;</span>) </span>&#123;</span><br><span class="line">        args = args.slice(<span class="number">0</span>, args.length - callbackCount);</span><br><span class="line">        BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess);</span><br><span class="line">    &#125;;</span><br><span class="line">    fn.type = type;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>genMethod</code>生成的函数非常简单，只是将对 native 的调用信息入队。<br>至此，由<code>NativeModules.moduleName</code>发起的调用链终于结束，最终返回结果：以 <code>methodName</code> 为 key，<code>genMethod</code> 生成的 function 为 value 的 JS object。即<code>NativeModules.moduleName</code>等价于<code>{methodName: fn}</code>。</p><blockquote><p>JS 中的 moduleID、methodID 对应 native moudle注册表中的数组下标。</p></blockquote><p>当然，事情并没有结束，继续扩展<code>NativeModules.moduleName.methodName(args)</code>。<br>通过上述分析，可知：<br><code>NativeModules.moduleName.methodName(args)</code>等价于：<br><code>BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess)</code></p><h2 id="MessageQueue-enqueueNativeCall"><a href="#MessageQueue-enqueueNativeCall" class="headerlink" title="MessageQueue.enqueueNativeCall"></a>MessageQueue.enqueueNativeCall</h2><p><code>NativeModules.moduleName.methodName</code>-&gt;<code>BatchedBridge.enqueueNativeCall</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MessageQueue = <span class="built_in">require</span>(<span class="string">'MessageQueue'</span>);</span><br><span class="line"><span class="keyword">const</span> BatchedBridge = <span class="keyword">new</span> MessageQueue();</span><br></pre></td></tr></table></figure></p><p>可以看到<code>BatchedBridge</code>就是<code>MessageQueue</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  enqueueNativeCall(moduleID: number, <span class="attr">methodID</span>: number, <span class="attr">params</span>: <span class="built_in">Array</span>&lt;any&gt;, <span class="attr">onFail</span>: ?<span class="built_in">Function</span>, <span class="attr">onSucc</span>: ?<span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._queue[MODULE_IDS].push(moduleID);</span><br><span class="line">    <span class="keyword">this</span>._queue[METHOD_IDS].push(methodID);</span><br><span class="line">    <span class="keyword">this</span>._queue[PARAMS].push(params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">if</span> (global.nativeFlushQueueImmediate &amp;&amp;</span><br><span class="line">        (now - <span class="keyword">this</span>._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS ||</span><br><span class="line">         <span class="keyword">this</span>._inCall === <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> queue = <span class="keyword">this</span>._queue;</span><br><span class="line">        <span class="keyword">this</span>._queue = [[], [], [], <span class="keyword">this</span>._callID];</span><br><span class="line">        <span class="keyword">this</span>._lastFlush = now;</span><br><span class="line">        global.nativeFlushQueueImmediate(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>enqueueNativeCall</code>方法中将调用信息(moduleID、methodID、params等入队)，若离上一次 flush queue 的时间超过5ms(<code>MIN_TIME_BETWEEN_FLUSHES_MS</code>)则立即 flush queue(出于性能考虑)。<br>对<code>nativeFlushQueueImmediate</code>是否还有影像？(在<code>JSCExecutor</code>构造函数中讲过了^_^)<br><code>global.nativeFlushQueueImmediate(queue)</code>等价于<code>JSCExecutor::nativeFlushQueueImmediate(queue)</code></p><h2 id="JsToNativeBridge-callNativeModules"><a href="#JsToNativeBridge-callNativeModules" class="headerlink" title="JsToNativeBridge::callNativeModules"></a>JsToNativeBridge::callNativeModules</h2><p><code>JSCExecutor::nativeFlushQueueImmediate</code>-&gt;<code>JSCExecutor::flushQueueImmediate</code>-&gt;<code>JsToNativeBridge::callNativeModules</code><br>沿着调用链，定位到<code>JsToNativeBridge::callNativeModules</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callNativeModules</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    JSExecutor&amp; executor, folly::dynamic&amp;&amp; calls, <span class="keyword">bool</span> isEndOfBatch)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; call : parseMethodCalls(<span class="built_in">std</span>::move(calls))) &#123;</span><br><span class="line">        m_registry-&gt;callNativeMethod(call.moduleId, call.methodId, <span class="built_in">std</span>::move(call.arguments), call.callId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`callNativeModules`会逐个解析从 JS 传过来的 call <span class="built_in">queue</span> 中的每个调用。</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">void</span> ModuleRegistry::callNativeMethod(<span class="keyword">unsigned</span> <span class="keyword">int</span> moduleId, <span class="keyword">unsigned</span> <span class="keyword">int</span> methodId, folly::dynamic&amp;&amp; params, <span class="keyword">int</span> callId) &#123;</span><br><span class="line">    modules_[moduleId]-&gt;invoke(methodId, <span class="built_in">std</span>::move(params), callId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>沿着调用链后面还有一些细节问题，由于篇幅关系，不再展开，主要如下：<br><img src="/img/RCTNativeModuleinvoke.jpg" alt=""><br><img src="/img/RCTModuleMethodinvokeWithBridge.jpg" alt=""><br>最终在<code>RCTModuleMethod.invokeWithBridge</code>中执行了调用<code>[_invocation invokeWithTarget:module];</code><br>至此，从 JS to Native 的调用结束！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JS to Native 的调用时序图：<br><img src="/img/JSToNativeCallTimingDiagram.png" alt=""><br>整个过程大概分为两个阶段：</p><ul><li>NativeModules.moduleName — 该过程主要是获取 native module 的信息(moduleID、methodID)，最终封装为 JS object ({methodName: fn})；</li><li>NativeModules.moduleName.methodName(params) — 执行调用。</li></ul><p>今天就到这了，下篇我们将分析 Native to JS。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过分析源码，逐步解析 ReactNative 中 JS to Native 的通信机制。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="框架" scheme="http://zxfcumtcs.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ReactNative" scheme="http://zxfcumtcs.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>Multithreading Traps</title>
    <link href="http://zxfcumtcs.github.io/2017/05/07/Multithreading-Traps/"/>
    <id>http://zxfcumtcs.github.io/2017/05/07/Multithreading-Traps/</id>
    <published>2017-05-07T10:02:11.000Z</published>
    <updated>2018-12-08T08:41:32.858Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先介绍了多线程的一些基本概念，如：atomicity、Out-of-order execution、Memory barrier等。然后结合 iOS 实际开发，分析了Property、dealloc、target-action、block、mutable containers等在多线程下的问题。最后，分享了几个小技巧。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>多线程使 CPU 的计算能力得到更加充分的利用，尤其在多核时代，程序因此变得更加流畅、高效。在 iOS 开发中，通过 GCD 更是能够零成本实现多线程，动不动就将某些耗时操作通过 GCD 分发到子线程执行，正是由于其廉价性，使得我们通常会忽略其引起的多线程问题。</p><p>多线程其实是把双刃剑，在带来流畅、高效的同时，也带来了很多问题，大大增加了程序复杂性。在开发中不难发现，很多bug、crash 都是多线程引发的。<br>多线程及其相关的问题，大致有以下特点：</p><ul><li>难重现(能重现的问题都不是问题)，多线程问题一般与特定的执行时序有关，重现难度大，一般在测试阶段很难发现，而发布之后通过大量用户才会曝露出来；</li><li>难理解，很多多线程问题除了看上去很奇怪、百思不得其解，找不到其他毛病，没有足够的经验很难发现是多线程引起的；</li><li>难意识，当我们在很嗨地写着多线程代码时，很难察觉正在挖坑！</li></ul><p>本文重点不是介绍多线程编程，而是多线程可能引发的问题，在继续之前有必要介绍几个重要概念：原子性(atomicity)、Out-of-order execution 以及 compiler reordering。</p><h1 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h1><hr><p>说到多线程，不得不提原子性(atomicity)，我们知道原子(atom)是化学中的概念，表示不可再分的基本粒子。在计算机领域，原子操作(原子性)是指在一次执行中不能被中断的操作。由于中断只发现在指令之间，因此在单处理器(UniProcessor)系统中，能通过一条指令完成的操作都具有原子性，然而在对称多处理器(Symmetrical Multi-Processing, SMP)系统中，由于同时存在多个处理器独立运行，单条指令操作也可能会受到干扰。因此，原子性通过软件是无法实现的，需要硬件层面的支持(架构相关的)。简单讲，CPU 通过缓存锁、总线锁在硬件层面可以实现原子性。</p><p>在目前大多数的 CPU 构架(如：x86、PowerPC、ARM)上，读写对齐的一个字长数据，能保证是原子的。如，在64位的系统中，读写对齐的 <code>int</code> 型数据的操作是原子操作。</p><p>原子性在多线程中是一个非常重要的概念，是实现线程同步(锁)的前提。</p><h1 id="Data-Races"><a href="#Data-Races" class="headerlink" title="Data Races"></a>Data Races</h1><hr><p>我们平时所说的多线程问题，其实绝大多数时候就是在讲 Data Races，出现 Data Races 有两个条件：</p><ul><li>在没有同步的情况下，多线程访问同一块内存；</li><li>至少有一个是写操作。</li></ul><p>其带来的后果可能是 crash、非预期的运行结果，当然也有可能是『无害』的。<br>如上文所说，在目前大多数 CPU 上，读写对齐的字长数据是原子操作，即有多个线程同时操作这一内存时不需要任何同步，也有人将其称之为『Benign Race』。但苹果工程师并不认同这种说法，主要有两点理由<a href="http://devstreaming.apple.com/videos/wwdc/2016/412jzguxz4h8hykgjlm/412/412_thread_sanitizer_and_static_analysis.pdf" target="_blank" rel="noopener">WWDC2016_412</a>：</p><ul><li>在 C 语言标准中，Benign Race 属于 undefined behavior；</li><li>在新的编译器或处理器上可能会引起问题(毕竟这不是一个公认标准)。</li></ul><p>因此，对于任何可能会出现 data races 的地方都要做好同步。</p><h1 id="Out-of-order-execution、compiler-reordering"><a href="#Out-of-order-execution、compiler-reordering" class="headerlink" title="Out-of-order execution、compiler reordering"></a>Out-of-order execution、compiler reordering</h1><hr><p>Out-of-order execution、compiler reordering，其实两者从代码执行的角度看，本质上是一样的，都是改变了代码原有的执行顺序。<br>只不过两者的“幕后黑手”以及发生时期不同：</p><ul><li>Out-of-order execution——由硬件(CPU)实现，也即在指令执行时(运行期)CPU改变了指令原有的顺序；</li><li>compiler reordering——由编译器实现，在编译过程中(编译期)改变了代码顺序。</li></ul><p>为什么会这样？此时大家可能更关心的是这个问题。很简单，两个字：『优化』，使得处理器能够更加高效的运行，具体细节已超出本文范围，不深入讨论。<br>那么问题又来了，这么“任性”地改变代码顺序不会出问题吗？<br>当然，它们(CPU、Compiler)是在『深入』分析的基础上，认为『安全』的前提下，才做的优化。</p><p>比如有这样一段代码：<img src="/img/thread1.jpg" alt=""></p><p>出于优化的目的，<code>setData</code>方法最终执行顺序可能就变成了：<img src="/img/thread1_outofreorder.jpg" alt=""></p><p>即改变了两条赋值语句的执行顺序。由于两者之间没有依赖关系(正是CPU、Compiler优化的前提)，因此这种优先是无害的。<br>但是，这是有前提的：单线程程序。</p><p>如果此时还存在Thread 2：<img src="/img/thread2.jpg" alt=""></p><p>如果两个线程执行顺序如下，那么上面的优化就存在问题了：<br><img src="/img/Out-of-order.jpeg" alt=""><br>最终输出的结果显然不是期望值。</p><p>之所以会出问题，在于 CPU、Compiler 没有能力处理多线程问题，它们一直停留在单线程模式中。因此，这个锅只有程序猿来接了！</p><h1 id="Memory-barrier"><a href="#Memory-barrier" class="headerlink" title="Memory barrier"></a>Memory barrier</h1><hr><p>Memory barrier 正是解决由 Out-of-order execution、compiler reordering 引起问题的方案。<br>Memory barrier 从字面(内存栅栏)即可理解其用途：强制要求处于 barrier 前的读、写操作的执行先于其后的读、写操作。<br><img src="/img/Memorybarrier.jpg" alt=""></p><p>如上图，Memory operation1、Memory operation2 在没有 Memory barrier 『保护』的情况下，其执行顺序可能会发生变化，而若在其间添加 Memory barrier，则可以保证他们的执行顺序不会改变。</p><p>系统也为我们提供了设置 Memory barrier 的接口：<code>OSMemoryBarrier</code>。</p><p>因此，上面例子中，我们只需在 thread1 两条写操作间添加 Memory barrier 即可：<img src="/img/thread1_memorybarrier.png" alt=""></p><blockquote><p>通过各种锁实现的线程同步，基础都实现了 Memory barrier。</p></blockquote><p>得益于锁内部实现了 Memory barrier，说实话，在实际编程中，我们很少需要考虑 Out-of-order execution、compiler reordering、Memory barrier。但并不代表可以无视它，在遇到一些『匪夷所思』的问题时，或许能为你提供一些思路。其实，任何问题都是这样，研究深度决定在分析、解决问题时的思考深度、视野广度。</p><p>介绍完这些多线程的通用问题，我们来看看与 iOS 开发相关的问题。</p><h1 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h1><hr><p>在继续之前，有必要先复习几个概念：变量、指针、指针变量。</p><ul><li>变量——本质就是在内存上分配的一块区域，在代码中一般通过一个名称(变量名)操作它；</li><li>指针——本质就是一个整型数值，标识一块内存的起始地址；</li><li>指针变量——存储指针数值的变量。</li></ul><p>通过一个简单的例子看一下：<img src="/img/ipointer.png" alt=""><br><code>pi</code>是一个指向 <code>int</code> 型的指针变量，其指向了变量<code>i</code>，如下图，我们假设变量<code>i</code>的内存地址为<code>0x0ffab1234678</code>，则变量<code>pi</code>的值就等于<code>0x0ffab1234678</code>。当然，变量<code>pi</code>也有自己的内存地址(假设为：<code>0x0ffab1234660</code>)，也可以有一个指针来指向它，称之为指针的指针(<code>int **</code>)。</p><p><img src="/img/pointer.jpg" alt=""></p><p>对象的属性可分为两种类型：</p><ul><li>值类型——即非指针类型，如<code>int</code>、<code>bool</code>、<code>double</code>；</li><li>引用类型——所有声明为指针类型的属性(OC 中所有对象都是此类型)。</li></ul><p>说到Property线程安全问题，必然会想到在定义Property时可以选择<code>atomic</code>或<code>nonatomic</code>这两个attribute之一，默认为<code>atomic</code>。<br>若在定义 Property 时选择<code>atomic</code>，则系统在实现默认 getter、setter 方法时会加锁。那么<code>atomic</code>一定能实现我们想要的线程安全吗？<br>对于值类型的属性，<code>atomic</code>确实能保证对该属性的操作是 thread-safety。但对于引用类型的属性，则情况更加复杂，不一定能保证 thread-safety。</p><p>我们来看个例子：<br><img src="/img/array_objs.jpg" alt=""><img src="/img/array_objs_addobjects.jpg" alt=""><img src="/img/array-objs-result.jpg" alt=""><br>分别从主线程和子线程往具有<code>atomic</code>attribute 的属性<code>objs</code>中添加了200000个元素，但最终<code>objs</code>中元素的个数小于200000个，明显是由于多线程的 data race 引起的。<br>可以看到此处的<code>atomic</code>并没有解决多线程问题。原因也很简单，对于引用类型的属性，<code>atomic</code>『保护』的是属性本身(本质是一个指针变量)，而我们操作的是属性(指针)所指向的那块内存，其并不在<code>atomic</code>保护的范围之内。</p><p>由于<code>atomic</code>并没有想像中那么有用，并且会有一定的性能问题，因此，一般定义属性时并不会使用它，而是在需要同步时，手动实现。</p><blockquote><p>在使用<code>atomic</code>属性时，还有两个点需要注意：</p><ol><li>若自定义了 getter、setter 方法，则需要自己实现 atomic 语义；</li><li>若直接访问属性的存储变量，则失去了 atomic 语义。</li></ol></blockquote><h1 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h1><hr><p>我们知道，object 在哪个线程上被最终释放，其<code>dealloc</code>方法就会在哪个线程上执行。这里主要的问题在于有些类的<code>dealloc</code>方法在子线程上执行是不安全的，如 <code>UIKit object</code>。</p><p>当我们开启新的子线程时，子线程一般会 retain 其 target，如：</p><ul><li>通过<code>performSelectorInBackground:</code>、<code>performSelector:onThread:</code>方法开启子线程；</li><li>通过<code>NSThread</code>开启子线程；</li><li>通过 GCD 开启子线程，其block引用了 target。</li></ul><p>当子线程 retain 了 target 时，必须要保证该线程对 target 的释放先于主线程。否则，若子线程持有对 target 的最后一个引用，target 的<code>dealloc</code>方法必定会在子线程上执行，这对于 UI 来说是不允许的。</p><p>但有意思的是，我们发现从 iOS8 开始，即使是在子线程上释放 UI 对象，系统也会将其<code>dealloc</code>方法分发到主线程上执行。<br><img src="/img/vcrelease.jpg" alt=""><br>如上图代码，在子线程释放了一个<code>UIViewController</code>的object，按理该 object 的<code>dealloc</code>方法会在子线程中执行，我们在其<code>dealloc</code>方法添加了断点，结果如下：<br><img src="/img/uideallocmainthread.jpg" alt=""><br>可以看到，系统最终还是在主线程上执行了<code>UIViewController</code>的<code>dealloc</code>方法。<br>为了进一步验证，在<code>UIViewController</code>的<code>release</code>方法上添加断点：<br><img src="/img/releasebreakpoint.jpg" alt=""><img src="/img/controllerreleaseresult.png" alt=""><br>可以看到，系统在实现<code>UIViewController</code>的<code>release</code>方法时，做了一定的处理：</p><ul><li>在上图所示的1处，通过<code>pthread_main_np</code>方法判断当前是否是在主线程上执行；</li><li>2处，进行了判断，若不是在主线程上执行，则直接跳转到<code>0x117a18a1a</code>处(跳过了直接执行<code>dealloc</code>方法)；</li><li>3处(<code>0x117a18a1a</code>)，dispatch 到主线程上执行<code>dealloc</code>方法。</li></ul><blockquote><p>需要注意的是，到目前为止还没找到官方文档明确这件事。因此，我们最好不要做这样的假设，还是要从代码角度确保 UI 的 dealloc 方法永远在 main thread 上执行。</p></blockquote><h1 id="target-action"><a href="#target-action" class="headerlink" title="target-action"></a>target-action</h1><hr><p>在 Objective-C 中，实现回调(callback)，主要有两种方式：target-action(observer-selector)、block。<br>这一小节，我们来谈谈 target-action 模式在多线程下存在的问题。<br>target-action 模式通常情形如下：(有两个对象：<code>objA</code>、<code>objB</code>)</p><ul><li><code>objA</code>关心<code>objB</code>上某个特定事件EventA；</li><li><code>objB</code>包含<code>objA</code>的弱引用(weak/assign);</li><li>当<code>objB</code>上 EventA 事件发生时，其回调<code>objA</code>的某个方法；</li><li>通常 EventA 事件发生在子线程上。</li></ul><p>由于，objB 没有强引用 objA，使得 objA 在执行回调时，objA 可能在另外一个线程中被释放，从而出现野指针。<br><img src="/img/target-action.jpg" alt=""></p><p>细想一下，NSNotification、KVO 都属于 target-action(observer-selector) 模式，它们有两个共同点：</p><ul><li>在哪个线程触发，就在哪个线程调用 observer-selector，其引发的最常见问题就是在子线程修改 UI；</li><li>observer 的 selector 是同步执行的。</li></ul><p>进一步深入分析发现：</p><ul><li>从 iOS9 开始，NSNotificaionCenter 在抛通知时会强持有 observer，直到 observer 执行完其 action；<br><img src="/img/notification.png" alt=""><img src="/img/notificationdealloc.jpg" alt=""><br>如上代码，在子线程抛出通知，此后我们的代码就再也没有强引用消息的 observer，但从执行的结果可以看出，首先没有 crash(没有出现野指针)，其次 observer 的<code>dealloc</code>方法在<code>notificationHandler</code>后执行。<br><img src="/img/notificationdeallocstack.jpg" alt=""><br>通过在 observer 的<code>dealloc</code>方法添加断点可以看到，是在<code>postNotificationName:</code>方法中触发了其<code>dealloc</code>方法的执行。</li><li>KVO 在<code>NSKeyValueWillChange</code>方法调用了 observer 的<code>retain</code>方法，从而确保在 KVO 回调执行过程中，observer 不会被释放，出现野指针的问题：<br><img src="/img/KVORetain.jpg" alt=""></li></ul><blockquote><p>与 KVO 不同的是 NSNotificationCenter 并没有直接调用 observer 的<code>retain</code>方法，猜测是通过更加低层的方式对 observer 进行了 retain 操作。</p></blockquote><p>NSNotificationCenter、KVO 的这种处理方式给我们很大的启发：<br><strong><em>在执行回调前先对 target 进行 retain 操作，防止出现野指针问题，在回调完成后再 release。</em></strong></p><p>然而，事情远没这么简单，NSNotificationCenter、KVO 并非线程安全的。</p><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>上面讲到，KVO 在触发时会 retain observer，防止出现野指针，但线程安全问题依然存在。<br><img src="/img/KVOObserverDealloc.jpg" alt=""><br>如上图，observer 在 thread1 上执行 <code>dealloc</code> 时(在调用<code>removeObserver:</code>前) thread2 触发 KVO，此时会在 thread2 上执行 KVO 回调<code>observeValueForKeyPath:</code>，此刻 observer 已成野指针了(虽然 KVO 会调用 observer 的 <code>retain</code> 方法，但由于 observer 的<code>dealloc</code>方法已开始执行，<code>retain</code>也无力回天了！)。</p><p>怎么解决？</p><ul><li>不要使用 KVO，当时在 QQ 阅读项目开发红包模块时，在灰度中发现这类 crash，最终放弃了 KVO 这一方案；</li><li>不要跨线程使用 KVO；</li><li>apple 建议将 observer 设计成一个永不被释放的对象，facebook 著名 KVO 开源框架 <a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">FBKVOController</a> 就采用了这一方法，其内部有一个单例<code>_FBKVOSharedController</code>，专门用于接收所有的 KVO 回调。</li></ul><h2 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h2><p>说到 NSNotificationCenter，第一反应是需要在 observer 的<code>dealloc</code>方法中将其从 Notification Center 移除，否则会 crash。但从 iOS9 开始，并不需要手动在<code>dealloc</code>中移除，原因是在 Notification Center 中 observer 被存储为<code>weak</code>，其最大、最有用的特点就是在其所指 object 释放前会被置为 <code>nil</code>。因此，从 iOS9 开始，NSNotificationCenter 是线程安全的，不会出现像 KVO 那样在 <code>dealloc</code> 执行过程中触发回调的问题。</p><blockquote><p>总结 NSNotificationCenter 在 iOS8、9上的表现，以及 KVO 的表现，可以得出在实现 target-action(delegate) 模式时可借鉴的经验：</p><ul><li>target 一定要是 weak——防止在 target dealloc 过程中触发回调；</li><li>在触发回调前先对 target 进行 retain 操作——防止在回调执行过程中，target 被释放，出现野指针。</li></ul></blockquote><h1 id="block"><a href="#block" class="headerlink" title="block"></a>block</h1><hr><p>作为 callback 的实现方式之一，block 由于具有保存 context 的优势，其使用的广泛程度甚至高于 target-action 模式。说到 block，一定会想到其引发的 retain cycle 问题。<br>为了解决 retain cycle 问题，在 MRC 下一般使用<code>__block</code>，ARC 下使用<code>__weak</code>。<br>在 MRC 下使用<code>__block</code>非常危险(极容易出现野指针)，必须保证在 block 执行时，<code>__block</code>指向的 object 还存在。<br><img src="/img/MRCBlockCrash.jpg" alt=""><br>如上面这个例子，在 dispatch_async 执行过程中，self 被释放，出现野指针。<br>ps：当然这里仅是个例子，实际中 GCD api 一般是不需要考虑 retain cycle。</p><p>ARC 下，由于有 weak，一般不会出现野指针，但 block 在执行时，<code>self</code> 可能已是 <code>nil</code>，处理不好也有可能会 crash。比较好的做法是，将 block 体封装成方法，这时如果 <code>self</code> 为 <code>nil</code>，方法就不会被执行。<br><img src="/img/blocktomethod.jpg" alt=""></p><h1 id="mutable-containers"><a href="#mutable-containers" class="headerlink" title="mutable containers"></a>mutable containers</h1><hr><p>Objective-C 中可变容器是非线程安全的，其导致的多线程问题也是在实际开发中遇到最多的一类线程安全问题。而这其中，<code>*** was mutated while being enumerated.</code>最为常见，并且大多数都是由多线程引起的(一个线程遍历，另一个线程写)。<br>解决这类问题需要注意两点：</p><ul><li>一定不能对外提供接口能直接访问类内部的mutable containers；</li><li>对 containers 的读(包括整个遍历过程)、写都需要加锁做好同步。</li></ul><p>我们都知道 UI 操作需要在主线程执行，除了这点 <code>UITableView</code> 似乎与多线程没啥关系，实则不然。<br>在使用 UITableView 时，我们经常是将其数据(datasource)保存在数组中，而数据来源要么是磁盘、要么是网络，基本都是在子线程完成。<br><img src="/img/tableviewthreadsafe.jpg" alt=""><br>如上图所示，经常犯的一个错误是在子线程获得数据后，直接修改了 UITableView 的 dataSource，而此时可能主线程上 UITableView 的回调也正在读 dataSoure，从而出现 data race 问题。<br>一定要记住，UITableView datasource 的刷新必须要在主线程上完成(当然，请求数据的过程可以在，也应该在子线程上执行)。</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><hr><p>最后分享几个小技巧。</p><h2 id="Thread-Sanitizer-TSan"><a href="#Thread-Sanitizer-TSan" class="headerlink" title="Thread Sanitizer (TSan)"></a>Thread Sanitizer (TSan)</h2><p>针对多线程问题，Apple 在 Xcode8 中推出了扫描工具(目前只支持 64-bit 的模拟器)：Thread Sanitizer (TSan)，其具有以下功能：</p><ul><li>Use of uninitialized mutexes；</li><li>Thread leaks (missing pthread_join)；</li><li>Unsafe calls in signal handlers (ex: malloc)；</li><li>Unlock from wrong thread；</li><li>Data races。</li></ul><p>其中，对 Data races 的扫描功能非常棒！建议大家在每个版本都用 TSan 扫描一次。更多信息可以参看 <a href="https://developer.apple.com/videos/play/wwdc2016/412/" target="_blank" rel="noopener">WWDC2016-412 Thread Sanitizer and Static Analysis</a>。</p><h2 id="放大法定位问题"><a href="#放大法定位问题" class="headerlink" title="放大法定位问题"></a>放大法定位问题</h2><p>由于多线程问题，一般复现难度大，只有在特定的执行时序下才能重现，无疑增加了排查、分析、解决问题的难度。<br>此时，我们可以通过放大法把小概率事件变成大概率事件，如：通过循环反复执行某一操作、通过 sleep 增大不安全的窗口期等。</p><h2 id="提供接口让调用方指定callback-thread"><a href="#提供接口让调用方指定callback-thread" class="headerlink" title="提供接口让调用方指定callback thread"></a>提供接口让调用方指定callback thread</h2><p>callback 应该在哪个 thread 上执行，在开发过程中经常有这样的问题。通常的做法是：要么粗暴的 dispatch 到 main thread，要么直接在当前线程执行。<br>其实，更好的做法是提供接口让调用方指定在哪个 thread callback。<br>目前，有不少开源库都是这么处理的，如：facebook 著名的 websocket 开源库 <a href="https://github.com/facebook/SocketRocket" target="_blank" rel="noopener">SocketRocket</a>：<br><img src="/img/RocketSocket.jpg" alt=""><br>如上图，其在提供<code>delegate</code>接口的同时，提供了两个接口：<code>delegateDispatchQueue</code>、<code>delegateOperationQueue</code>。</p><h2 id="通过-queue-specific-判断当前是否在某个队列中执行任务"><a href="#通过-queue-specific-判断当前是否在某个队列中执行任务" class="headerlink" title="通过 queue specific 判断当前是否在某个队列中执行任务"></a>通过 queue specific 判断当前是否在某个队列中执行任务</h2><p>为了在某队列上同步执行任务，经常需要判断当前是否已在该队列上，否则容易出现 deadlock。通过<code>dispatch_queue_get_specific</code>、<code>dispatch_queue_set_specific</code>这两个 api 可以方便的实现：<br><img src="/img/queuespecific.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>多线程在带来流畅、高效的同时，也带来了无尽的问题。多线程问题本身非常复杂，本文也只是简单分析了几类常见的多线程问题。<br>总的来说，多线程问题并没有什么统一解决方案，因人因事而异，更多的需要依赖开发人员的经验和严谨的态度。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html" target="_blank" rel="noopener">Threading Programming Guide</a><br><a href="https://developer.apple.com/library/content/technotes/tn2109/_index.html" target="_blank" rel="noopener">Simple and Reliable Threading with NSOperation</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/412/" target="_blank" rel="noopener">WWDC2016-412 Thread Sanitizer and Static Analysis</a><br><a href="http://inessential.com/2013/12/20/observers_and_thread_safety" target="_blank" rel="noopener">Observers and Thread Safety</a><br><a href="https://en.wikipedia.org/wiki/Out-of-order_execution" target="_blank" rel="noopener">Out-of-order execution</a><br><a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">Memory barrier</a><br><a href="http://stackoverflow.com/questions/32006565/why-is-uiviewcontroller-deallocated-on-the-main-thread" target="_blank" rel="noopener">Why is UIViewController deallocated on the main thread?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先介绍了多线程的一些基本概念，如：atomicity、Out-of-order execution、Memory barrier等。然后结合 iOS 实际开发，分析了Property、dealloc、target-action、block、mutable containers等在多线程下的问题。最后，分享了几个小技巧。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="Multithreading" scheme="http://zxfcumtcs.github.io/tags/Multithreading/"/>
    
  </entry>
  
  <entry>
    <title>自定义 UI 组件库</title>
    <link href="http://zxfcumtcs.github.io/2017/03/04/CustomUIControls/"/>
    <id>http://zxfcumtcs.github.io/2017/03/04/CustomUIControls/</id>
    <published>2017-03-04T14:34:44.000Z</published>
    <updated>2018-12-08T08:41:32.857Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了通过 View-ViewModel 模式构建 UI 组件，以便提高 UI 组件的可复用性。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>『不要重复造轮子，要注意代码复用，提高开发效率』，这是在日常开发中经常挂在嘴边的话。对 copy code 的行为我们经常也报以鄙视的目光。<br>但是，copy 行为却又时常发生，经常是一言不合就 copy！</p><p>在继续之前，我们有必要思考两个问题：</p><ul><li>什么样的代码被复用的概率最高；</li><li>copy code 的行为为何如此普遍。</li></ul><h2 id="什么样的代码被复用的概率最高"><a href="#什么样的代码被复用的概率最高" class="headerlink" title="什么样的代码被复用的概率最高"></a>什么样的代码被复用的概率最高</h2><p>代码复用可分为二个层级：APP 间以及 APP 内部。<br>APP 间被复用的代码通常是些基础组件，如：网络、数据库、日志系统、磁盘存储系统等。<br>APP 内部复用概率最高的代码个人认为是 UI 组件（本文所说的 UI 组件为 APP 内部自定义的 UI）。</p><h2 id="copy-code-的行为为何经常发生"><a href="#copy-code-的行为为何经常发生" class="headerlink" title="copy code 的行为为何经常发生"></a>copy code 的行为为何经常发生</h2><p>既然大家都会鄙视 copy 行为，为何又时常发生呢？<br>你可能会说 copy 的同学觉悟、追求不高。<br>但，从另一角度是否也说明代码的可复用性、可扩展性比较差。<br>现在一般都是敏捷开发、快速迭代，时间紧、任务重，在遇到相似、相近的代码时，大家通常都是拷一份过来，改吧改吧，而不是在原有基础上费时费力地扩展。这其中的弊端就不用多说了！</p><p>UI 组件作为 APP 内部复用概率最高的代码，更是 copy 的重灾区。究其原因，在于在 UI 组件中包含了大量的业务逻辑，导致一个 UI 组件要复用到另外一个业务下非常困难。主要体现在：</p><ul><li>UI 组件与业务数据相绑定（与后台协议返回的数据结构相对应的 OC 对象，我们称之为 item）；</li><li>UI 组件内部处理了业务逻辑。</li></ul><p>举个例子，在 QQ 阅读的信息流中有一种常见的 UI 样式：左图右文(QRFeedFlowBookView)<br><img src="/img/FeedFLowLeftPictureRightText.jpg" alt=""><br>在当初实现该 UI 样式时，数据是通过 QRFeedFlowBookItem(业务数据结构) 传递给 QRFeedFlowBookView，即在 QRFeedFlowBookView 内部处理了具体的业务数据。这导致，QRFeedFlowBookView 在业务数据不是或不能通过 QRFeedFlowBookItem 表示时，无法复用。<br>还有，像一些角标要不要展现，具体逻辑也是在 QRFeedFlowBookView 中处理的，此时如各个业务对此的逻辑不同，QRFeedFlowBookView 也无法复用。</p><h1 id="以-View-ViewModel-形式构建-UI-组件"><a href="#以-View-ViewModel-形式构建-UI-组件" class="headerlink" title="以 View-ViewModel 形式构建 UI 组件"></a>以 View-ViewModel 形式构建 UI 组件</h1><hr><p>从上面分析出的 UI 组件难于复用的原因，可以看出要解决这一问题，就是要避免上文提到的2点：</p><ul><li>UI 组件不能与具体业务数据相绑定；</li><li>UI 组件内部不能处理业务逻辑（其本职工作仅是 UI 布局）。</li></ul><p>此时，MVVM 模式应该要进入我们的视线了，在该模式中 ViewModel 的存在是不是很好的解决了上面的问题。<br>我们知道在 MVVM 模式中，ViewModel 向上为 View 提供展示数据（该数据已经在 ViewModel 中处理好了，View 无需任何处理，只要展示即可），向下接收来自业务层的数据，处理相关的业务逻辑。</p><p>可以看出，ViewModel 作为中间层很好地将业务与 UI 隔离开。<br>说到 MVVM，很多同学并不喜欢，觉得其中的 Data-Binding 很麻烦，但我们构建 UI 组件时用到的是 View-ViewModel 结构，并不要求一定是 MVVM，在 MVC 等模式下也可使用。</p><p>同时，我们采用的是面向接口的模式，View 对外依赖的是接口（protocol），而不是某个具体的 ViewModel。每个 UI 组件其结构如下所示：<br><img src="/img/ViewViewModel.png" alt=""><br>如上图所示，若某个 UI 组件被多个业务所复用，可以根据需求定义多个 ViewModel 以处理不同的业务逻辑，每个 ViewModel 都实现 ViewModelProtocol 协议为 View 提供数据。</p><p>另外，UI 组件也可以包含(复用)其他 UI 组件。</p><p>如上文提到的左图右文 UI，我们抽取为一个组件 QRLeftPictureRightTextView：<br><img src="/img/QRLeftPictureRightTextView.png" alt=""><img src="/img/QRLeftPictureRightTextViewModel.png" alt=""><br>该控件在信息流以及老书城都有用到，为此我们也定义了两个 ViewModel，以处理各自的业务逻辑：<br><img src="/img/QRLeftPictureRightText.jpg" alt=""></p><p>在日常开发中，经常有同学问『某某样子的 UI 我们现在有吗，是哪个类？』<br>为此，我们在构建 UI 组件库的同时也维护了一份文档，将所有组件都『登记造册』：<br><img src="/img/QRLeftPictureRigthTextDoc.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>通过 ViewModel 这个中间层很好地隔离了 UI 与业务逻辑，使 UI 复用性更好，不仅提高了开发效率，也规范了代码结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍了通过 View-ViewModel 模式构建 UI 组件，以便提高 UI 组件的可复用性。&lt;br&gt;
    
    </summary>
    
    
      <category term="构架" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%84%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>简化 iOS Data Binding</title>
    <link href="http://zxfcumtcs.github.io/2016/11/05/iOSDataBinding/"/>
    <id>http://zxfcumtcs.github.io/2016/11/05/iOSDataBinding/</id>
    <published>2016-11-05T10:55:46.000Z</published>
    <updated>2018-12-08T08:41:32.864Z</updated>
    
    <content type="html"><![CDATA[<p>ZSKVOController 是一个基于 KVO 的 Data Binding 框架，本文简要介绍其实现原理。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>在<a href="https://zxfcumtcs.github.io/2016/07/20/MobileArchitecture/">《不谈框架，谈细节》</a>这篇文章中，简要分析了当前移动开发中几种常见的框架 ( MVC、MVP、MVVM 等)，其中数据绑定 ( Data Binding ) 是 MVVM 与其他 MV* 模式的一个显著区别。目前，iOS 中现实数据绑定主要有两种方式：</p><ul><li>KVO；</li><li>三方开源库 ReactiveCocoa。</li></ul><p>其中，ReactiveCocoa 学习成本比较高，使用并不十分广泛。<br>在<a href="https://zxfcumtcs.github.io/2015/09/18/KVO/">《KVO漫谈》</a>这篇文章中，我们分析了 KVO 实现的基本原理，也对 KVO 存在的问题作了简要的描述，其在使用中存在的问题主要有：</p><ul><li>KeyPath 需要逐个注册，并且是字符串形式的硬编码，无法通过编译器检查错误；</li><li>KVO 回调都集中在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中，通常使得该方法过于庞大；</li><li>observer 的注册与注销必须成对出现，否则极容易出现 crash。</li></ul><p>作为一个优秀的框架或工具至少需要具备两点：</p><ul><li>能提升开发效率；</li><li>不给使用者提供犯错误的机会。</li></ul><p>因此，我们希望简化后的 Data Binding ( 基于 KVO ) 也具备这些优点，具体讲：</p><ul><li>简化注册过程；</li><li>不同的 KeyPath 对应不同的回调方法；</li><li>不需要手动注销 ( 使用者没有犯错的机会 )。</li></ul><h1 id="ZSKVOController"><a href="#ZSKVOController" class="headerlink" title="ZSKVOController"></a>ZSKVOController</h1><hr><p>ZSKVOController 是我们实现的基于 KVO 的 Data Binding 框架。<br>首先，我们看看 ZSKVOController 框架达到的效果：<br>假如：<br>在 ViewModel 中有属性：<code>title</code>、<code>desc</code>，<br>View 需要绑定<code>title</code>、<code>desc</code>，则在 View 中只需做两件事：</p><ul><li>绑定：将 ViewModel 绑定到 View 上<code>[_viewModel zs_addKVOObserver:self];</code>；</li><li>实现方法：<code>zs_observeTitle:</code>、<code>zs_observeDesc:</code>。</li></ul><p>如<code>zs_observeDesc:</code>的实现如下：<br><img src="/img/zs_observeDesc.jpg" alt=""><br>是不是简单多了。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><hr><p>我们知道，对于属性，可以重写 setter 方法，其 setter 方法名是通过一定的规则生成的：’set’ + 属性名(大写首字母)<br>我们也可通过类似的方式生成 KeyPath 对应的 Data Binding 回调方法，如：’zs_observe’ + KeyPath(大写首字母)。</p><p>其余的事情全由 ZSKVOController 框架完成，其结构如下所示：<br><img src="/img/ZSKVOController.png" alt=""></p><p>核心思想：</p><ul><li>在将 observeder(ViewModel) 绑定到 observer(View) 上时 (即调用<code>zs_addKVOObserver:</code>方法)，动态遍历 observer 的实例方法，找到所有符合：”zs_observe*:” 命名规则的方法，从中解析出需要绑定的 KeyPath；</li><li>为了在 observer(View) dealloc 时不需要手动 remove，我们在 observer 上动态添加属性：ZSKVOController，由其注册对 observeder(ViewModel)的绑定，在其 <code>dealloc</code> 方法中 remove KVO；</li><li>为了在 observeder(ViewModel) dealloc 时不需要手动 remove KVO，我们为 observeder 动态添加了一个监视其 dealloc 的『哨兵』属性：ZSObservederDeallocGuard，在其 dealloc 方法中 remove 所有 KVO。</li></ul><p>具体实现细节，请参看源码：<a href="https://github.com/zxfcumtcs/ZSKVOController" target="_blank" rel="noopener">ZSKVOController</a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>ZSKVOController 内部通过 KVO 实现 Data Binding，是对 KVO 的一次封装，从注册到数据变化的处理都有较大的简化，同时，无需手动 remove KVO。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ZSKVOController 是一个基于 KVO 的 Data Binding 框架，本文简要介绍其实现原理。&lt;br&gt;
    
    </summary>
    
    
      <category term="构架" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%84%E6%9E%B6/"/>
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://zxfcumtcs.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 问答</title>
    <link href="http://zxfcumtcs.github.io/2016/08/28/Https/"/>
    <id>http://zxfcumtcs.github.io/2016/08/28/Https/</id>
    <published>2016-08-28T09:19:48.000Z</published>
    <updated>2018-12-08T08:41:32.857Z</updated>
    
    <content type="html"><![CDATA[<p>本文从问题入手，简单分析了 HTTPS 中 TLS 握手过程以及简单介绍了数字签名、数字证书、对称加密、非对称加密等知识。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>为了加强网络安全，2015年，Apple 在 iOS9、OS X v10.11 上提出 ATS (App Transport Security) 的概念，旨在通过 HTTPS 建立安全连接。当时，ATS 还是个可选项，但 Apple 在 WWDC 2016 上表示，从2017年1月1日起所有 app 都必须使用 ATS (不清楚不使用的后果是什么，可能是拒绝提交 app store)。</p><blockquote><p>Apple 对 ATS 有如下要求：</p><ol><li>The server must support at least Transport Layer Security (TLS) protocol version 1.2.</li><li>Connection ciphers are limited to those that provide forward secrecy.</li><li>Certificates must be signed using a SHA256 or better signature hash algorithm, with either a 2048 bit or greater RSA key or a 256 bit or greater Elliptic-Curve (ECC) key.</li></ol></blockquote><p>由于系统网络 API，如：<code>NSURLConnection</code>、<code>NSURLSession</code> 已经支持 HTTPS，因此，客户端从 HTTP 切换到 HTTPS 几乎没有什么工作量 (前提是后台使用了可靠的证书)。</p><p>但作为开发人员，对于 HTTPS 的基本概念、流程还是需要了解，以便在出现问题时能快速定位问题、解决问题 (所谓知彼知己)。<br>下面我们将通过问答的形式讨论分析 HTTPS 的基本原理。</p><h1 id="HTTPS-的使命是什么？"><a href="#HTTPS-的使命是什么？" class="headerlink" title="HTTPS 的使命是什么？"></a>HTTPS 的使命是什么？</h1><hr><p><strong>『建立安全的网络连接』</strong><br>没错，但反过来要问了， HTTP 为什么不安全？<br>『HTTP (Hypertext Transfer Protocol，超文本传输协议)』 通过明文传输通信内容，导致信息很容易被窃听、篡改，同时无法验证通信双方的身份。</p><p>因此，HTTPS 要解决这些问题：</p><ul><li>信息加密——防止信息被窃听；</li><li>信息完整性校验——防止信息被篡改；</li><li>身份认证——防止信息劫持。</li></ul><h1 id="HTTPS-与-HTTP-什么关系？"><a href="#HTTPS-与-HTTP-什么关系？" class="headerlink" title="HTTPS 与 HTTP 什么关系？"></a>HTTPS 与 HTTP 什么关系？</h1><hr><p>我们知道，网络协议都是处在 OSI 七层网络模型之中，得益于良好的分层模型，HTTPS 就是在 HTTP 协议栈的基础之上添加了一个安全层 TLS/SSL (Transport Layer Security/Secure Sockets Layer)。<img src="/img/HTTPHTTPS.png" alt="">在 HTTPS 协议栈中，HTTP、TCP 协议无须任何改动，加解密、认证等工作由 TLS 层完成。</p><h1 id="HTTPS-工作原理是什么？"><a href="#HTTPS-工作原理是什么？" class="headerlink" title="HTTPS 工作原理是什么？"></a>HTTPS 工作原理是什么？</h1><hr><p>这是一个很大的问题，细分的话就是 HTTPS 如何完成它的3个使命：加密、完整性校验以及身份认证。<br>这一切都要从 TLS/SSL 协议说起，但在开始之前有必要先了解一些相关的基础知识：</p><h2 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h2><ul><li>对称加密 (Symmetric cryptography)，发送方与接收方使用相同的密钥加密与解密，这也是其最大的弱点，意味着双方在能加密通信前需要传送密钥；</li><li>非对称加密 (也称为公钥加密，Asymmetric cryptography/Public-key cryptography)，旨在解决对称加密必须传送密钥的缺陷。1976年， Whitfield Diffie 与 Martin Hellman 提出在不交换密钥的情况下完成加解密的构想，即 Diffie–Hellman key exchange。1977年，数学家 Rivest、Shamir 以及 Adleman 受 Diffie–Hellman key exchange 的启发，设计出一种非对称加密算法，称之为 RSA 算法，其思想是通信中的一方生成一对密钥：公钥、私钥，公钥分开发布，任何人都可以获取，私钥则是密保的。公钥加密的信息只有私钥能解密，私钥加密的信息也只有其对应的公钥可以解密。</li></ul><p>其中，<a href="https://commons.wikimedia.org/wiki/File:Diffie-Hellman_Key_Exchange_" target="_blank" rel="noopener">Diffie-Hellman Key Exchange在原理大致如下</a>：<img src="/img/Diffie-Hellman_Key_Exchange.png" alt="">更多信息可以参考<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="noopener">Diffie–Hellman key exchange</a>。</p><h2 id="数字签名-Digital-Signature"><a href="#数字签名-Digital-Signature" class="headerlink" title="数字签名 (Digital Signature)"></a>数字签名 (Digital Signature)</h2><p>顾名思义，签名主要就是防伪，数字签名主要用于认证消息的发送者 (发送者无法抵赖)、消息完整性校验。</p><blockquote><p>A digital signature is a mathematical scheme for demonstrating the authenticity of a digital message or documents. A valid digital signature gives a recipient reason to believe that the message was created by a known sender, that the sender cannot deny having sent the message (authentication and non-repudiation), and that the message was not altered in transit (integrity).</p></blockquote><p><img src="/img/DigitalSignature.png" alt=""><br>从<a href="https://upload.wikimedia.org/wikipedia/commons/2/2b/Digital_Signature_diagram.svg" target="_blank" rel="noopener">上图</a>可以看出，数字签名就是将要发送的数据通过 hash 函数计算消息摘要，再通过发送者私钥对摘要加密，最后附加在数据后面一起发送。<br>接收者，在收到消息后通过发送者公钥解密其中的签名，并同样通过 hash 函数计算消息摘要，若两者一致说明消息没有被篡改(完整性)，同时也能证明消息的确来自发送者。其中的关键有两点：</p><ul><li>计算消息摘要的 hash 函数：对输入敏感且不可逆；</li><li>非对称加密：一个公钥解一个私钥，通过发送者发布的公钥能解开的加密信息一定是通过发送者配对的私钥加密的。</li></ul><h2 id="数字证书-Digital-Certificate"><a href="#数字证书-Digital-Certificate" class="headerlink" title="数字证书 (Digital Certificate)"></a>数字证书 (Digital Certificate)</h2><p>仅仅通过非对称加密能实现身份认证吗？<br>我们知道，在非对称加密中，接收方仅仅掌握了所谓来自发送方的公钥，而公钥是不包含任何身份信息的。<br><img src="/img/MiddlemanAttack.jpg" alt=""><br>如上图所示中间人攻击，攻击者可以劫持发送者公钥，将自己的公钥发送给接收者，此时其完全可以冒充发送者与接收者通信，而接收者毫无察觉。<br>此时，数字证书应运而生：<img src="/img/digitalcertificatestructure.jpg" alt=""><br>上图是 X.509 定义的 v3 版数字证书结构，证书本身包含的重要信息有：证书持有者以及公钥、证书签发者、过期时间等。当然，最后还要附上签发者的数字签名，其中，数字签名用于判断证书的真伪。<br>从上面我们知道，数字签名需要使用签发者公钥解密，那么如何获得证书签发者的公钥以便验证证书的真伪？如何判断获得的签发者公钥没被篡改？<br>额，似乎要进入死循环了…</p><p>此时，CA (Certificate Authority，证书授权中心) 应运而生，其作为第三方权威可信机构，承担 PKI 中公钥合法性校验的职责，并签发认证证书以及对证书的维护管理等。</p><blockquote><p>A public key infrastructure (PKI) is a set of roles, policies, and procedures needed to create, manage, distribute, use, store, and revoke digital certificates[1] and manage public-key encryption.</p></blockquote><p><img src="/img/CA.jpg" alt=""><br>上图为证书从 CA 到服务器，再到客户端的大致流程：</p><ul><li>服务器向 CA 提出证书申请 (需要提供公钥、域名、申请人信息等)；</li><li>CA 对提出的申请进行核审；</li><li>核审通过后向申请者签发证书 (证书除了包含申请人公钥、域名等信息，还有证书过期时间，最重要的是 CA 的签名)；</li><li>客户端连接服务器时，服务器下发证书；</li><li>客户端验证证书，若验证通过则进行后续连接操作 (如：协商通信密钥等)。</li></ul><p>再回到前面的问题『如何获得证书签发者的公钥以便验证证书的真伪？如何判断获得的签发者公钥没被篡改？』<br>由于 CA 是公认的权威机构，系统或浏览器会内置其自签名的证书 (根证书)。</p><h2 id="证书链-Certificate-chains"><a href="#证书链-Certificate-chains" class="headerlink" title="证书链 (Certificate chains)"></a>证书链 (Certificate chains)</h2><p>由于证书的需求量巨大，为了减少一级 CA 的工作量，出现了二级、三级、… CA 机构，其签发出来的证书也就构成了一个证书链。<br><img src="/img/CertificateChain.jpg" alt=""><br>如<a href="https://docs.oracle.com/cd/E19693-01/819-0997/gdzen/index.html" target="_blank" rel="noopener">上图</a>所示，所有 CA 机构组成一个树状结构。<br><img src="/img/VerifyingACertificateChain.jpg" alt=""><br>证书的校验逆证书链而上，直到找到系统信任的证书。<br><img src="/img/googleCertificateChain.jpg" alt=""><br>上图是 google.com.hk 的证书链，可以看到 *google.com.hk 的证书是由二级 CA: Google Internet Authority G2签发，而该二级 CA 的证书则由根 CA: GeoTrust Global CA 签发，从而构成一个可信任的证书链。</p><p>好了，下面该回到正题了。</p><h2 id="TLS-SSL-协议"><a href="#TLS-SSL-协议" class="headerlink" title="TLS/SSL 协议"></a>TLS/SSL 协议</h2><hr><p>我们已经知道，在 HTTPS 协议栈中，TLS/SSL 处于 HTTP 与 TCP 之间。进一步细分的话，TLS 分为2层5条协议：<img src="/img/TLSprotocolstack.jpg" alt=""></p><p>其中，TLS Record Protocol 用于处理传输的数据，其主要职责是将上层协议下发的数据分块 (一块最大2^14 = 16384 bytes)、压缩、添加 MAC、加密等 (对于从底层协议上行的数据，其操作正好相反：解密、校验、解压、重组)。<br><img src="/img/RecordProtocoloperation.jpg" alt=""></p><h3 id="TLS-SSL-Handshake"><a href="#TLS-SSL-Handshake" class="headerlink" title="TLS/SSL Handshake"></a>TLS/SSL Handshake</h3><hr><p>TCP 为了建立可靠连接需要三次握手，TLS 为了实现加密、校验、身份认证同样需要握手 (握手，简单讲就是通信双方协商在后续通信过程中需要使用的信息)。</p><p>整个握手过程双方大概要确认以下几点：</p><ul><li>双方通信使用的 TLS 版本；</li><li>交换双方用于生成对称加密密钥的参数；</li><li>确认双方使用的加密算法、压缩算法；</li><li>完成身份认证。</li></ul><p>我们知道，身份认证时的数字签名采用的是非对称加密。出于效率考虑，在 TLS 链接建立后，双方通信时采用的是对称加密。因此，TLS 握手需要确定对称加密密钥 (Master Secret)。目前有两种方法计算 Master Secret：RSA 以及 Diffie-Hellman，因此，TLS Handshake 分为 RSA Handshake、Diffie-Hellman 握手。</p><h3 id="RSA-Handshake"><a href="#RSA-Handshake" class="headerlink" title="RSA Handshake"></a>RSA Handshake</h3><p><img src="/img/RSAHandshake.jpg" alt=""><br>上图是 RSA Handshake 的基本流程：</p><ul><li>Client Hello：客户端首先发起 TLS 握手，告诉服务端其支持的最高 TLS 版本、加密套件列表 (cipher suites)、压缩方法并产生随机数 Random_C；</li><li>Server Hello：服务端根据客户端支持的最大 TLS 版本决定此次通信使用的 TLS 版本、从客户端加密套件列表中选择一种加密套件以及压缩方法、生成随机数 Random_S 并将 Session Id 一起传给客户端；</li><li>Server Certificate：服务端将证书传给客户端以便认证其身份；</li><li>Server Hello Done：告知客户端服务端已完成握手相关的所有数据的传送；</li><li>客户端校验 Server Certificate；</li><li>Client Key Exchange：客户端生成随机密钥 PreMaster Secret，并用服务端公钥加密后发送给服务端；</li><li>Client change_cipher_spec：通知服务端后续消息将加密；</li><li>Client Finished：第一条加密的消息，表示握手完成；</li><li>服务端接收到加密的 PreMaster Secret后，用私钥解密，此时双方都掌握了计算 Master Secret 的所有信息 (Random_C、Random_S、PreMaster Secret)，双方分别计算 Master Secret；</li><li>Server change_cipher_spec：通知客户端后续通信会加密；</li><li>Server Finished：握手完成。</li></ul><h3 id="Diffie-Hellman-Handshake"><a href="#Diffie-Hellman-Handshake" class="headerlink" title="Diffie-Hellman Handshake"></a>Diffie-Hellman Handshake</h3><p>新技术的出现往往是原有技术存在不足或缺陷，那么 RSA Handshake 存在什么问题？<br>在 RSA 中，身份认证以及对 PreMaster Secret 加密使用的是同一对 public-private key，如果攻击者截获了服务器的私钥并窃听了整个握手过程，那么其可以顺利的破解整个通信消息。更严重的是，整个通信过程对称加密密钥是固定不变的，所以即使当前攻击者没有掌握服务端私钥，其可以将整个通信过程记录下来，等其获取到服务端私钥后，再进行破解。</p><p>而在 Diffie-Hellman Handshake 过程中，双方不需要在握手过程中传递类似 PreMaster Secret 的信息，更可喜的是，通过 Diffie-Hellman key exchange 可以生成新的对称密钥，废弃老的密钥，也就是在通信过程中对称密钥不固定，可以随时更换。</p><p>在握手流程上与 RSA Handshake 相比，Diffie-Hellman Handshake 双方都要交换 Diffie–Hellman 参数：<br><img src="/img/Diffie-HellmanHandshake.jpg" alt=""></p><p>下面我们使用 Safari 访问 『<a href="https://www.google.com.hk』，并通过" target="_blank" rel="noopener">https://www.google.com.hk』，并通过</a> Wireshark 抓包来了解一下其中 TSL 握手的过程：<br>1、Client Hello<img src="/img/ClientHello.jpg" alt=""><br>可以看到在 Client Hello 中包含了：TLS Version (客户端支持的最高版本 TLS 1.2)、Random、Cipher Suites (37套)、 Compression Methods (null，表示不压缩)。</p><p>2、Server Hello<img src="/img/ServerHello.jpg" alt=""><br>可以看到在 Server Hello 中包含了：TLS Version (确定双方通信使用 TLS 1.2)、Random、Session ID、Cipher Suite 选择了 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA、不加密 (Compression Method 为 null)。<br>其中，TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 的含义如下：</p><ul><li>TLS 自然表示是 TLS 协议；</li><li>ECDHE 表示使用 Elliptic Curve Diffie-Hellman Ephemeral 方式生成对称加密密钥 (Master Secret)；</li><li>RSA 表示数字签名使用非对称加密 RSA；</li><li>AES_128_CBC 表示对称加密使用 128 bit 的 AES 方式；</li><li>SHA 表示使用安全哈希算法 (Secure Hash Algorithm) 计算摘要。</li></ul><p>3、Server Certificate<img src="/img/ServerCertificate.jpg" alt=""><br>4、Server Key Exchange<img src="/img/ServerKeyChange.jpg" alt=""><br>5、Server Hello Done<img src="/img/ServerHelloDone.jpg" alt=""><br>Server Hello Done 表示服务端已发送完所有握手相关的数据。<br>6、Client Key Exchange<img src="/img/ClientKeyExchange.jpg" alt=""><br>7、Client Change_Cipher_Spec<img src="/img/ClientChangeCipherSpec.jpg" alt=""><br>Change_Cipher_Spec 表示通知对方后续通信将加密 (此时 Master Secret 已计算出来)<br>8、Client Finished (Encrypted Handshke Message)<img src="/img/TLSHandshakeFinished.jpg" alt=""><br>紧接着 Change_Cipher_Spec，会发送一条 Finished 消息，用于验证之前的 key exchange 以及身份认证是否成功。Finished 消息是 TLS 链接建立后的第一条使用握手过程协商的加密算法、密钥加密的消息。Finished 消息的内容是整个握手过程中接收到的数据，对方在接收到 Finished 消息后需要对其解密并验证消息内容是否正确。<br>9、Server Change_Cipher_Spec<br>10、Server Finished<br>服务端同样需要发送 Change_Cipher_Spec、Finished 消息。<br>至此，若所有步骤都正确无误，则 TLS 握手过程顺利完成！后续所有消息都将通过对称加密的方式发送。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>再来看 HTTPS 的三个主要任务：</p><ul><li>加密：通过握手过程协商的加密算法、密钥对消息加密；</li><li>完整性校验：通过 MAC 实现；</li><li>身份认证：通过数字证书完成。</li></ul><p>以上就是 HTTPS 相关的一些知识。</p><h1 id="未尽事宜"><a href="#未尽事宜" class="headerlink" title="未尽事宜"></a>未尽事宜</h1><ul><li>证书管理：证书可能会被 CA 吊销、失效等，终端可以通过 CRL (Certificate Revocation List) 或 OCSP (Online Certificate Status Protocol) 等机制查询证书的状态；<br>在证书中会包含 CRL、OCSP 相关的信息：<img src="/img/CRLOCSP.jpg" alt=""></li><li>session 复用：从上述介绍我们可以知道，建立 TLS 链接是十分耗时的，可以通过 session id 以及 session ticket 机制实现链接复用。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hpbn.co/transport-layer-security-tls/" target="_blank" rel="noopener">Transport Layer Security (TLS)</a><br><a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">The Transport Layer Security (TLS) Protocol Version 1.2</a><br><a href="https://tools.ietf.org/html/rfc5280" target="_blank" rel="noopener">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a><br><a href="http://www.uniroma2.it/didattica/iss/deposito/4_tls.pdf" target="_blank" rel="noopener">Transport Layer Security (secure Socket Layer)</a><br><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener">Keyless SSL: The Nitty Gritty Technical Details</a><br><a href="https://docs.oracle.com/cd/E19693-01/819-0997/gdzen/index.html" target="_blank" rel="noopener">Certificates and Certificate Authorities (CA)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从问题入手，简单分析了 HTTPS 中 TLS 握手过程以及简单介绍了数字签名、数字证书、对称加密、非对称加密等知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="NetWorking" scheme="http://zxfcumtcs.github.io/tags/NetWorking/"/>
    
  </entry>
  
  <entry>
    <title>不谈框架，谈细节</title>
    <link href="http://zxfcumtcs.github.io/2016/07/20/MobileArchitecture/"/>
    <id>http://zxfcumtcs.github.io/2016/07/20/MobileArchitecture/</id>
    <published>2016-07-20T14:03:26.000Z</published>
    <updated>2018-12-08T08:41:32.858Z</updated>
    
    <content type="html"><![CDATA[<p>本文从细节入手，尝试分析了几种常见的移动框架：MVC、MVCS、MVP、MVVM。对于在实际开发中如何选择框架给出了一些参考意见。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>移动开发框架，无论是 iOS、Andriod 还是 Web 都属于 GUI (Graphical User Interfaces) 框架范畴。2006年，Martin Fowler 的 <a href="http://martinfowler.com/eaaDev/uiArchs.html" target="_blank" rel="noopener">GUI Architectures</a> 一文可谓是经典之作。文中，Martin Fowler 提到 MVC 模式如何组织代码、划分模块职责，还提到 <a href="http://martinfowler.com/eaaDev/DataBinding.html" target="_blank" rel="noopener">Data Binding</a>、<a href="http://martinfowler.com/eaaDev/FlowSynchronization.html" target="_blank" rel="noopener">Flow Synchronization</a> 以及 <a href="http://www.martinfowler.com/eaaDev/MediatedSynchronization.html" target="_blank" rel="noopener">Observer Synchronization</a> 等核心概念。<br>纵观十年来 GUI 框架演变，无论是 MVCS、MVP 还是 MVVM，其实讨论的核心问题还是如何分层、如何划分模块职责、做好代码隔离。</p><p>谈到 iOS 上常见框架，相信只要有半年以上开发经验的同学都能侃侃而谈。但在实际交流过程中发现不少同学对关键细节问题却认知模糊，甚至是错误的。因此，本文尝试从细节入手对几种常见框架进行简单描述(对框架的认识智者见智、仁者见仁，我所描述的也不一定是正确的)。</p><h1 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h1><hr><p>上文提到各种框架虽各种不同，但它们其实都是在讨论一个问题：『如何分层』。<br>那么在继续之前，我们有必要思考一下：<strong><em>为什么要分层？</em></strong></p><p>计算机界有一句大道至简的名言：</p><blockquote><p>All problems in computer science can be solved by another level of indirection.</p></blockquote><p>之所以要分层，最终目的是降低系统整体复杂度。<br>通过分层我们至少能获得以下能力：</p><ul><li>提供良好的抽象，隐藏实现细节，降低耦合度；</li><li>隔离变化；</li><li>提高模块可复用性；</li><li>增强系统可扩展性。</li></ul><p>说到分层，可能最先想到的例子是 OSI 七层或 TCP/IP 五层网络模型：<img src="/img/OSI.jpg" alt=""><br>在分层网络模型中，不同协议工作在不同网络层，互不干扰，又协调有致，如：IP 协议工作在网络层，主要职责是网络寻址；TCP 协议工作在传输层，主要负责建立可靠的网络连接、负责拥塞控制等。正是因为良好的分层，IP 协议无需关心 TCP 协议的工作，反之亦然。同时 IP 协议也可以在 TCP、UDP 协议间复用。</p><p>如今对网络安全越来越重视，HTTPS 协议也慢慢普及，通过分层，只需在原有 HTTP 协议基础上添加一个 TLS/SSL 的安全传输层即可，由它来负责加解密，而原有的 HTTP、TCP 协议无需修改：<img src="/img/HTTPHTTPS.png" alt=""></p><h1 id="Model-View-Controller"><a href="#Model-View-Controller" class="headerlink" title="Model-View-Controller"></a>Model-View-Controller</h1><hr><p>MVC(Model-View-Controller)作为最经典的框架，广为人熟知，也是 Apple 官方推荐的移动框架。<img src="/img/MVC-Apple.jpg" alt=""><br>MVC模式的核心思想是数据层(Domain)与表现层(Presentation)的隔离。</p><blockquote><p><a href="http://www.martinfowler.com/eaaDev/uiArchs.html" target="_blank" rel="noopener">Separated Presentation:</a><br>Ensure that any code that manipulates presentation only manipulates presentation, pushing all domain and data source logic into clearly separated areas of the program.</p></blockquote><p><img src="/img/DomainPresentation.png" alt=""><br>那么，在数据与展现被隔离之后，它们之间如何同步数据、状态？<br>这就涉及 MVC 模式另一个重要思想：观察者同步(Observer Synchronization)。</p><blockquote><p><a href="http://www.martinfowler.com/eaaDev/MediatedSynchronization.html" target="_blank" rel="noopener">Observer Synchronization:</a><br>Synchronize multiple screens by having them all be observers to a shared area of domain data.</p></blockquote><p>常用方法：在Presentation Object(Controller)中注册通知、设置delegate、传递block等。当数据需要更新时，Domain Object(Model)通过上述方式将数据自底向上的同步给Presentation Object。</p><p>下面简单介绍一下 Model、View、Controller：</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><hr><p>Apple: Model Objects Encapsulate Data and Basic Behaviors.<br>Stanford: Model = What your application is (but not how it is displayed).<br>简单讲：Model = Data + Manipulate Data</p><p>(ps:本文中的Stanford表示斯坦福的 iOS 公开课)<br><img src="/img/QRBookShelfModel.png" alt=""><br>如：我们书架的 Model：<code>QRBookShelfModel</code>，包含了数据：<code>NSArray&lt;QRBookShelfItem *&gt; *books</code>以及对数据的操作：<code>addBook:</code>、<code>deleteBook:</code>等。</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><hr><p>Apple: Controller Objects Tie the Model to the View.<br>Stanford: Controller = How your Model is presented to the user(UI logic).</p><p>Controller 是 Model 与 View 间的连接器，其核心职责有：</p><ul><li>处理用户事件；</li><li>处理展示逻辑；</li><li>连接 Model 与 View。</li></ul><p>这里有个问题：到底什么是展示逻辑？<br>简单讲：将业务数据转换成UI数据，如：</p><ul><li>下载进度，从 Model 层返回的是 double 型，将其转换成可展示的 string 类型(0.811—&gt;81.1%)；</li><li>性别，从 Model 返回的是0、1这样的 int 型，将其转换成：1-&gt;男，0—&gt;女；</li><li>日期，将时间戳格式化：123456789923—&gt;2016-07-01 10:09.</li></ul><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><hr><p>Apple: View Objects Present Information to the User<br>Stanford: View=Your Controller’s minions</p><p>总之，View 只做一件事：layout。</p><h2 id="MVC-规则"><a href="#MVC-规则" class="headerlink" title="MVC 规则"></a>MVC 规则</h2><hr><p>为了实现 MVC 的核心思想：业务 (model) 与展示 (View) 的隔离，必须严格遵守一些规则：</p><ul><li>Controller 依赖(持有) Model、View(可直接与它们通信)；</li><li>Model 与 View 互不可见(不可通信)；</li><li>View 只负责layout，且不能保存业务数据 (需要数据时通过 datasource 方式向 Controller 要)；</li><li>View 可通过 target、delegate 与 Controller 同步状态；</li><li>Model 不能主动与 Controller 通信，通过 Notification、KVO、delegate、block 等机制通知 Controller 数据变化。</li></ul><p>看到这里，大家有没有一种熟悉的味道？<br>没错，UITableView 与外界 (Contoller) 的交互与此处的描述高度一致。<br><img src="/img/MVC.jpg" alt=""></p><p>(关于 MVC 规则的描述，大家也可以参考 Stanford iOS 公开课中的相关内容)</p><h2 id="有问题吗？"><a href="#有问题吗？" class="headerlink" title="有问题吗？"></a>有问题吗？</h2><hr><p>此时，大家或许心中有些疑问：<br>1、在 MVC 模式中，网络请求、数据存储谁来完成？<br>2、Model、View、Controller 谁的可复用性最强？<br>3、展示逻辑为什么由 Controller 完成而不是 View？</p><ul><li><p>在 MVC 模式中，网络请求、数据存储谁来完成？<br>  Controller、Model 都可以，一般由 Model 完成。此时的 Model 已不再是简单的 Model Object，而是 Model layer，在我们项目中通常将其称为 Manager。</p></li><li><p>Model、View、Controller 谁的可复用性最强？<br>  View&gt;Model&gt;Controller</p></li><li><p>展示逻辑为什么由 Controller 完成而不是 View？<br>  View可复用性高，不应关心具体展示逻辑，只专注于 layout</p></li></ul><h2 id="Massive-View-Controller"><a href="#Massive-View-Controller" class="headerlink" title="Massive View Controller"></a>Massive View Controller</h2><hr><p>MVC 模式被批评最多的就是 Controller 过于臃肿，那么 Controller 都做了什么？</p><ul><li>处理复杂的展示逻辑；</li><li>处理用户事件；</li><li>初始化 View、管理部分 View 的生命周期并提供数据；</li><li>处理业务数据变化，转换为 UI 结果；</li><li>获取、存储数据(可选)。</li></ul><p>尤其是如今很多产品经理『擅长』做加法，页面、交互越来越复杂，这对于 Controller 来说无疑是雪上加霜。</p><h1 id="Model-View-Controller-Store"><a href="#Model-View-Controller-Store" class="headerlink" title="Model-View-Controller-Store"></a>Model-View-Controller-Store</h1><hr><p>前面提到，在 MVC 模式中，并没有讨论获取数据属于哪个模块的职责 (一般由 model 负责)。MVCS 模式就是在 MVC 基础上将数据单独提取为一层(Store)。<br><img src="/img/MVCS.png" alt=""></p><h1 id="Model-View-Presenter"><a href="#Model-View-Presenter" class="headerlink" title="Model-View-Presenter"></a>Model-View-Presenter</h1><hr><p>在 MVC 模式中，展示逻辑被划分为 Controller 的职责范围。如今，展示逻辑越来越复杂，Controller 随之也变得越来越臃肿。同时，Controller 也被认为是 View 的一部分，这样 Model 与 View 间并没有完全隔离、解耦。<br>MVP (Model-View-Presenter) 就是在这样的背景下产生的，其将展示逻辑提取为一个单独的层(Presenter)，简化了 Controller，也彻底隔离了 Model 与 View。<br><img src="/img/MVP.png" alt=""></p><p>新产生的 Presenter 层有以下特点：</p><ul><li>UI 无关 (在 Presenter 中不能包含 UIKit 相关头文件)；</li><li>处理展示逻辑；</li><li>Model 与 View 间的桥接者。</li></ul><h1 id="Model-View-View-Model"><a href="#Model-View-View-Model" class="headerlink" title="Model View View-Model"></a>Model View View-Model</h1><hr><p>最近两三年对 MVVM(Model View View-Model) 的讨论比较多，其提出的愿景也是为了简化 Controller、彻底将 View 与 Model 解耦、并提供 Data Binding。<br><img src="/img/MVCMVVM.jpg" alt=""><br>在 MVVM 中 Controller 被认为是 View，更准确的说是：<br><img src="/img/MVMCV.jpg" alt=""></p><h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><hr><p>在 MVVM 模式中，各模块间的依赖关系、数据流向、数据传递的格式都有严格的规定：<br><img src="/img/MVVMRules.jpg" alt=""><br>如上图所示，View、View Model 以及 Model 需要遵守以下规则：</p><ul><li><p>View(UIViewController/UIView):<br>  1.可以依赖(持有) View、View Model，即可直接调用其方法；<br>  2.不能依赖(持有) Model、Model Object(Item)；<br>  3.UI 绑定到View Model上(如：titleLabel.text-&gt;viewModel.title)<br>  4.通过 RACCommands/RACActions 或直接调用 View Model 的方法将用户事件传递给 View Model。</p></li><li><p>View Model:<br>  1.可以依赖(持有) View Model、Model 以及 Model Object；<br>  2.不能依赖(持有) View、Raw Model Object；<br>  3.其公开属性只能是基础数据类型(NSInteger、NSString等)或其他 View Model；<br>  4.将 Model Object 转换成可直接在 View 上显示的属性或Sub View Model(展示逻辑)；<br>  5.接受来自 View 或 Sub View Model 的输入(用户事件)。</p></li><li><p>Model (Layer)：<br>  1.可以依赖(持有) 其他 Model、Model Object、Data Source、Raw Model Object；<br>  2.不能依赖(持有) View Model、View；<br>  3.将 Raw Model Object 转换为 Model Object；<br>  4.为 View Model 提供数据(异步)。</p></li></ul><p>其中，View 与 View Model 类似 UIView 与 CALayer 的关系，一一对应(包括层次结构)：<br><img src="/img/ViewViewModel.jpg" alt=""></p><h2 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h2><hr><p><img src="/img/MVVMDataBinding.jpg" alt=""><br>从上图可知，在 MVVM 中数据流方向与依赖关系正好相反，数据流的流动就是建立在 Observer Synchronization 思想基础之上。</p><p>从 Data Source 到 Model、Model 到 View Model 可采用一般的同步方法，如：Delegate、Notification 以及 block 等。而从 ViewModel 到 View 的 Data Binding 是 MVVM 模式与其他 MV* 模式最大的区别。</p><p>遗憾的是 iOS 并没有原生的 Data Binding 方式，目前大概只能通过两种方式实现 Data Binding：KVO 或 ReactiveCocoa。KVO/RAC是一种更加激进的 Observer Synchronization：</p><ul><li>优势：绑定关系确定后，同步更加方便；</li><li>劣势：数据流不直观，调试较困难；</li></ul><h2 id="MVVM-VS-MVP"><a href="#MVVM-VS-MVP" class="headerlink" title="MVVM VS. MVP"></a>MVVM VS. MVP</h2><hr><p>MVVM 与 MVP 有很多相似的点：</p><ul><li>将展示逻辑从 Controller 中提取出来(分别放到 View Model 和 Presenter 中)；</li><li>分别在 View Model、Presenter 中响应用户事件；</li><li>分别通过 View Model、Presenter 连接 View 与 Model；</li><li>解耦 View 与 Model。</li></ul><p>两者最大的区别在于：MVVM 有 Data Binding 而 MVP 没有。</p><h1 id="华山论剑——MV-VS-MVVM"><a href="#华山论剑——MV-VS-MVVM" class="headerlink" title="华山论剑——MV* VS. MVVM"></a>华山论剑——MV* VS. MVVM</h1><hr><p>根据是否有 Data Binding，可将常见 GUI 框架分为两大阵营：</p><ul><li>有 Data Binding：MVVM；</li><li>没有 Data Binding：MVC、MVP、MVCS 等。</li></ul><p>MVVM 的 Data Binding 在一定程度上增加了编码的复杂度、数据流也变得不够直观、调试难度也有所增加。但对于数据可变的场景，一旦通过 Data Binding 将 View 与 View Model 绑定起来，在数据变化时，会自动映射到 UI 上，十分方便。</p><p>根据展示逻辑是否独立于 Controller，可分为：</p><ul><li>独立：MVVM、MVP</li><li>不独立：MVC、MVCS</li></ul><p>MVVM、MVP 分别将展示逻辑从 Controller 中提取出来，使 Controller 得到一定程度的简化，在展示逻辑复杂的情况下，效果更加明显。</p><h2 id="没有好坏，只有适合"><a href="#没有好坏，只有适合" class="headerlink" title="没有好坏，只有适合"></a>没有好坏，只有适合</h2><hr><p>通过上述分析，我们可以看到，常见几种框架：MVC、MVCS、MVP、MVVM 并没有绝对的好坏之分，只是各有不同的适用场景。<br>我们在选择时可以根据以下两点作为参考依据：</p><ul><li>数据是否可变(UI是动态还是静态)<br>  静态：MV*<br>  动态：MVVM</li><li>展示逻辑是否复杂<br>  复杂：MVVM、MVP</li></ul><h2 id="万变不离其宗——MVC是根"><a href="#万变不离其宗——MVC是根" class="headerlink" title="万变不离其宗——MVC是根"></a>万变不离其宗——MVC是根</h2><hr><p>MVCS、MVP、MVVM 等各种新生框架，虽各有不同，但都是源自于 MVC，它们的核心思想一直没变，也不能变：</p><ul><li>Separated Presentation;</li><li>Observer Synchronization.</li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><hr><p>理论的东西讲了不少，下面结合实际的项目，看看应该如何选择框架。</p><h2 id="书籍详情页"><a href="#书籍详情页" class="headerlink" title="书籍详情页"></a>书籍详情页</h2><hr><p>书籍详情页在整个 QQ 阅读 app 中，无论是展示还是业务逻辑都是最复杂的一个模块。<br><img src="/img/DetailPage.jpg" alt=""></p><ul><li>在书籍下载过程中下载按钮需要显示下载状态(进度)——动态 UI；</li><li>评分、作者分类、包月相关提示、打赏、粉丝榜等展示逻辑十分复杂。</li></ul><p>因此，该模块采用 MVVM 框架比较合适。遗憾的是，当时设计该模块时没有充分意识到其复杂程序，而是选择了传统的 MVC 框架。结果造成详情页 Controller 十分复杂，下面这段就是 Controller 中根据下载状态修改 toolbar 上3个按钮状态的代码(ps：看不清没关系，只要能看出其很复杂即可^_^)：<br><img src="/img/DetailPageChangeBookInfo.jpg" alt=""><br>同时，大量的展示逻辑也耦合在了各个 View 中：<br><img src="/img/BookDetailHeaderView.jpg" alt=""><br>如果，采用 MVVM 框架，各种展示逻辑可以放到相应的 View Model 中，让 View 只专注于 layout。同时在 View Model 中处理下载相关逻辑，使下载逻辑与 View 解耦。</p><h2 id="信息流"><a href="#信息流" class="headerlink" title="信息流"></a>信息流</h2><hr><p>信息流作为 QQ 阅读一大亮点，能为用户个性化推荐书籍，是整个 app 中最重要的一个页面：<br><img src="/img/FeedFlow.jpg" alt=""><br>信息流是最重要的页面，但不是最复杂的页面：</p><ul><li>信息流的数据是静态的，在显示过程中不会改变——静态UI；</li><li>展示逻辑相对简单。</li></ul><p>因此，信息流模块没必要使用复杂的 MVVM 框架。<br><strong><em>很多场景属于此类情形：通过 UITableView 列举多行静态数据，若数据有更新时直接 reload tableview。</em></strong></p><h1 id="无剑胜有剑-皆可为剑"><a href="#无剑胜有剑-皆可为剑" class="headerlink" title="无剑胜有剑 皆可为剑"></a>无剑胜有剑 皆可为剑</h1><hr><p>各种分层框架都是前辈充满智慧的宝贵经验，值得尊敬、借鉴、学习，但也不必拘泥于形式，重点是理解其背后的思想。设计模式有六大原则：</p><ul><li>单一职责原则</li><li>里氏代换原则</li><li>依赖倒转原则</li><li>接口隔离原则</li><li>迪米特法则</li><li>开放-封闭原则</li></ul><p>其中除了里氏代换原则，其他五大原则都是分层框架的指导思想。只要我们深刻理解并能严格遵守这些原则，无论我们选择哪种框架、或在其基础上进行衍化，都能设计出高质量的代码。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>代码设计、框架选择及理解仁者见仁、智者见智，但经典的设计理念是公认的、也是经过时间检验的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://martinfowler.com/eaaDev/uiArchs.html" target="_blank" rel="noopener">GUI Architectures</a><br><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" target="_blank" rel="noopener">Model-View-Controller</a><br><a href="https://www.objc.io/issues/13-architecture/mvvm/" target="_blank" rel="noopener">Introduction to MVVM</a><br><a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/" target="_blank" rel="noopener">Lighter View Controllers</a><br><a href="http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/" target="_blank" rel="noopener">ReactiveCocoa and MVVM, an Introduction</a><br><a href="http://twocentstudios.com/2014/06/08/on-mvvm-and-architecture-questions/" target="_blank" rel="noopener">On MVVM, and Architecture Questions</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从细节入手，尝试分析了几种常见的移动框架：MVC、MVCS、MVP、MVVM。对于在实际开发中如何选择框架给出了一些参考意见。&lt;br&gt;
    
    </summary>
    
    
      <category term="构架" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%84%E6%9E%B6/"/>
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>NSURLSession 拾遗</title>
    <link href="http://zxfcumtcs.github.io/2016/06/09/NSURLSession_Supplements/"/>
    <id>http://zxfcumtcs.github.io/2016/06/09/NSURLSession_Supplements/</id>
    <published>2016-06-09T09:51:28.000Z</published>
    <updated>2018-12-08T08:41:32.859Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了实际开发过程中在 NSURLSession 上遇到的各种问题。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>NSURLSession 是 Apple 在 iOS7 推出的一套网络组件库，用于取代 NSURLConnection(在 iOS9 中已被废弃)。</p><blockquote><p>本文并不是 NSURLSession 的科普文章(这类文章网上已有很多，也可以参考之前的文章：<a href="http://zxfcumtcs.github.io/2014/08/02/NSUrlSession/">NSURLSession—网络框架新生代</a>)。</p></blockquote><p>最近在项目中对下载模块做了一次重构，其中用到 NSURLSession，期间遇到了一些有趣的问题，故小结一下。</p><h1 id="网络错误"><a href="#网络错误" class="headerlink" title="网络错误"></a>网络错误</h1><hr><p>在调试过程中发现，当断开网络时并没有收到回调：<code>URLSession:task:didCompleteWithError:</code>。<br>原来，从 iOS8 开始对于<code>background mode</code>的 NSURLSession，当无法连接服务器时，NSURLSession 并不会调用<code>URLSession:task:didCompleteWithError:</code>，而是让上传、下载任务处于空闲等待状态，当网络恢复后，NSURLSession 自动恢复之前的任务。</p><p>iOS7 上若无法连接服务器会立即调用上述回调方法并返回错误：<br>Error Domain=NSURLErrorDomain Code=-1009 “The Internet connection appears to be offline.”</p><h1 id="timeoutIntervalForResource"><a href="#timeoutIntervalForResource" class="headerlink" title="timeoutIntervalForResource"></a>timeoutIntervalForResource</h1><hr><p>上小节了解到当无法连接服务器时，NSURLSession 并不会将这类问题反馈给业务层，但有时业务层可能需要了解这一事实，从而在 UI 上给出相应的提示。此时可以通过 NSURLSessionConfigure 的<code>timeoutIntervalForResource</code>属性设置一个超时时间。</p><p>在此，需要区分清楚 NSURLSessionConfigure 的两个属性<code>timeoutIntervalForResource</code>与<code>timeoutIntervalForRequest</code>的区别：</p><ul><li>timeoutIntervalForResource：整个任务(上传或下载)完成的最长时间，默认值为1周；</li><li>timeoutIntervalForRequest：两个数据包之间的最大时间间隔；</li></ul><p>timeoutIntervalForResource指整个任务完成的最大时间，简单讲就是 NSURLSession 里面所有 task 完成的总时间(包括因控制最大并发数而排队等待的时间)。</p><h1 id="自动重试"><a href="#自动重试" class="headerlink" title="自动重试"></a>自动重试</h1><hr><p>在调试过程中还发现一个有趣的问题，当把网络调成弱网时：<br><img src="/img/downloadTask-didWriteData-totalBytesWritten-totalBytesExpectedToWrite.png" alt=""><br>上图是在 <code>URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:</code> 中打印的 log，理论上totalBytesWritten应该是递增的，但从上图可以看到出现了断裂，从168640降到了3906，而3906恰是本次接收的字节数(bytesWritten)。<br>这点说明 NSURLSession 在弱网络下出现失败时会自动重试。</p><p>那么，这点对我们有何影响呢？</p><ul><li>业务层基本上不需要再进行重试操作了(以前我们经常会在失败时进行多次重试)；</li><li>如果需要显示进度，需要作特殊处理，不然可能会出现抖动。</li></ul><h1 id="background-mode"><a href="#background-mode" class="headerlink" title="background mode"></a>background mode</h1><hr><p>background 模式下的 NSURLSession 可以在后台执行相应的任务，此时 app 可能处于 background、suspended 或 terminated 状态。当 app 处于 suspended 或 terminated 状态时是不能执行任何代码的，那么下载任务是如何执行的呢？<br>对于 background mode NSURLSession，所有的上传、下载任务都会交由系统在一个独立的进程中执行。<br>通过 instruments 可以看到这个进程：<br>有下载任务时：<img src="/img/NSURLSessionProcess.png" alt=""><br>处于空闲状态时：<img src="/img/NSURLSessionProcess1.png" alt=""></p><p><em>ps：如果用户在任务中心强制将 app kill 掉，所有 background task 都会被 cancel。</em></p><h1 id="identifier"><a href="#identifier" class="headerlink" title="identifier"></a>identifier</h1><hr><p>在创建 background 模式的 NSURLSession 时需要提供一个唯一的<code>identifier</code>，<strong><em>这里的『唯一』不仅仅是在 app 内部，而是在整个系统中都要求是唯一的(因为所有的 background session 都是在同一个进程中处理)。</em></strong>因此，可以将bundle ID拼接到identifier中。</p><p>同时，需要将正在执行中的 session identifier存储起来，当 app crash、suspended 或 terminated 后可以通过存储的 identifier 恢复尚未完成的 sesssion。</p><h1 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a>delegate</h1><hr><p>NSURLSession 会对 delegate 保持强引用，因此像 NSTimer 一样，在任务完成时需要调用 <code>invalidateAndCancel</code> 或 <code>finishTasksAndInvalidate</code> 方法，否则会出现内存泄漏。</p><h1 id="deep-copy-NSURLSessionConfigure"><a href="#deep-copy-NSURLSessionConfigure" class="headerlink" title="deep copy NSURLSessionConfigure"></a>deep copy NSURLSessionConfigure</h1><hr><p>在创建 NSURLSession 时，会对 NSURLSessionConfigure 进行深拷贝，也就是在创建 NSURLSession 后再对 configure 进行修改不会影响之前创建的 session。</p><h1 id="URLSession-downloadTask-didFinishDownloadingToURL"><a href="#URLSession-downloadTask-didFinishDownloadingToURL" class="headerlink" title="URLSession:downloadTask:didFinishDownloadingToURL:"></a>URLSession:downloadTask:didFinishDownloadingToURL:</h1><hr><p>在下载任务完成后，NSURLSession 会回调该方法，在该方法返回前需要将下载文件(保存在<code>location</code>参数指定的位置)读取到内存或拷贝到其他地方，在该方法返回后系统会自动删除<code>location</code>处的下载文件。</p><h1 id="application-handleEventsForBackgroundURLSession-completionHandler"><a href="#application-handleEventsForBackgroundURLSession-completionHandler" class="headerlink" title="application:handleEventsForBackgroundURLSession:completionHandler:"></a>application:handleEventsForBackgroundURLSession:completionHandler:</h1><hr><p>当 app 处于 suspended 或 terminated 状态，若此时有 background session 完成任务或需要鉴权，系统会调用该方法。通过该方法系统会传递一个 block 类型的 <code>completionHandler</code>过来，在我们处理完 session 相关的任务后，需要执行该 block，在执行完该 block 后，系统大概在5秒后再次被挂起。</p><h1 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h1><hr><p>当 cacel 正在执行中的 session task 时，NSURLSession 会回调 <code>URLSession:task:didCompleteWithError:</code> 方法，并返回错误信息：<br>Error Domain=NSURLErrorDomain Code=-999 “cancelled”</p><h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><hr><p>在 NSURLSession 带来的诸多利好中还有一个就是在 iOS9 上自动支持 HTTP/2，无需使用方额外做任何事情。<br>HTTP/2 与 HTTP/1.1、HTTP/1.0相比，特大的特点就是『快』。<br><a href="https://medium.com/apps-and-networking/http-2-makes-media-loading-3-15-times-faster-on-mobile-a455c3e68135#.1ptt4gx4s" target="_blank" rel="noopener">HTTP/2 makes media loading 3–15 times faster on mobile</a> 这篇文章对 HTTP/2 与 HTTP/1.1 在速度上做了对比：<br><img src="/img/http2vs1wifi.jpg" alt=""><br><img src="/img/http2vs13g.png" alt=""></p><p>HTTP/2 与 HTTP/1.1相比主要区别有：</p><ul><li>每个 Host 只需一个 TCP connection；</li><li>连接多路复用(HTTP/1.0 中一个连接一次只能有一个请求、HTTP/1.1 中一个连接同时可以有多个请求，但一次只能有一个响应，HTTP/2则完全是多路复用的)；</li><li>request 可以设置优先级；</li><li>二进制协议(HTTP：超文本传输协议，以前是文本协议)；</li><li>头部压缩；</li><li>服务器可以主动 push。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="noopener">URL Session Programming Guide</a><br><a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/" target="_blank" rel="noopener">NSURLSession Class Reference</a><br><a href="http://stackoverflow.com/questions/23288780/nsurlsessiontask-never-calls-back-after-timeout-when-using-background-configurat" target="_blank" rel="noopener">NSURLSessionTask never calls back after timeout when using background configuration</a></p><p><a href="https://http2.github.io/faq/" target="_blank" rel="noopener">HTTP/2 Frequently Asked Questions</a><br><a href="https://medium.com/apps-and-networking/http-2-makes-media-loading-3-15-times-faster-on-mobile-a455c3e68135#.1ptt4gx4s" target="_blank" rel="noopener">HTTP/2 makes media loading 3–15 times faster on mobile</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了实际开发过程中在 NSURLSession 上遇到的各种问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="NetWorking" scheme="http://zxfcumtcs.github.io/tags/NetWorking/"/>
    
  </entry>
  
  <entry>
    <title>细说 NSOperation</title>
    <link href="http://zxfcumtcs.github.io/2016/05/17/NSOperation/"/>
    <id>http://zxfcumtcs.github.io/2016/05/17/NSOperation/</id>
    <published>2016-05-17T15:25:12.000Z</published>
    <updated>2018-12-08T08:41:32.859Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细介绍了在实现同步、异步 NSOperation 时分别需要实现哪些方法、注意哪些问题。最后对 GCD 与 NSOperation Queue 作了一个简单的对比。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>在 iOS 中实现并发编程主要有三种方式：GCD、NSOperation Queue以及Thread，其中前两者使用广泛。<br>在正式开始之前有必要区分两组概念：同步、异步与串行、并行。</p><ul><li>同步(Synchronous)、异步(Asynchronous)通常指方法(或函数)，同步方法表示直到任务完成才返回(如：<code>dispatch_sync</code>)，异步方法则是将任务抛出去，在任务没完成前就返回(如：<code>dispatch_async</code>)；</li><li>串行(Serial)、并行(Concurrent)通常指 App 执行一组任务的模式，串行表示一次只能执行一个任务，只有当前一个任务完成后才启动下一个任务，而并行指可以同时执行多个任务。最常见的莫过于 GCD 中的串行、并行队列。</li></ul><p>NSOperation Queue + NSOperation 作为 iOS 中『高级的、面向对象的并发编程方式』耳熟能详，但具体到一些细节问题上认识往往又比较模糊。本文在苹果官方文档 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html" target="_blank" rel="noopener">Concurrency Programming Guide</a>、<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/index.html" target="_blank" rel="noopener">NSOperation Class Reference</a> 以及 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperationQueue_class/index.html" target="_blank" rel="noopener">NSOperationQueue Class Reference</a> 的基础上做了一次疏理和总结。</p><h1 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h1><hr><p><code>NSOperation</code> 本身是个抽象类，在使用前必须子类化(系统预定义了两个子类：<code>NSInvocationOperation</code> 和 <code>NSBlockOperation</code>)。那问题来了，在子类化过程中，需要重写父类的哪些方法？</p><p>这首先就要了解一下<code>NSOperation</code>类中几个重要方法的默认实现：<br><img src="/img/NSOperationDefault.png" alt=""><br>在 NSOperation 中还有一个重要概念：operation 的状态，并且当状态变化时需要通过 KVO 的方式通知外：<br><img src="/img/NSOperationKeypath.png" alt=""><br>回到前面那个问题：子类化 NSOperation 时需要重写哪些方法？<br>这取决于子类化后的 operation 是 Synchronous 还是 Asynchronous(NSOperation 默认是Synchronous)。</p><h2 id="Synchronous-VS-Asynchronous-Operations"><a href="#Synchronous-VS-Asynchronous-Operations" class="headerlink" title="Synchronous VS. Asynchronous Operations"></a>Synchronous VS. Asynchronous Operations</h2><hr><p>由于操作 NSOperation 与 NSOperation 任务的执行往往在不同的线程上进行，在继续之前需要强调线程安全问题：『NSOperation 本身是 thread-safe，<em>当我们在子类重写或自定义方法时同样需要保证 thread-safe</em>』。</p><h3 id="Synchronous-Operations"><a href="#Synchronous-Operations" class="headerlink" title="Synchronous Operations"></a>Synchronous Operations</h3><p>对于 Synchronous Operation，在调用其 <code>start</code> 方法的线程上同步执行该 operation 的任务，<code>start</code> 方法返回时 operation 执行完成。因此，对于 Synchronous Operation 一般只需重写 <code>main</code> 方法即可(<code>start</code>方法的默认实现已实现相关 KVO 功能)。</p><h3 id="Asynchronous-Operations"><a href="#Asynchronous-Operations" class="headerlink" title="Asynchronous Operations"></a>Asynchronous Operations</h3><p>然而对于 Asynchronous Operation，调用其 <code>start</code> 方法后，在 <code>start</code> 返回时 operation 的任务可能还没完成(为了实现异步，一般需要在其他线程执行 operation 的具体任务)。因此 <code>start</code> 方法默认实现不能满足异步需要(默认实现会在<code>start</code>返回前将 <code>isExecuting</code> 置为 NO、<code>isFinished</code> 置为 YES，并产生 KVO 通知)。此时至少需要重写以下方法：</p><ul><li>start：<br>  我们知道 NSOperation 本身不具备并发(或者说异步执行)能力，因此需要 <code>start</code> 方法来实现，可以通过创建子线程或其他异步方式完成。同时需要在任务开始前将 <code>isExecuting</code> 置为YES 并抛出 KVO 通知。<br>  <strong><em>『重写的 <code>start</code> 方法一定不能调用 <code>[super start]</code>』</em></strong></li><li>asynchronous<br>  返回 YES，一般不需要抛出 KVO 通知</li><li>executing<br>  返回 operation 的执行状态，在其值发生变化时需要在 <code>isExecuting</code> 上抛出 KVO 通知</li><li>finished<br>  返回 operation 的完成状态，同样值变化时需要在 <code>isFinished</code> 上抛出 KVO 通知</li></ul><p>这里我们看看著名的网络框架 AFNetworking 中关于 NSOperation 的使用：</p><blockquote><p>AFNetworking 3.0 全面使用 <code>NSURLSession</code>，而 <code>NSURLSession</code> 本身是异步的、且没有 <code>NSURLConnection</code> 需要 runloop 配合的问题，因此在3.0版本中并没有使用 NSOperation，代码得到很大的简化。这里我们说的是 AFNetworking 2.3.1 版本。</p></blockquote><p>在 AFNetworking 中 AFURLConnectionOperation 是个异步的 NSOperation 子类，其 <code>start</code> 方法如下：<br><img src="/img/AFURLConnectionOperation-start.png" alt=""><br>从上面 <code>start</code> 方法的实现可以看到：</p><ol><li>用 lock(递归锁) 保证了thread-safe；</li><li>检查了 operation 是否已被 cancel；</li><li>检查了 operation 是否已 ready；</li><li>通过子线程实现并发；</li><li>在 state setter 中实现了 KVO。<br><img src="/img/AFURLConnectionOperation-statesetter.png" alt=""></li></ol><p>再来看看 AFURLConnectionOperation 使用的子线程：<br><img src="/img/AFURLConnectionOperation-thread.png" alt=""><br>可以看到，所有 AFURLConnectionOperation 实例底层使用的是同一个子线程，并在该线程中启动了 runloop（<code>NSURLConnection</code> 的网络回调必须要有 runloop 的配合，通过port-based input source 唤醒 runloop 处理网络事件），也就是说 AFURLConnectionOperation 是在一条常驻子线程中处理网络回调。</p><p>前面我们提到 operation 被 cancel 时也被认为是完成，这点在自定义 <code>start</code> 时同样需要注意：<br><img src="/img/AFURLConnectionOperation-cancel.png" alt=""><br>在 AFURLConnectionOperation 的 <code>cancelConnection</code> 以及 <code>connection:didFailWithError:</code> 方法中都会调用其 <code>finish</code> 方法：<br><img src="/img/AFURLConnectionOperation-finish.png" alt=""><br>ps：虽然 NSOperation 支持 cancel，但在调用 <code>cancel</code> 方法后该如何处理完全由我们自定义的 <code>start</code> 方法决定(当然良好的设计应该要符合 cancel 的语义)。</p><p>同时，AFURLConnectionOperation 也实现了以下方法：<br><img src="/img/AFURLConnectionOperation-isReady-isFinished.png" alt=""></p><h3 id="关于-NSOperation-其他细节问题"><a href="#关于-NSOperation-其他细节问题" class="headerlink" title="关于 NSOperation 其他细节问题"></a>关于 NSOperation 其他细节问题</h3><hr><ul><li><p>dependencies:<br>  我们可以在 operation 间添加依赖关系，在某个 operation 所依赖的 operations 完成之前，其一直处于未就绪状态(<code>isReady</code> 为 NO)。<br>  需要注意的是，依赖关系是 operation 自身的状态，也就是说有依赖关系的 operations 可以处在不同的 NSOperationQueue 中。</p></li><li><p>isReady:<br>  <code>isReady</code> 默认实现主要处理 operation 间的依赖关系，当我们自定义该方法时需要考虑 <code>super</code> 的值，如 AFURLConnectionOperation中关于 <code>isReady</code> 的实现：<img src="/img/AFURLConnectionOperation-isReady.png" alt=""></p></li><li><p>qualityOfService:<br>  用于表示 operation 在获取系统资源时的优先级，默认值：<code>NSQualityOfServiceBackground</code>，我们可以根据需要给 operation 赋不同的优化级，如最高优化级：<code>NSQualityOfServiceUserInteractive</code>。</p></li><li><p>queuePriority:<br>  用于设置 operation 在 operation queue 中的相对优化级，同一 queue 中优化级高的 operation(<code>isReady</code> 为 YES) 会被优先执行。需要注意区分<code>qualityOfService</code>(在系统层面，operation 与其他线程获取资源的优先级)与<code>queuePriority</code>(同一 queue 中 operation 间执行的优化级)的区别。<br>  同时，需要注意<code>dependencies</code>(严格控制执行顺序)与<code>queuePriority</code>(queue 内部相对优先级)的区别。</p></li></ul><h1 id="NSOperation-Queue"><a href="#NSOperation-Queue" class="headerlink" title="NSOperation Queue"></a>NSOperation Queue</h1><hr><p>NSOperation Queue 用于管理、执行 NSOperation，无论其中的 operation 是并行还是串行，queue 都会在子线程(借用 GCD)中执行 operation。<br>从上小节我们知道，实现异步 operation 比同步 operation 要复杂许多，因此如果打算将 operation 加入 queue 中，则完全可以将 operation 实现为同步方式。<br>对于 queue 中已就绪的 operation，queue 会选择 <code>queuePriority</code> 值最大的 operation 执行。</p><p>关于 NSOperation Queue 有两点需要强调：</p><ul><li>cancelAllOperations：用于取消队列中的 operations，对 queue 中所有 operations 调用 <code>cancel</code>方法。(从上小节我们知道，对 operation 调用 <code>cancel</code> 方法后的效果完全由 operation 自己决定。<code>cancel</code> 唯一能影响的就是清除 operation 的依赖关系，使其立即可以被执行)。此时 queue 并不会 remove 其中的 operations，remove 操作仅发生在 operation 完成时。</li><li>suspended：将该属性置为 YES，会阻止 queue 执行新的 operation，但已经在执行中的 operation 不受此影响。</li></ul><h1 id="GCD-vs-NSOperation-Queue"><a href="#GCD-vs-NSOperation-Queue" class="headerlink" title="GCD vs. NSOperation Queue"></a>GCD vs. NSOperation Queue</h1><hr><p>GCD 与 NSOperation Queue 作为常见的并发编程方式，在使用时该如何选择？<br>首先，对比一下我们关心的几个问题：<br><img src="/img/GCDvsNSOperationQueue.png" alt=""><br>我们可以看到，NSOperation Queue 作为高级 API，有很多 GCD 没有的功能，如需要支持：控制并发数、取消、添加依赖关系等需要使用 NSOperation Queue。<br>另外，由于 block 可复用性没有 NSOperation 好，对于独立性强、可复用性高的任务建议使用 NSOperation 实现。<br>当然，NSOperation 在使用时需要 sub-classing，工作量较大，对于简单的任务使用 GCD 即可。</p><p>别忘了，我们还有第三种选择：NSThread。由于使用 NSThread 时需要处理线程相关的问题，一般很少使用。但无论是 GCD 还是 NSOperation Queue，其中的任务具体何时执行是由系统控制的，对于实时性要求很高的任务则可以使用 NSThread。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>本文简单讨论了在使用 NSOperation 时需要重写哪些方法、注意哪些问题。同时也对 GCD 与 NSOperation Queue 作了简单对比，在清楚了它们各自的特点之后再做选择时会更加清晰。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p> <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html" target="_blank" rel="noopener">Concurrency Programming Guide</a><br> <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/index.html" target="_blank" rel="noopener">NSOperation Class Reference</a><br> <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperationQueue_class/index.html" target="_blank" rel="noopener">NSOperationQueue Class Reference</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细介绍了在实现同步、异步 NSOperation 时分别需要实现哪些方法、注意哪些问题。最后对 GCD 与 NSOperation Queue 作了一个简单的对比。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈高质量移动开发</title>
    <link href="http://zxfcumtcs.github.io/2016/03/26/HighQualityMobileDevelopment/"/>
    <id>http://zxfcumtcs.github.io/2016/03/26/HighQualityMobileDevelopment/</id>
    <published>2016-03-26T15:27:27.000Z</published>
    <updated>2018-12-08T08:41:32.857Z</updated>
    
    <content type="html"><![CDATA[<p>本文从移动端构架设计、类设计、方法设计以及最佳实践等方面简单讨论了如何开发出高质量的代码。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>高质量代码、架构设计以及重构等都是充满智慧且需要深厚功底和实战经验的话题，本不敢随意拿来讨论。只是最近在项目中对两个较大的模块做了一次重构，再加上补习了一下《代码大全》以及《重构》，因此尝试着做一次这方面的分享。代码设计本身也是一个仁者见仁、智者见智的话题，下述讨论如有不正确之处，请指正。</p><p>首先需要回答的问题是什么样的代码是高质量代码，其次才是如何设计出高质量代码。</p><p>从宏观上说，高质量代码无外乎于：可扩展性强、可维护性高、可读性好。<br>从实现的层面说，主要包含：划分层次合理、数据流向简洁明了、模块间通信合法、类有良好的封装和一致的抽象、实体内部高内聚、实体间低耦合等。</p><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><hr><p>对于终端开发来说，架构设计最经典莫过于 MVC，在此基础上又衍生出了像 MVVM 之类的架构。<br>之前看过一篇文章讨论是先分层再分模块，还是先分模块再分层的问题。虽然，这两种方式各有道理，但个人还是建议先划分模块，再在模块内部按 MVC 或其他架构分层，因为对于终端来说模块有更强的独立性，一个模块基本上也是由M、V、C 三部分构成。</p><p>关于 MVC、MVVM 等构架的文章已有很多，本文不再赘述。</p><p>以 MVC 为例，需要强调的是 M、V、C三者间的通信规则：<br><img src="/img/MVC.jpg" alt=""><br>如上图所示，Model 与 View 之间严格禁止直接通信，这也是经常会犯的错误。<br>禁止 Model 与 View 间的通信，也就将底层数据与 UI 隔离开，降低了耦合。</p><p>项目中，往往一个模块由一个人单独负责，这就导致不同的模块可能采用不同的架构，MVC、MVP、MVVM 以及其他变体构架可能在一个项目中同时存在，显得有些混乱。最好是能统一一下，一个项目只用一种构架。</p><h1 id="类设计"><a href="#类设计" class="headerlink" title="类设计"></a>类设计</h1><hr><p>在面向对象编程中，类的好坏直接影响代码的质量，那么什么样的类是设计良好的类？<br>同样，从宏观上说设计良好的类具有：良好的抽象与封装。</p><p>抽象与封装是两个关系非常紧密的概念。</p><blockquote><p>代码大全对抽象的定义：抽象是一种能让你在关注某一概念的同时可以放心地忽略其中一些细节的能力。</p></blockquote><p>具体到类上，抽象主要指接口的抽象，即对外宣称该类具有什么样的能力、能完成哪些工作。而类的具体实现对外界是个黑盒子，无需关心。<br>封装更强调的是隐藏细节，迫使外界无法了解类内部的细节信息。</p><h2 id="良好的抽象"><a href="#良好的抽象" class="headerlink" title="良好的抽象"></a>良好的抽象</h2><p>通过抽象接口可以简化外界对类的使用，使其无需关心类内部复杂的实现细节。<br>在设计接口时，需要注意的问题：</p><ul><li><p><b><u>接口需要展现一致的抽象层次</u></b><br><img src="/img/abstract-employeecensus.png" alt=""><br>  该类接口最大的问题在于没有隐藏内部使用数组的事实，很明显在抽象接口中不应暴露这一细节。<br>  这样做的坏处在于，若今后修改了底层容器，不再使用 Array 而改用 Dictionary，那么这组接口就难以理解，渐渐地也无法维护了。<br>  正确的做法应该是：<br><img src="/img/abstract-employeecensus-right.png" alt=""></p></li><li><p><b><u>接口应隐藏细节</u></b><br>  接口应该隐藏业务层无需关心的细节问题。在我们项目中，支持游客登录和 QQ 登录，而登录模块将这两种登录方式区分开来以不同的 notification 通知业务层相关的登录信息。然而绝大多数业务逻辑并不关心具体的登录方式，若在此基础上添加微信等其他登录方式，接口将更加难以维护。<br>  因此，在登录模块重构后将这些细节信息都隐藏在登录模块内部，对外提供统一的回调接口。</p></li><li><p><b><u>高内聚</u></b><br>  无论是在类层次还是方法层次，高内聚一直是我们追求的目标之一。对类来说，抽象与内聚关系十分紧密，类具有良好抽象的接口一般也意味着有很高的内聚性。</p><p>  在我们 QQ 阅读项目中，有一个非常重要的类：<code>QRBookInfo</code>，从名字看应该是一个用于表示书籍信息的类。其对外的接口应该有：id(唯一编号)、name(名称)、author(作者)以及 format(格式)等。但在现实中 <code>QRBookInfo</code>类却包含了很多不属于它的信息，如：阅读进度、阅读时间、添加到书架时间以及在书架上分组 id 等，最终该类暴露给外界的属性有将近40个，沦落为一个大杂烩，很明显已经不具备高内聚特征了。</p><p>  如果要对该类进行重构，则可以通过 Extract Class(提炼类)的手法进行，将不属于该类的职责提炼到新的类中。从 <code>QRBookInfo</code> 至少可以提炼出3个类：</p><ol><li><code>QRBook</code>——用于描述书籍本身，抽象接口有：id(唯一编号)、name(名称)、author(作者)以及 format(格式)等；</li><li><code>QRBookShelfItem</code>——用于描述书架上每个项的信息，抽象接口有：id(书籍编号)、addTime(添加到书架时间)以及 categoryId(该书在书架上的分组编号)等；</li><li><code>QRReadingItem</code>——用于描述阅读信息，抽象接口有：id(书籍编号)、readTime(阅读时间)以及 readProgress(阅读进度)等。</li></ol><p>项目中，还有个书架类：<code>BookShelfViewController</code>，有5000多行代码，注册了20多个通知，已经到了几乎无法维护的地步，其中不仅包含了书架相关的逻辑，打开书的逻辑也全部扔在里面。后来在一个新项目中需要使用这个类时，稍微做一点小改动都无法正常工作。此次对书架进行重构时将打开书的逻辑全部移到其他类中，<code>QRBookShelfViewController</code> 这个类只专注于处理书架相关的逻辑。</p><p>高内聚作为管理类复杂度的一个重要原则，我们应该时刻把握这一利器。</p></li><li><p><b><u>尽量让接口可编程，拒绝隐藏的语义</u></b></p><blockquote><p>来自代码大全：每个接口都由一个可编程(programmatic)部分和一个语义(semantic)部分组成。其中，可编程部分由接口中的数据类型和其他属性构成，编译器能强制性地要求它们(在编译时检查错误)，而语义部分则由『本接口将会被怎样使用』的假定组成，而这些是无法通过编译器来强制实施的。</p></blockquote><p>  比如：在调用 methodA 前必须先调用方法 methodB，这一要求则属于 methodA 的语义部分。由于没有编译器的强制检查，这一隐藏语义很可能被调用者忽略，引起错误。</p><p>  因此，接口设计时尽量不要包含语义部分，可以通过抽取新接口或添加 Asserts 等方法将语义接口转换为编程接口，确实无法避免也应在接口中通过注释说明其中的语义。如在上述例子中，可以添加新的接口methodC，在该接口中调用 methodB、methodA，从而消除 methodA 的语义。</p></li><li><p><b><u>谨防在修改时破坏接口的抽象</u></b><br>  从前面讨论可知，一个类应该围绕一个中心职责，处理一个任务。在类设计之初可能有较高的内聚性，但在实际开发中，类会被不断扩展，不断加入新的功能和数据。类的内聚性和抽象性很可能在这个过程中被破坏。<br>  经常在代码中可以看到一个类有截然不同风格、不同抽象的接口，这往往是被”篡改”的结果。另外还会看到有2个、3个、4个甚至更多个相同功能，只是参数不一样的接口。有的接口多出个 bool 型的参数，有的带个 block 类型的参数，有的带个 delegate 形式的参数，在这种粗暴式的背后往往隐藏着重复代码的危机。<br>  在我们的登录模块中，登录接口有10个之多，登录回调也是五花八门，有 block、delegate 以及 notification。因此在业务层的类中经常看到这3种回调方式同时存在，维护成本极高。我相信，在设计之初绝非如此混乱，而是在日后开发过程中慢慢引入的。<br>  因此在修改已有类接口时一定要三思，切不可图一时之便随意添加修改，否则久而久之很可能导致类失控。若因业务需要必须修改，最好将需求提给类的作者，由他来修改。</p></li><li><p><b><u>设计接口时尽量不要给调用者留坑</u></b><br>  我们有一个基类 controller：<code>QRBaseViewController</code>，其定义了一个接口，作用是让子类自定义 NavigationBar 上的item：<br><img src="/img/initTopBarWithTitle.png" alt=""> <img src="/img/actionBlock.png" alt=""><br>  你能看出来该接口有什么问题吗？<br>  没错，问题就出在其最后一个block参数上，由于类本身需要 hold 这个 block，而在 block 中往往需要通过 <code>self</code> 调用其他子方法或属性，这样就出现了cycle retain。经过一番排查发现有6、7个类存在这样的问题。<br>  (ps: 上面的 <code>actionBlock</code> 属性应该使用 <code>copy</code> 而不是 <code>strong</code>)</p></li></ul><h2 id="良好的封装"><a href="#良好的封装" class="headerlink" title="良好的封装"></a>良好的封装</h2><p>抽象更多是强调这个类是什么，能做什么，而封装则是强制外界无法了解实现的细节。<br>良好的封装一般需要注意：</p><ul><li><p><b><u>尽可能地限制类中各成员的可访问性</u></b><br>  使可访问性尽可能低是促成封装的原则之一，在 Objective-C 中则是尽可能将类的数据成员、属性以及方法放到类的匿名分类中，使类的接口(.h文件)文件尽量简洁。</p></li><li><p><b><u>不要暴露类的数据成员</u></b><br>  在 Objective-C 中，属性作为特殊的数据成员，可以暴露给外界，但在这么做之前请认真思考是否真的需要这么做。<br>  但是，作为容器类的数据成员(Array、Dictionary、Set 等)一定不要轻意暴露给外界，因为这属于很底层的实现细节。一旦暴露了这些细节，封装将被严重破坏。</p><p>  试想一下，若有一天需要将 Array 改为 Dictionary，影响范围有多大？<br>  如果暴露的是容器的mutable版本，那么外界可以任意对该容器进行操作，你已失去各种控制、错误检查的能力，同时还可能有多线程问题。</p></li><li><p><b><u>私有实现细节一定不要暴露在头文件中</u></b><br>  头文件应该是简洁明了的，仅用于向外界表达该类能做什么。简洁的头文件也能减少类的使用者在使用该类时的成本。</p></li><li><p><b><u>要格外警惕从语义上破坏封装性</u></b><br>  语法上的封装可以通过 private、匿名 category 等方式实现，然而语义上的封装性更难以控制。以下是代码大全中列举的从语义上破坏封装性的例子：</p><ol><li>不去调用类 A 的 InitialixeOpertaions()子程序，因为你知道 A 类的 PerformFirstOperation()子程序会自动调用它；</li><li>不在调用 employee.Retrive(database)之前去调用 database.Connect()子程序，因为你知道在未建立数据库连接时employee.Retrive(database)会去连接数据库；</li><li><p>不去调用类 A 的 Terminate()子程序，因为你知道 A 类的 PerformFinalOperation()子程序已经调用了该方法。</p><p>上述例子的问题在于，其调用方不是依赖类的抽象接口，而是依赖于类的内部实现。当通过查看类的内部实现得知可以如何使用该类时，就不是针对接口编程，而是透过接口针对内部实现编程。这是一种十分危险的举动，类的封装性已被破坏，一旦类内部实现改变了，可能引起严重错误。</p></li></ol></li><li><p><b><u>低耦合</u></b><br>  两个类之间的关联程度称为耦合，低耦合一直是我们的追求。类的封装性直接影响到耦合程度，若类过多的将细节信息暴露出来，无疑会增加类与使用方间的耦合度。<br>  理想情况下，类对于调用者来说是个黑盒子，调用者通过类的接口就能完成对该类的使用，而无需深入类内部了解实现细节，当然这首先需要该类有很好的抽象与封装。反之，若在使用一个类时需要了解其内部实现，则必然在两者之间形成很高的耦合。<br>  抽象性与耦合间的关系也十分紧密，良好的抽象与封装一般也会有较低的耦合度。</p><p>  项目中，有个用于表示书架分组的类：<code>QRCategoryViewController</code>，该类不仅用于处理分组相关的业务逻辑，连用户分组数据的读取、存储也全在这个类中。而书架在决定显示哪些书时也需要知道当前分组信息，因此，在书架初始化时必须也初始化一个<code>QRCategoryViewController</code>实例，用于获取当前分组信息。这里，正是由于<code>QRCategoryViewController</code>类在抽象与封装上没有处理好，导致原本几乎没有耦合关系的两个类<code>QRCategoryViewController</code>与<code>BookShelfViewController</code>间高度耦合。在重构时，将分组数据的管理移到一个新类<code>QRCategoryManager</code>中，使<code>QRCategoryViewController</code>与<code>BookShelfViewController</code>间彻底解耦。</p></li></ul><h2 id="慎用继承，用好继承"><a href="#慎用继承，用好继承" class="headerlink" title="慎用继承，用好继承"></a>慎用继承，用好继承</h2><p>作为面向对象三大特性之一的继承，重要性不言而喻，用好了能简化程序，反之会增加程序复杂性。<br>在决定使用继承之前，需要认真思考基类与派生类之间是否是”is…a”的关系，如若不是，那继承就不是正确的选择，此时可考虑”has…a”(包含)关系是否更合适。<br>代码大会中关于继承的几个经典描述：</p><ul><li>继承的目的在于通过”定义能为多个派生类提供共有元素的基类”的方式简化代码。</li><li>基类即对派生类将会做什么设定了预期，也对派生类能怎么运作提出了限制。</li><li>派生类必须能通过基类的接口而被使用，且使用者无须了解两者之间的差异。</li><li>如果派生类不准备完全遵守由基类定义的同一个接口契约，继承就不是正确的选择。<br>(你做到了吗^-^)</li></ul><p>项目中的书架类<code>BookShelfViewController</code>由于要同时适配 iPhone 和 iPad 两个版本，因此在代码中随处可见：<code>if(IS_IPHOEN)...else</code>这样的语句。<br>在重构的时候，将 iPhone 与 iPad 的UI逻辑抽取到两个子类，而它们共有的数据相关逻辑(如：云书架、章节更新等)放在基类。<br><img src="/img/QRBookShelfViewController.png" alt=""><br>在登录重构时，我们有 QQ 登录、微信登录以及游客登录，3种登录方式都有相同的操作：登录、续期、获取 accessToke 等。从表面上看，似乎可以生成一个基类，再派生出3个子类分别用于实现上述不同的登录方式。但仔细一想，它们之间除有相同语义的接口，并没有共享的数据或实现，因此继承并不合适，而 Objective-C 支持的接口在这里再合适不过了。<br>因此，我们定义了一个 protocol <code>QRAuthenticatorDelegate</code>：<br><img src="/img/QRAuthenticatorDelegate.png" alt=""><br><code>QRQQAuthenticator</code>、<code>QRWeChatAuthenticator</code> 以及 <code>QRGuestAuthenticator</code>实现了 <code>QRAuthenticatorDelegate</code>。<br><img src="/img/QRAuthenticationDelegate.png" alt=""></p><p>由于 Objective-C 语言的动态性，其成员函数天生就具有虚函数的特征，当继承体系过于复杂，函数重载将进一步加大问题的复杂性。<br>继承在使用前一定要三思，或许包含、接口是更好的选择，使用不当会增加程序复杂性。</p><h2 id="隔离错误"><a href="#隔离错误" class="headerlink" title="隔离错误"></a>隔离错误</h2><p>船体外壳装有隔离舱、建筑物都有防火墙，其作用都是隔离危险。<br>在防御式编程中同样需要隔离危险，在系统层面可以有专门的类用于处理错误、隔离危险(来自代码大全)：<br><img src="/img/barricadeerror.png" alt=""><br>在此我更想从类的层面讨论这一问题，曾经一直苦恼这样一个问题：<br>在类的公开接口中检查了传入的参数，然后该参数又传入到私有方法中，那么在私有方法中应不应该再次检查该参数的合法性。<br>根据上面的隔离理论，应该只要在公开接口中检查参数的合法性即可，在私有方法中可以认为参数是经过筛选的、正确的。</p><p>在程序中错误又可分为2类：</p><ul><li>绝不应该出现的、意料之外的错误(之所以会出现可能是程序存在 bug)；</li><li>不经常出现的、非正常情况。</li></ul><p>对于上述2种错误应该分别使用断言(Assertions)和错误处理。回到前面那个问题，在类的公开接口中可以视情况使用错误处理或断言，而在类的私有方法中可以直接使用断言。<br>(ps: 断言主要用于在开发期间快速检测代码错误)</p><h1 id="方法设计"><a href="#方法设计" class="headerlink" title="方法设计"></a>方法设计</h1><hr><p>『代码首先是写给人看的，其次才是让机器执行的』，在方法设计时更应考虑这一点。</p><h2 id="起个好名字"><a href="#起个好名字" class="headerlink" title="起个好名字"></a>起个好名字</h2><p>命名是个技术活，对代码维护性、可读性至关重要！<br>需要注意的是，方法名应该强调方法是做什么的，而不是怎么做的。<br>除此之外，方法名在内存管理上也有约束：<br>任何以下列名称为前缀的方法，若其返回值为 object，则方法调用者持有该 object：alloc、new、copy以及mutableCopy。<br>还有一个更为严格的规则：任何以 init 为前缀的方法必须遵守下列规则：</p><ul><li>该方法必须是实例方法；</li><li>该方法必须返回类型为<code>id</code>或其所属class、superclass、subclass 的对象；</li><li>该方法返回的 object 不能是 autorelese，即方法调用者持有返回的 object。</li></ul><p>尤其是在 ARC 与 MRC 混用的项目中，必须遵守上述规则，详情可参看我之前的文章：<a href="http://zxfcumtcs.github.io/2015/09/03/MemoryManagement/">Inside Memory Management for iOS</a>。</p><h2 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h2><p>一个方法只做一件事！并通过方法名很优雅的表达出来！<br>但在实际中很多方法往往做了更多，有的方法长达100多行，甚至几百上千行。<br>低内聚的方法带来的后果有：</p><ul><li>难以维护；</li><li>因为做的事太多，无法取一个好的方法名；</li><li>往往导致重复代码，试想一下，若 methodA 做了 task1 和 task2，methodB 做了 task1 和 task3，那 task1 相关的代码是不是就重复了。</li></ul><h2 id="将复合语句体抽取为子方法"><a href="#将复合语句体抽取为子方法" class="headerlink" title="将复合语句体抽取为子方法"></a>将复合语句体抽取为子方法</h2><p>将 <code>if...else...</code>、<code>for</code>、<code>switch</code> 等语句的 body 抽取为子方法，并通过好的方法名提高可读性。<br><img src="/img/ifright.png" alt=""><br><img src="/img/ifwrong.png" alt=""></p><p>这两段代码做了同样的事情，都是根据用户选择加载 grid 或 line 模式的书架，但其可读性差异还是很大的。</p><h2 id="复合语句体加大括号"><a href="#复合语句体加大括号" class="headerlink" title="复合语句体加大括号"></a>复合语句体加大括号</h2><p>经常会看到这样的代码：<br><img src="/img/ifnoparantheses.png" alt=""><br>还记得，iOS 系统上那个由 gotofail 引起的 SSL/TSL 安全漏洞吗？<br><img src="/img/gotofail.png" alt=""><br>这就是引起问题的源码，虽然说这个 bug 不能全赖 if 没有加”{}”，但如果 if 加上了大括号该问题可能就避免了。<br>因此，无论 if 等复合语句的 body 是否只有一条语句都应加上”{}”。</p><p>另外，关于 if 语句的格式规范问题，虽各有各的习惯，但强烈不建议做成下面这样(事实上大量 if 被写成这样，因为 Xcode默认代码补全就是这样的)：<br><img src="/img/worngifformat.png" alt=""><br>当 if…else…较复杂时，根本分不清 else 与哪个 if 配对。<br><img src="/img/rightifformat.png" alt=""><br>个人更推荐这种写法，不仅层次分明，也节省空间。</p><h2 id="将复杂的条件表达式抽取为子方法或命名良好的赋值语句"><a href="#将复杂的条件表达式抽取为子方法或命名良好的赋值语句" class="headerlink" title="将复杂的条件表达式抽取为子方法或命名良好的赋值语句"></a>将复杂的条件表达式抽取为子方法或命名良好的赋值语句</h2><p>如果条件表达式过于复杂为了提高可读性，若该表达式重复出现应该抽取为布尔方法，否则可以将其赋值给一个良好命名的变量。<br>我们书架有个规则，在 iPhone 上对于自定义的分组，若该分组下有书籍，则需要在书籍列表的最后面添加一个导入书的按钮。<br><img src="/img/BookShelfAddButton.png" alt=""><br>如果我们把这些条件直接写在 if 里面：<br><img src="/img/ifcondition.png" alt=""><br>下面是将其抽取到一个方法中：<br><img src="/img/shouldShowAddBookCell.png" alt=""><br>对于不需要关心具体显示规则的人来说，下面这种可读性好很多。</p><h2 id="中间变量"><a href="#中间变量" class="headerlink" title="中间变量"></a>中间变量</h2><p>前面讲到复杂的布尔表达式可以转换为命名良好的中间变量，但并不意味着可以随意添加。多一个中间变量就多一份复杂，多一种状态，对于使用次数少的中间变量可以直接将表达式内联到语句中。<br><img src="/img/Intermediatevariable.png" alt=""><br>像这里的 <code>indexPath.row</code> 含义清楚明确，没必要再定义中间变量 <code>row</code>。</p><p>对于类来说也是如此，为了解决某些问题往往会引入一些状态成员变量，这种做法无可厚非，但还是要谨慎。往往状态变量涉及什么时候 set、什么时候 reset，增加了类内部的复杂性，也增加了类内部方法间的耦合度。</p><h2 id="优先处理错误情况"><a href="#优先处理错误情况" class="headerlink" title="优先处理错误情况"></a>优先处理错误情况</h2><p>若方法需要检查参数或其他条件，把检查操作放在方法开始部分，条件不满足时立即返回。<br><img src="/img/iffirstdorightthings.png" alt=""><img src="/img/iffirstdoworngthings.png" alt=""><br>第二种写法，一看就知道在条件不满足时方法什么也没做。<br>而第一种写法，尤其是在 if body 很复杂、嵌套了多层 if、代码超出一屏时就很难一眼看出在条件不成立时方法做了什么。</p><h2 id="switch-语句不要有-default-分支"><a href="#switch-语句不要有-default-分支" class="headerlink" title="switch 语句不要有 default 分支"></a>switch 语句不要有 default 分支</h2><p>尤其是利用 switch 处理 enum 时，轻意不要写 default 分支，这样在漏掉哪个枚举值没有处理时，编译器会发出警告。但在有 default 分支时，是不会有警告的。</p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><hr><p>该小节主要讨论在开发过程一些值得注意的小点，不一定与设计有关。</p><h2 id="充分利用泛型"><a href="#充分利用泛型" class="headerlink" title="充分利用泛型"></a>充分利用泛型</h2><p>LLVM 7.0从编译器层面支持泛型，系统中常用的容器都增加了对泛型的支持，无疑是一个重大利好。<br><img src="/img/noGenerics.png" alt=""> <img src="/img/genericsArrayDictionary.png" alt=""> <img src="/img/warningGenerics.png" alt=""><br>使用泛型容器时若类型不匹配编译器会有 warning。<br>其实，我个人觉得泛型容器最大的意义并非在类型不匹配时的 warning，而是泛型对接口的自我说明能力。<br>上面第个一代码片段，直到使用该容器时才能知道其中元素的类型，而第二个代码片段从容器定义中便能清楚地看到这点。</p><h2 id="合理使用-nullable、nonnull"><a href="#合理使用-nullable、nonnull" class="headerlink" title="合理使用 nullable、nonnull"></a>合理使用 nullable、nonnull</h2><p>同泛型，nullability 也是编译器 LLVM 支持的一个特性，用于描述接口中的值是否可以为 nil。<br>对于 nonnull 的接口，若传入的是 nil，编译器会发出 warning。同样，nullability对接口的自我说明能力比 warning 更有意义。</p><h2 id="用好-Objective-C-的动态性"><a href="#用好-Objective-C-的动态性" class="headerlink" title="用好 Objective-C 的动态性"></a>用好 Objective-C 的动态性</h2><p>Objective-C 语言的动态性给我们带来了无限的想象空间，『只有想不到，没有做不到』。<br>典型的利用到 Objective-C 动态性的例子有：JSPatch、MJExtension、Swizzling、KVO 以及 AOP等等。</p><ul><li>JSPatch 用于热补丁，已经非常火，无须多言；</li><li>MJExtension 主要用于将 json 自动转换成 Objective-C 的对象，能极大的提高开发效率；</li><li>Swizzling 的使用就更加常见了，我们有一个典型的用途：通过 Swizzling UIViewController 的 <code>viewWillAppear:</code> 方法以及 UIButton 的 <code>sendAction:</code> 方法，记录用户的操作路径，在 crash 时随 crash log 一起上报，通过该方法解决了不少疑难杂症的 crash；</li><li>KVO 用处很大，争议也很大，用好了可以简化代码，具体可以参考我之前的文章：<a href="http://zxfcumtcs.github.io/2015/09/18/KVO/">KVO漫谈</a>；</li><li>AOP 主要用于将不相关的逻辑独立出来，如打 log 等，在登录模块重构时使用到 AOP 思想，具体可参考我之前的文章：<a href="http://zxfcumtcs.github.io/2016/01/23/iOSAOP/">AOP漫谈</a>；</li></ul><h2 id="统一管理队列"><a href="#统一管理队列" class="headerlink" title="统一管理队列"></a>统一管理队列</h2><p>GCD作为实现多线程的方式之一，结合 block 使用时简单方便。因此，在代码中经常存在大量<code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{</code>这样的用法。<br>虽然系统会控制 GCD 使用的线程数，但当线程被锁住时，还是会创建新的线程以供其他 block 使用，因此某一时段系统可能会创建出大量线程，最终会抢占主线程的资源，影响到主线程的执行。<br>因此，必要时可以统一管理这些队列，<a href="https://github.com/ibireme/YYDispatchQueuePool" target="_blank" rel="noopener">YYDispatchQueuePool</a> 就是一个很不错的实现。</p><h2 id="类的子方法按功能排列"><a href="#类的子方法按功能排列" class="headerlink" title="类的子方法按功能排列"></a>类的子方法按功能排列</h2><p>虽然一直追求高内聚的类，但 UI 交互的类尤其是 UIViewController 一般功能都比较复杂，此时最好按功能排列方法，同一功能的方法放在一起。<br>如UIViewController的这些方法应该固定排在最前面：<br><img src="/img/initdealloc.png" alt=""><br>如果能配合使用 <code>#pragma mark -</code> 那就更好了。还可以通过 category 将不同的功能分到不同的 category 中。<br>另外，也不要将多个类放到同一个文件中。</p><h2 id="正确使用-category"><a href="#正确使用-category" class="headerlink" title="正确使用 category"></a>正确使用 category</h2><p>通过 category 可以扩展现有类的功能，在使用 category 时有几个点需要注意：</p><ul><li>category 独立于主类而存在，也就是说删除 category 不能影响主类(简单说就是不能在主类中引入 category 头文件)；</li><li>不能因为在 category 中需要使用成员变量或属性，而将其添加到主类头文件中，此时可以通过 associated object实现；</li><li>不能在 category 中重写父类方法，当在主类与 category 中定义了同一个方法时，category 中的方法会覆盖主类的方法。比如：在主类与 category 中都定义了 <code>dealloc</code> 方法，则主类中的 <code>dealloc</code> 方法将被覆盖。尤其是在没有源码的三方库中，更加不能这样做。</li></ul><h2 id="避免使用宏"><a href="#避免使用宏" class="headerlink" title="避免使用宏"></a>避免使用宏</h2><p>首先需要表明的是，能够使用宏而不是硬编码，是一件值得鼓励的事情。<br>但宏的缺点也常常遭到诟病，主要有：非强类型、只是预编译期的文本替换，因为宏定义没有加括号而引发的错误屡见不鲜。<br>绝大多数情况下，宏都可以用 const 或者子方法代替。看个有意思的问题，下面这个宏定义有问题吗：<br><img src="/img/LongPressRecognizer.png" alt=""><br>在使用时会报错：<br><img src="/img/LongPressRecognizerError.png" alt=""><br>问题就出在的文本替换上面，上面这个调用最终的样子是：<br><img src="/img/LongPressRecognizerErrorUse.png" alt=""></p><h2 id="拒绝-warning"><a href="#拒绝-warning" class="headerlink" title="拒绝 warning"></a>拒绝 warning</h2><p>warning 代表程序存在病态，虽然有些 warning 看上去无关紧要，但 warning 一旦多起来，一些重要的 warning 可能也隐藏其中，难以发现。</p><p>对于那些真的觉得无关紧要的 warning，可以通过<code>#pragma clang diagnostic ignored</code>将其隐藏(当然并不推荐这么做)。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>在如今的移动互联网时代，很多项目都是被需求推着往前走，都在追求敏捷开发、快速迭代、小步快跑，对代码质量有所忽视。<br>俗话说：『磨刀不误砍柴工』，在动手之前多一点思考，在开发过程中少一点任性，就能写出质量更高的代码。<br>总之，高质量说来容易，做到难。不仅要有丰富的实战经验，扎实的功底，更要有一颗执著的心！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从移动端构架设计、类设计、方法设计以及最佳实践等方面简单讨论了如何开发出高质量的代码。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>横屏不好惹</title>
    <link href="http://zxfcumtcs.github.io/2016/02/28/InterfaceOrientations/"/>
    <id>http://zxfcumtcs.github.io/2016/02/28/InterfaceOrientations/</id>
    <published>2016-02-28T12:17:20.000Z</published>
    <updated>2018-12-08T08:41:32.858Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单讨论了从横屏页面 pop 回竖屏页面以及在横屏页面 push 竖屏页面的实现方式。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>最近由于项目需要又和横屏扛上了，但本文不打算过多介绍 iOS 中转屏相关的理论，而是简要的分析横竖屏在实际使用中的两个场景：</p><ul><li>从仅支持竖屏的页面 push 一个支持横竖屏切换的页面，再从横屏状态返回；</li><li>从横屏状态 push 一个竖屏页面。</li></ul><p>(上述问题通过 present 方式可以解决，但在某些场景 present 不是好的解决方案，本文讨论的是 push 方式)<br>假设 controllerA 仅支持竖屏，controllerB 支持横竖屏切换。</p><h1 id="从横屏-pop-回竖屏"><a href="#从横屏-pop-回竖屏" class="headerlink" title="从横屏 pop 回竖屏"></a>从横屏 pop 回竖屏</h1><hr><p>场景：从 controllerA push controllerB，controllerB 切到横屏，再 pop 掉 controllerB（即返回 controllerA）。<br>此时由于设备还处于横屏状态，原本只支持竖屏的 controllerA 也以横屏的方式显示了，这当然不是我们希望看到的结果。</p><p>一直对此感到很苦恼，没有找到好的解决办法。</p><p>『山穷水复疑无路，柳暗花明又一村』，一个偶然的机会发现在 pop controllerB 返回 controllerA 时系统会调用 controllerA 的<code>supportedInterfaceOrientations</code>方法，若在该方法中返回<code>UIInterfaceOrientationMaskPortrait</code>，即可顺利以竖屏方式显示 controllerA。</p><p>由于从iOS6开始，系统在处理转屏时有很大的改动，不再调用具体某个 controller 的转屏方法(如：<code>supportedInterfaceOrientations</code>、<code>shouldAutorotate</code>)，而是由 navigationController 接管，因此一般情况不会在 contoller 里面实现这些方法。</p><h1 id="从横屏-push-仅支持竖屏的页面"><a href="#从横屏-push-仅支持竖屏的页面" class="headerlink" title="从横屏 push 仅支持竖屏的页面"></a>从横屏 push 仅支持竖屏的页面</h1><hr><p>场景：controllerB 处于横屏状态，此时需要 push controllerA。<br>由于此时没有触发转屏操作，无论是 navigationController 还是涉及到的相关 controller(该场景下的 controllerA、controllerB)的转屏方法都没有调到。controllerA 自然也是以横屏姿态出现了。</p><p>此时，要是能触发一下转屏相关的事件就好了！<br>为了达此目的，需要使用点『奇技淫巧』的手段了，在 push controllerA 之前先 present 一个仅支持竖屏的页面，立马上又 dismiss 掉，这样就能触发转屏事件了，controllerA 也就变成竖屏了。</p><p><img src="/img/PortraitViewController.png" alt=""></p><p>从 iOS 的开展来看，Apple 是希望淡化页面方向这个概念(尤其是 iOS8 之后)，但在实际项目中有时又十分关注这点，此时显得很无奈！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单讨论了从横屏页面 pop 回竖屏页面以及在横屏页面 push 竖屏页面的实现方式。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>AOP漫谈</title>
    <link href="http://zxfcumtcs.github.io/2016/01/23/iOSAOP/"/>
    <id>http://zxfcumtcs.github.io/2016/01/23/iOSAOP/</id>
    <published>2016-01-23T11:03:00.000Z</published>
    <updated>2018-12-08T08:41:32.864Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先简要讨论了 Objective-C 消息传递机制，随后重点讨论了在 Objective-C 中实现 AOP 的三种方式：<em>Method Swizzling</em>、<em>Aspects</em>以及<em>Proxy</em>。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>AOP(Aspect Oriented Programming, 面向切面编程)作为一种编程范式(Programming Paradigm)，主要用于解决<em>cross-cutting concerns(横向的通用逻辑)</em>问题，将非模块内部逻辑抽离出来，实现高内聚、低耦合的目标。</p><p>AOP 主要通过预编译或运行期动态代理实现在不修改源代码的前提下添加功能，我们知道 Objective-C 作为典型的动态语言，在实现 AOP 上有着先天优势，下文将着重介绍 Objective-C 现实 AOP 的三种方式。</p><p>在项目开发中，像统计、日志、安全鉴权、异常处理等都是不可避免的，同时它们与模块的业务逻辑并不相关，若将它们揉和在一起十分不利于代码的维护，而通过 AOP 可以很方便的将这些功能从业务模块中抽离出来。</p><p>在<a href="http://zxfcumtcs.github.io/2015/09/18/KVO/">KVO漫谈</a>这篇文章中我们讨论了 KVO 的实现机制，简单地讲就是 Objective-C runtime 对被观察对象进行动态的功能添加，使得在被观察属性值发生变化时通知观察者，这也是 AOP 的应用。</p><h1 id="简述Objective-C消息传递"><a href="#简述Objective-C消息传递" class="headerlink" title="简述Objective-C消息传递"></a>简述Objective-C消息传递</h1><hr><p>Objective-C 语言的动态性在很大程度上取决于其消息传递机制，我们知道在 Objective-C 中调用某个实例的方法(如：<code>[receiver message]</code>)，称之为一条消息，最终会转换为调用<code>objc_msgSend</code>函数，其原型为：<code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code>。该函数在运行时通过查表的方式<em>动态地</em>查找最终要执行的方法的入口地址(而 C 函数、C++普通实例方法的调用是在编译期就确定了方法的入口地址，是一个静态过程，当然 C++中的虚函数也是通过查表的方式动态地查找方法入口地址)。</p><p>在Objective-C中实现 AOP 主要依赖于其消息传递机制。</p><p>在继续之前，有必要先温习几个相关的概念：</p><ul><li>selector: 我们最熟悉的，可以简单地理解为方法名；</li><li>NSMethodSignature: 方法签名，主要定义了方法的返回值类型，参数个数及类型；<br><img src="/img/NSMethodSignature.png" alt=""><br><em>函数原型 = selector + Method Signature</em></li><li>IMP: 函数指针，其定义为<code>typedef id(*IMP)(id, SEL, ...);</code>，定义函数的入口地址;</li><li>Method: 其定义为<code>typedef struct objc_method *Method;</code>;<br><img src="/img/objc_method.png" alt=""><br>从<code>objc_method</code>定义可以看出：<br><em>Method = selector + Method Signature + IMP</em></li><li>NSInvocation: 一次实例方法调用的面向对象的封装；<br><em>NSInvocation = object + selector + method signature + arguments</em></li></ul><p>有了上述铺垫，下面我们进入本文主题，讨论在 Objective-C 中实现 AOP 的三种方式。</p><h1 id="AOP-之-Method-Swizzling"><a href="#AOP-之-Method-Swizzling" class="headerlink" title="AOP 之 Method Swizzling"></a>AOP 之 Method Swizzling</h1><hr><p>对于 swizzling 大家应该都不陌生，其利用 Objective-C 的 runtime 动态的替换已有方法的实现，常见的使用场景就是替换系统方法，用于打日志，做统计等。<br>在一个版本上线后，会收到不少 crash log，但有些 log 无法定位到问题所在，此时如果能知道 crash 发生在哪个页面或许有助于问题的解决，为此，我们 swizzle 了 UIViewController 的 <code>viewWillAppear:</code>方法，在 swizzling 方法中记录下该 controller 的名称，同时还 swizzle 了 button 的 action 方法。在出现 crash 时，将这些信息连同 crash log 一起上报，这样我们就能很清楚的看到用户的操作路径。通过该方法解决了不少疑难杂症。</p><p>Method Swizzling 的对象是类，因此会影响该类的所有实例，主要用于实现简单的 AOP 场景。</p><blockquote><p>在一次内部分享时讨论过一个有趣的问题：<br>下图所示代码是一个典型的 swizzling 的实现方式，问题是在29行为何要先 addMethod，在失败的情况下再 exchange，而不是直接 exchange？(通过17、23行 if 的判断可以确定该类已经实现了 origSel 和 newSel 两个 selector)<br>问题就出在<code>class_getInstanceMethod</code>方法的『搜索域』上，该方法首先在第一个参数所指定的类中查找，若没有找到将沿着继承链逆向查找，直到找到指定的方法。也就是说，其返回的方法可能是父类的，若此时直接 exchange，则 swizzle 的是父类中的方法，这不是我们想看到的，故需要先调用<code>addMethod</code>方法，而该方法的『执行域』则是类本身，不会进入父类。</p></blockquote><p><img src="/img/swizzleMethod.png" alt=""></p><h1 id="AOP-之-Aspects"><a href="#AOP-之-Aspects" class="headerlink" title="AOP 之 Aspects"></a>AOP 之 Aspects</h1><hr><p><a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Aspects</a> 是一个非常优秀的 AOP 开源库，在<a href="https://github.com/" target="_blank" rel="noopener">github</a>已有3000多个 star，可以说是『久经考验』。其在原理上与普通的Method Swizzling是一致的，都是利用 Objective-C runtime 动态的注入新功能。<br><img src="/img/NSObject_Aspects.png" alt=""><br>Aspects的接口非常简单通过为 NSObject 添加 category，提供两个接口分别用于为类、实例 AOP 功能。</p><p>通过 Aspects 即可以在类层次为该类的所有实例做切面，也可以针对某个特定的实例：<br><img src="/img/AOPViewController.png" alt=""></p><p>好奇的是Aspects如何针对实例做切面，为了更方便的阐述问题，以下面的代码为例：<br><img src="/img/AspectsDome.png" alt=""></p><ul><li>Aspects 会动态创建<code>AspectsDome</code>类的子类<code>_Aspects_AspectsDome</code>；</li><li>swizzle <code>_Aspects_AspectsDome</code>类的<code>forwardInvocation:</code>方法，使其指向<code>__ASPECTS_ARE_BEING_CALLED__</code>函数(在该函数中会执行指定的切面操作并执行被 hook 的方法)；</li><li>swizzle <code>_Aspects_AspectsDome</code>类的<code>class</code>方法，使其指向父类的<code>class</code>方法(为了对外界隐藏其实现细节，系统在实现 KVO 时使用了同样的方式)；</li><li>在<code>_Aspects_AspectsDome</code>类中添加新方法<code>aspects__testAspects</code>，其实现指向父类<code>AspectsDome</code>的<code>testAspects</code>方法；</li><li>在<code>_Aspects_AspectsDome</code>类中将<code>testAspects</code>方法的实现指向<code>_objc_msgForward</code>;</li><li>将实例<code>aspectsDome</code>的类属性(isa)切换到<code>_Aspects_AspectsDome</code>类上(即，此时<code>aspectsDome</code>的类型为在<code>_Aspects_AspectsDome</code>，而不是初始化时的<code>AspectsDome</code>)。</li></ul><p>看到这里，似乎有种熟悉的味道，没错！在<a href="http://zxfcumtcs.github.io/2015/09/18/KVO/">KVO漫谈</a>这篇文章中我们讨论了 KVO 的实现机制，和 Aspects 的做法十分类似，都会创建新的子类。</p><p>此时，执行<code>[aspectsDome testAspects]；</code>的流程如下：<br>[aspectsDome testAspects]-&gt;_objc_msgForward-&gt;[aspectsDome forwardInvocation]-&gt;<strong>ASPECTS_ARE_BEING_CALLED</strong>-&gt;执行切面操作并执行<code>testAspects</code>方法的初始实现。</p><p>详细的现实建议大家去看<a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">源码</a>。<br>在阅读源码过程中，最让我震撼的是下面两段代码：<br><img src="/img/AspectBlock.png" alt=""><br><img src="/img/aspect_blockMethodSignature.png" alt=""></p><p>在<a href="http://zxfcumtcs.github.io/2014/07/14/block/">block那些事</a>系列文章中我们详细讨论过 block 的内部结构。Aspects的作者根据 block 内部结构，从 block 中抽取出一个 NSMethodSignature，这样做最大的目的是获取 block 参数的个数及类型。</p><p>然而下面这段代码却给我很大的困扰，无法理解：<br><img src="/img/invokeWithInfo.png" alt=""><br>这段代码的作用是根据由 block 得到的 method signature，实例化一个 NSInvocation，设置相应的参数，最后在 block 上执行该 invocation。</p><p>在 NSInvocation 中第0个、第1个参数分别是 self，_cmd。其中第0个参数通过<code>invokeWithTarget:</code>方法可以设置，但_cmd，也就是真正要执行的 selector 却没有设置。</p><p>在844行，当 block 的参数个数大于1时，将第1个参数设为 info。</p><p><em>简单地说，问题就是没有设置 NSInvocation的 selector，最终是如何找到相应的 selector 并执行的？<br>我想到的唯一的理由是，此处的 target 是 block 类型，在 NSInvocation 内部作了特殊处理，仅仅是猜测，没找到相关的资料。</em></p><p>Aspects 通过 Objective-C 的动态性，在运行时 hook 原有方法，并注入新功能，实现了 AOP，其通常用于打日志、做统计等。</p><h1 id="AOP-之-Proxy"><a href="#AOP-之-Proxy" class="headerlink" title="AOP 之 Proxy"></a>AOP 之 Proxy</h1><hr><p>通过前文的阐述我们知道，在 Objective-C 中方法调用最终都要通过查表的方式找到方法入口地址，那如果没有找到要执行的方法如何？<br><em>unrecognized selector sent to instance…</em>，这是我们经常看到的在没有找到要执行的方法时系统报的 crash。</p><p>其实，在 crash 之前，runtime 给了我们3次拯救的机会：</p><ul><li>Method resolution；</li><li>Fast forwarding；</li><li>Normal forwarding。</li></ul><p>前两种方法与文本讨论无关，不多赘述。</p><p>Normal forwarding：这也是 runtime 给的最后一次机会，此时，rumtime 首先发送<code>methodSignatureForSelector:</code>消息，用于获取方法签名，若在该重载方法中返回 <code>nil</code>，则 rumtime 抛出<code>doesNotRecognizeSelector</code>消息，程序就 crash 了。否则，runtime 发送<code>-forwardInvocation:</code>消息，实现转发。</p><p>这是一个很好的实现 AOP 的契机。<br>但，很快会发现，若直接使用Normal forwarding实现 AOP，还是无法降低模块间的耦合，将不相关的逻辑从业务逻辑分离的目的。</p><p>此时，NSProxy 就要『粉墨登场』了。</p><p>NSProxy 或许有点陌生，但从名称能大概知道其主要作用是代理(简单说就是消息转发)。<br><img src="/img/NSProxy.png" alt=""><br>从上图可以看出，NSProxy 的实现非常简单(代码已稍加整理)，也是为数不多的不是继承自 NSObject 的类。之所以要如此设计，原因在于一旦类实现了某个方法，那么在调用该方法时就不会触发消息转发机制，而是直接调用已实现的方法。NSProxy 作为代理类，这样的干扰自然是越少越好。</p><p>在开发过程中，经常有这样的需求，执行某些操作前必须要鉴权(登录)，下面以此为例简单的演示一下：<br><img src="/img/TTAuthenticationProxyh.png" alt=""><br><img src="/img/TTAuthenticationProxym.png" alt=""><br>首先，定义了一个鉴权 proxy，在该类的<code>forwardInvocation:</code>方法中判断当前是否需要鉴权，若不需要鉴权则直接在 target 上执行操作，否则通过鉴权中心<code>TTAuthenticationCenter</code>进行鉴权操作，同时保存当前请求。<br><img src="/img/TTAuthenticationCenter.png" alt=""><br>在<code>TTAuthenticationCenter</code>中，通过 maptable 记录当前需要鉴权的请求(注意：maptable 的 key 使用了<code>NSPointerFunctionsWeakMemory</code>关键字，这样就不会retain target，当 tagret 被 dealloc 时，会自动从 maptable 中清除)<br>在鉴权完成后，即在<code>didAuthentication</code>方法中，依次执行被 hook 的请求。<br><img src="/img/NSObjectAuthentication.png" alt=""><br><img src="/img/testOperate.png" alt=""><br>上图在<code>testOperate</code>方法中要调用<code>operateNeedAuthentication</code>方法，但该方法需要先鉴权，故将该调用直接发送给<code>TTAuthenticationProxy</code>。<br>通过这种方式，完全将鉴权逻辑与业务逻辑隔离，降低模块间的耦合。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>在很多场景下，通过 AOP 可以隔离不相关的逻辑、降低模块间的耦合。通过上文可知，在 Objective-C 中实现 AOP 主要是借助于 runtime，动态的添加新功能，因此有一定的性能损耗，在使用之前需要了解具体的业务场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先简要讨论了 Objective-C 消息传递机制，随后重点讨论了在 Objective-C 中实现 AOP 的三种方式：&lt;em&gt;Method Swizzling&lt;/em&gt;、&lt;em&gt;Aspects&lt;/em&gt;以及&lt;em&gt;Proxy&lt;/em&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>KVO漫谈</title>
    <link href="http://zxfcumtcs.github.io/2015/09/18/KVO/"/>
    <id>http://zxfcumtcs.github.io/2015/09/18/KVO/</id>
    <published>2015-09-18T15:02:28.000Z</published>
    <updated>2018-12-08T08:41:32.858Z</updated>
    
    <content type="html"><![CDATA[<p>本文讨论了 KVO 若干有趣的特性，并将 KVO 与其他通信方式进行了比较，最后深入分析了 KVO 内部实现机制。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>KVO(Key-Value Observing)对于 iOS 开发者来说应该并不陌生。通过 KVO 机制，当被观察对象的属性值发现变化时观察者能接到相应的通知。为了能接收到正确的 KVO 消息，需要满足以下三点：</p><ul><li>被观察对象的相应属性必须是 KVO 兼容；</li><li>通过<code>addObserver:forKeyPath:options:context:</code>方法注册观察者；</li><li>观察者必须实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法。</li></ul><p>那么何为 KVO 兼容的属性？<br>同样需要满足三点：</p><ul><li>相应属性需要是 KVC 兼容；</li><li>相应属性值改变时需要触发 KVO 消息；</li><li>相关的dependent keys设置正确。</li></ul><p>其中，对于 KVC 兼容的属性，NSObject 已支持在属性值变化时自动发送 KVO 消息。当然也可以禁止 NSObject 的该功能，改为由手动实现，此时，只需重载<code>automaticallyNotifiesObserversForKey:</code>方法，对于需要禁止 KVO 的 key 返回 NO 即可。</p><p>关于 KVO 有几个点值得一提：</p><ul><li><p>Dependent Keys：<br>在 KVO 所有特性中，最让我心动的莫过于依赖键(Dependent Keys)，简单地说就是某个属性值可以依赖于其他若干个属性，当任何被依赖的属性值改变时，依赖属性就会触发 KVO 消息。对于To-one Relationships，可以通过<code>keyPathsForValuesAffectingValueForKey:</code>或<code>keyPathsForValuesAffecting&lt;Key&gt;</code>方法注册依赖键。</p></li><li><p>NSKeyValueObservingOptionInitial：<br>我们知道 KVO 的触发时机是被观察的属性值发生变化时，但有时可能需要在初始化时就能通过 KVO 获取被观察属性的值，此时就可以在注册观察者时添加<code>NSKeyValueObservingOptionInitial</code>选项。通过该选项，在调用<code>addObserver:forKeyPath:options:context:</code>方法时会同步触发 KVO 消息。</p></li><li><p>NSKeyValueObservingOptionPrior：<br>正常情况下，是在被观察属性的值改变后通过<code>didChangeValueForKey:</code>方法触发 KVO 消息。若在注册观察者时添加<code>NSKeyValueObservingOptionPrior</code>选项，则在属性值改变前，即在<code>willChangeValueForKey:</code>方法中也会触发一次 KVO 消息。此时，被观察属性值的改变会触发两次 KVO 消息，可以通过<code>change</code>中的<code>NSKeyValueChangeNotificationIsPriorKey</code>进行区分。</p></li><li><p>KVO 消息的同步性：<br>首先，KVO 消息的处理与被观察属性值的改变发生在同一线程上，因此<code>observeValueForKeyPath:ofObject:change:context:</code>方法可能会在不同的线程上执行，需要考虑线程安全问题。其次KVO 消息与被观察属性值的改变是同步的，也就是在被观察属性值的<code>setter</code>方法返回前所有的 KVO 消息都已处理完成。</p></li></ul><p>由于本文的定位不是 KVO 教程，关于<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="noopener">KVO</a>、<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html" target="_blank" rel="noopener">KVC</a>，Apple 官方有详细的描述，在此不再赘述。</p><h1 id="KVO、Notification、delegate、block"><a href="#KVO、Notification、delegate、block" class="headerlink" title="KVO、Notification、delegate、block"></a>KVO、Notification、delegate、block</h1><hr><p>KVO、NSNotfication、delegate、block这四种方式都可以用于对象间的通信。<br>KVO 与 NSNotification 有很多相似之处，都是一对多的、单向的通信方式，通过它们可以使得模块间较好的解耦。同时它们也有许多相似的缺点。<br>delegate、block 则是一对一的、『半双向』的通信方式。之所以说是『半双向』是因为它们可以有返回值。<br><img src="/img/MVC.jpg" alt=""><br>这是斯坦福大学 iOS 开发公开课里关于讲解 MVC 的一页 PPT，很好地总结了 M、V、C 间通信的规则与方式：</p><ul><li>Model 与 View 间不允许直接通信；</li><li>Controller 作为控制中枢，一般持有 Model 与 View 的 object，能直接与它们通信；</li><li>View 可以通过 delegate 与 Controller 通信以及通过将 Controller 设置为 target 响应来自 View 的事件；</li><li>Model 可以通过 KVO 或 Notification向 Controller 发送消息。</li></ul><p>可以看到，为了充分解耦，Model 与 Controller 间的通信有严格的限制，必须是单向的。<br>由于 View 与 Controller 严格要求是一对一的，两者的关系也更加紧密，故其间的通信 delegate 更加适合。</p><p>个人认为，从设计的角度出发，KVO 与 Notification 没有本质的区别。但前面提到 KVO 有个很棒的特性：Dependent Keys。有时，通过 KVO 的Dependent Keys特性能写出很漂亮的代码。</p><p>比如：界面中某个元素 V 的显示依赖于 Model 中 A、B、C、D 四个属性值，当其中任意属性值发生改变时，界面元素 V 的状态都需要变化。<br>如果，此时选用 Notification 的方式由 Modle 通知 Controller 刷新 UI，需要在A、B、C、D 四个属性值发生变化的地方都抛出 Notification，同时需要将4个属性值通过消息传递给 Controller 以便计算 V 的新状态。<br>若采用 KVO 机制，可以在 Model 中合成一个新的属性M，并且使得 M 依赖于 A、B、C、D，再在 Controller 中观察属性 M 即可。</p><h1 id="KVO陷阱"><a href="#KVO陷阱" class="headerlink" title="KVO陷阱"></a>KVO陷阱</h1><hr><p>KVO 本身存在不少争议，也有人为其开出了长长的『罪行』清单。<br>个人认为 KVO 值得我们关注的缺点有：</p><ul><li><p>string 类型的 key：<br>在 KVO 中所有 key path 都是 string 类型，也就意味着无法通过编译器在编译期发现像拼写错误这类的 warning、error；</p></li><li><p>无法指定响应 KVO 的selector：<br>一个类只能集中在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中处理 KVO 消息，而无法像 NSNotification 那样在注册观察者时指定 selector，这就导致如果某个类观察的属性较多时，在该方法中就会出现长长的<code>if...else...</code>；</p></li><li><p>KVO 消息是隐式的(implicit)：<br>一旦 KVO 相关的观察者注册完毕，其余的事情都由 runtime 完成，虽然符合数据单向流通的设计要求，但在实际开发过程中还是有些困扰，尤其是新人接手老项目时，可能无法意识到修改某个属性的值会产生一系列的影响，不便于问题的调试、跟踪。</p></li></ul><p>当然，使用 KVO 还有一些要注意的地方，处理不好可能会 crash、产生意料之外的结果等，这些都属于编码规范一类的，在此不多作讨论。</p><h1 id="KVO背后的故事"><a href="#KVO背后的故事" class="headerlink" title="KVO背后的故事"></a>KVO背后的故事</h1><hr><p>我们知道被观察属性值发生变化时，观察者能自动收到 KVO 消息，这是如何实现的呢？<br>这一切都要归功于 Objective-C 语言的动态 runtime，<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="noopener">mikeash</a>大神对此有过具体分析，在此我们再来梳理一下。<br><img src="/img/printClassInfo.png" alt=""><br><img src="/img/KVO1.png" alt=""><br><img src="/img/KVOResult1.png" alt=""><br>从上述结果我们能得出：</p><ul><li>在某个对象(<code>_observedObject</code>)上添加观察者时，runtime 会为其动态生成一个子类(<code>NSKVONotifying_KVOObserved</code>)，并将被观察对象(<code>_observedObject</code>)的<code>isa</code>指针切换到新生成的子类上；</li><li>在被观察对象(<code>_observedObject</code>)上移除观察者时，其<code>isa</code>指针又会切换回来；</li><li>Apple 君为了隐藏 KVO 的实现细节，在动态生成的子类中重写了<code>class</code>方法，使其返回原有类的信息(当然通过<code>object_getClass</code>获取的<code>isa</code>指针信息是无法隐藏的)。</li></ul><p>我们再来对比一下这两个类都包含了哪些方法(注：printNamesStr只会输出该类自身的方法，不会包含父类的方法)：<br><img src="/img/printNamesStr.png" alt=""><br><img src="/img/printNamesStrResult.png" alt=""></p><p>可以看到在<code>NSKVONotifying_KVOObserved</code>类中重载了<code>setX:</code>、<code>class</code>、<code>dealloc</code>方法，添加了<code>_isKVOA</code>方法。<br>更进一步，我们发现被<code>NSKVONotifying_KVOObserved</code>重载的<code>setX:</code>实际指向全局的：<code>_NSSetLongLongValueAndNotify</code>方法。<br><img src="/img/printIMP.png" alt=""></p><p>针对不同的类型，Apple 实现了以下方法：<br>_NSSetBoolValueAndNotify、_NSSetCharValueAndNotify、_NSSetDoubleValueAndNotify、_NSSetFloatValueAndNotify、_NSSetIntValueAndNotify、_NSSetLongLongValueAndNotify、_NSSetLongValueAndNotify、_NSSetObjectValueAndNotify、_NSSetPointValueAndNotify、_NSSetRangeValueAndNotify、_NSSetRectValueAndNotify、_NSSetShortValueAndNotify、_NSSetSizeValueAndNotify、_NSSetUnsignedCharValueAndNotify、_NSSetUnsignedIntValueAndNotify、_NSSetUnsignedLongLongValueAndNotify、_NSSetUnsignedLongValueAndNotify、_NSSetUnsignedShortValueAndNotify</p><p>这些方法虽没有开源，但其内部实现通过调用栈能所有了解：<br><img src="/img/NSSetLongLongValueAndNotify.png" alt=""><br>在该方法中我们看到了熟悉的<code>willChangeValueForKey:</code>以及<code>didChangeValueForKey:</code>方法的调用。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>KVO 通过 runtime 动态机制实现了自动发送 KVO 消息，但正如前文所说 KVO 也存在不少争议，在使用前需要仔细思考，其是否是最佳选项。</p><p>参考资料：<br><a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="noopener">Friday Q&amp;A 2009-01-23</a><br><a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html" target="_blank" rel="noopener">Key-Value Observing Done Right</a><br><a href="http://nshipster.com/key-value-observing/" target="_blank" rel="noopener">Key-Value Observing</a><br><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="noopener">Key-Value Observing Programming Guide</a><br><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html" target="_blank" rel="noopener">Key-Value Coding Programming Guide</a><br><a href="https://www.objc.io/issues/7-foundation/key-value-coding-and-observing/" target="_blank" rel="noopener">Key-Value Coding and Observing</a><br><a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="noopener">KVO Considered Harmful</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讨论了 KVO 若干有趣的特性，并将 KVO 与其他通信方式进行了比较，最后深入分析了 KVO 内部实现机制。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Inside Memory Management for iOS</title>
    <link href="http://zxfcumtcs.github.io/2015/09/03/MemoryManagement/"/>
    <id>http://zxfcumtcs.github.io/2015/09/03/MemoryManagement/</id>
    <published>2015-09-03T08:28:55.000Z</published>
    <updated>2018-12-08T08:41:32.858Z</updated>
    
    <content type="html"><![CDATA[<p>本文探讨了在 Memory Management 中的命名规则、引用计数的实现机制以及 weak 变量的内部实现。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>Memory Management 在 C 语言体系中一直是个重要的话题，它们没有像 Java 那样的 Garbage Collection，内存管理完全由程序员负责。因此，稍有不慎就会出现 Memory Leak 或 Dangling Pointer 等严重问题，这对于程序来说是致命的！</p><p>Objective-C 作为在 C 语言基础上发展起来的面向对象语言，自身自然也没有内存管理机制。因此，作为 iOS 程序员的我们也需要小心翼翼地处理着内存问题。然而，这一切随着 ARC 的到来有很大的改观。</p><p>由 iOS5 和 Xcode4.2 内置的编译器 LLVM3.0 共同支持的 ARC(Automatic Reference Counting)，如其名称所示实现了内存的自动管理。简单地说，其实质就是将内存管理的工作由程序员转交给编译器来完成，当然某些特性需要 runtime 的支持。</p><h1 id="内存管理中的命名规则"><a href="#内存管理中的命名规则" class="headerlink" title="内存管理中的命名规则"></a>内存管理中的命名规则</h1><hr><p>与 ARC 相比，我们将手动内存管理机制称作 MRC(Mannul Reference Counting)，就像 ARC 与 MRC 名称所展示的那样，两者从内存管理的本质上讲没有区别，都是通过引用计数(Reference Counting)机制管理内存。不同的是，在 ARC 中内存管理相关的代码由编译器在编译代码时自动插入。</p><p>那么问题来了~</p><p>ARC 下编译器如何自动插入内存管理代码？更直白点，编译器如何知道在某处需要插入相关的代码？</p><p>首先，能想到的是在类的 <code>dealloc</code> 方法中，对该类的实例对象所持有的成员变量(strong)执行 release 操作。</p><p>那么，对于局部变量，编译器如何管理内存？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSString *str = [[NSString alloc] initWithFormat:@&quot;test ARC&quot;];</span><br><span class="line">    NSLog(@&quot;%@&quot;, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们知道，在 ARC 下，上面的代码片段会被编译器处理成(仅是示例，编译器最终的处理可能不完全一致)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSString * str = [[NSString alloc] initWithFormat:@&quot;test ARC&quot;];</span><br><span class="line">    NSLog(@&quot;%@&quot;, str);</span><br><span class="line">    [str release];// 编译器插入了 release</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而下面的代码片段，编译器没有为内存管理添加任何代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSString *str = [NSString stringWithFormat:@&quot;test ARC&quot;];</span><br><span class="line">    NSLog(@&quot;%@&quot;, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么编译器在处理上述两段代码时，采取不同的态度？</p><p>答案很明显，代码2返回的是 autorelese 对象，其已被纳入内存管理之中，故不需要编译器再作处理，而代码1却没有。</p><p>嗯，问题似乎已得到完美的解答！<br>然而，这一切都是站在人的角度去分析的，编译器如何知道代码1需要其管理内存，而代码2不需要？</p><p>ok，这就是本节主题：『命名规则』要解决的问题。</p><p>任何以下列名称为前缀的方法，若其返回值为 object，则方法调用者持有该 object：</p><ul><li>alloc</li><li>new</li><li>copy</li><li>mutableCopy</li></ul><p>还有一个更为严格的规则：任何以 init 为前缀的方法必须遵守下列规则：</p><ul><li>该方法必须是实例方法；</li><li>该方法必须返回类型为<code>id</code>或其所属class、superclass、subclass 的对象；</li><li>该方法返回的 object 不能是 autorelese，即方法调用者持有返回的 object。</li></ul><p>『方法调用者持有该 object』也就意味着该 object 的内存问题需要调用方管理。</p><p>在此之外的任何方法返回的 object，其调用方都不持有，即返回的应该是 autorelease object。</p><blockquote><p>例外：以 allocate、newer、copying、mutableCopyed 为前缀的方法以及 initialize 方法不在上述规则之内。</p></blockquote><p>编译器根据上述规则，很容易就能判断出在代码1中需要处理对象<code>str</code>的内存问题，而代码2返回的是 autorelease object，故不需要其处理。</p><p>在编码过程中，应该严格按照上述规则执行！</p><p>那问题来了，如果在编码过程中硬是不遵守上述规则如何？<br>首先，你就被排除在优秀程序员之外了！MRC 时代，不按上述规则写出的代码在内存管理上极难维护，很容易出现内存泄漏或多次释放的问题。<br><img src="/img/MRCAlloc.png" alt=""><br>在 MRC 下，上述代码通过 Analyze 做静态分析时会给出如上图所示的 warning。</p><h2 id="ARC-与-MRC-混用"><a href="#ARC-与-MRC-混用" class="headerlink" title="ARC 与 MRC 混用"></a>ARC 与 MRC 混用</h2><p>由于很多项目经历了 MRC 到 ARC 的时代，因此 ARC 与 MRC 在项目中同时存在的情况大有所在。<br>如果，此时不遵守上述命名规则会出现问题吗？</p><p><img src="/img/MRCAllocString.png" alt=""><br><img src="/img/ARCuseMRC.png" alt=""><br>运行结果：<br><img src="/img/ARCUseMRCCrash.png" alt=""><br>crash!</p><p>原因在于在 ARC 的文件中调用了以 <code>alloc</code> 为前缀的方法，根据命名规则，此时编译器认为 <code>allocString</code> 方法将返回一个需要其管理内存(release)的对象。上述 ARC 的代码将被编译器处理为：<br><img src="/img/ARCPseudoconde.png" alt=""><br>然而，在 MRC 中的<code>allocString</code>方法并未遵守命名规则，其返回的是一个 autorelease object。最终效果就是 release 了一个 autorelease object！这类问题，我们除了知道出问题对象的类型，crash 堆栈没有任何帮助，因此在大型项目中排查此类问题有一定的难度(工作量)。<br><img src="/img/CrashStack.png" alt=""><br>那么，在 ARC 的文件中不遵守命名规则会出问题吗？<br><img src="/img/ARCAllocString.png" alt=""><br>这段代码运行正常没有 crash，原因在于 <code>allocString</code> 方法本身及调用者都在 ARC 管理范畴之类，编译器很清楚该如何处理。即便如此，作为优秀的程序员，在日常 coding 过程中还是应该遵守命名规则。</p><h1 id="Inside-Reference-Counting"><a href="#Inside-Reference-Counting" class="headerlink" title="Inside Reference Counting"></a>Inside Reference Counting</h1><hr><p>前文已提到，无论是 ARC 还是 MRC，其本质都是通过引用计数(Reference Counting)来管理内存。</p><p>如果让你设计一套引用计数机制，你会怎么做？<br>嗯，这是个不错的面试题！<br>其实，该问题的答案不外乎两种：</p><ul><li>在对象内部管理引用计数；</li><li>通过外部结构(如：hash 表)统一管理引用计数。</li></ul><h2 id="GNUstep’s-Implementation-of-Reference-Counting"><a href="#GNUstep’s-Implementation-of-Reference-Counting" class="headerlink" title="GNUstep’s Implementation of Reference Counting"></a>GNUstep’s Implementation of Reference Counting</h2><p>GUNstep 实现了一套兼容 Cocoa Framework 的 Framework，作为开源代码我们来看看它是如何处理引用计数的：<br><img src="/img/GNUstepReferenceCounting.png" alt=""><br>通过整理，删除非必要的代码，GUNstep 实现的<code>alloc</code>方法如上所示。可以看到，其使用了一个结构体<code>obj_layout</code>来保存引用计数，同时该结构体被附在所生成 object 的头部。<br>object内存布局如下图所示(引自《Objective-C高级编程》)：<br><img src="/img/GNUstepObjectMemory.png" alt=""></p><h2 id="Apple’s-Implementation-of-Reference-Counting"><a href="#Apple’s-Implementation-of-Reference-Counting" class="headerlink" title="Apple’s Implementation of Reference Counting"></a>Apple’s Implementation of Reference Counting</h2><p>由于 Apple 现已来源了相关的代码，使得我们可以进一步一探究竟。Apple 所有的来源代码都可以在此找到：<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">Apple Opensource</a>。</p><p>首先，我们来看看 Apple 是如何实现 <code>retain</code> 方法的：<br><img src="/img/AppleRetain.png" alt=""><br>如果抛开 Apple 所做的优化，其<code>retain</code>方法最终会调用上图所示的<code>sidetable_retain</code>方法。</p><p>在继续之前有必要介绍一下新朋友：<code>SideTable</code><br><img src="/img/SideTable.png" alt=""><br>在类<code>SideTable</code>的成员变量中，似乎看到了熟悉的味道！是的，没错，其中的 <code>RefcountMap</code> 就是引用计数表，而<code>weak_table_t</code>则是弱引用表(weak table).</p><p>RefcountMap 则是一个简单的 map，其 key 为 object 内存地址，value 为引用计数值。</p><p>通过<code>SideTable</code>源码，还可以得出如下结论：</p><ul><li>存在全局的若干个<code>SideTable</code>实例，它们保存在 static 成员变量<code>table_buf</code>中；[在 iOS 平台上有8个这样的实例(SIDE_TABLE_STRIPE = 8)]</li><li>程序运行过程中生成的所有对象都会通过其内存地址映射到<code>table_buf</code>中相应的<code>SideTable</code>实例上。</li></ul><p>这里之所以会存在多个<code>SideTable</code>实例，object 映射到不同<code>SideTable</code>实例上，猜测是出于性能优化的目的，避免<code>SideTable</code>中的 reference table、weak table 过大。</p><p>回到上面的<code>sidetable_retain</code>方法，其首先通过 object 的地址找到对应的 sidetale，然后通过 <code>RefcountMap</code>将该 object 的引用计数加1.</p><p><code>release</code>、<code>retainCount</code>等相关方法的代码在该开源代码中也能找到，在此不再赘述。</p><p>简单地说，Apple 通过全局的 map 来记录Reference Counting，其key 为 object 地址，value 为引用计数值。</p><p>那么，GNUstep 与 Apple 的实现方案各有什么优劣点？<br>GNUstep 的方案从实现的角度看简单明了，而 Apple 的方案能够更好的把控系统内存使用情况，对调试有一定的帮助。</p><h1 id="Inside-Weak"><a href="#Inside-Weak" class="headerlink" title="Inside Weak"></a>Inside Weak</h1><hr><p>weak 无疑是 ARC 送给我们的一大利器，通过它基本能消灭 delegate 引起的 dangling pointer 问题。这得益于 weak 指针指向的 object 在 dealloc 时，该指针会被置为 nil。<br>那么，系统是如何处理 weak 变量的呢？<br><img src="/img/weak.png" alt=""><br>上面这个简单的代码片段会被编译器处理成如下所示的 pseudo code：<br><img src="/img/weakpseudocode.png" alt=""><br>注：以下代码已经过整理以便阅读、抓住重点。</p><p>通过上述代码可以看到，对于 weak 变量，系统将以 weak 指针变量的地址(&amp;weakNum)、用于赋值的 object(num)为参数调用<code>objc_initWeak</code>方法：<br><img src="/img/objc_initWeak.png" alt=""><br><code>objc_initWeak</code>方法进一步调用<code>objc_storeWeak</code>方法，在该方法中，以赋值object(num)对应的 sidetable 中的 weaktable、赋值object(num)以及 weak 变量的指针为参数调用<code>weak_register_no_lock</code>方法。<br>在<code>objc_storeWeak</code>方法中，还可以看到，对于 weak 引用会在赋值object的引用计数表中设置弱引用标志位(SIDE_TABLE_WEAKLY_REFERENCED)，具体原因有待深究。<br>当然，在<code>objc_storeWeak</code>方法中做的最后一件事情就是将赋值对象的地址赋给 weak 指针。<br><img src="/img/objc_storeWeak.png" alt=""><br><code>weak_register_no_lock</code>方法首先检查赋值object在 weak table 中是否存在相应的条目，若存在则直接在其中添加该 weak 变量的信息，若不存在则插入赋值 object 对应的条目。<br><img src="/img/weak_register_no_lock.png" alt=""></p><h2 id="weaktable"><a href="#weaktable" class="headerlink" title="weaktable"></a>weaktable</h2><p>谈到 weak，自然少不了要说到 weaktable：<br><img src="/img/weaktable.png" alt=""><br><img src="/img/weak_entry_t.png" alt=""></p><p>在 weaktable 中，最重要的成员莫过于<code>weak_entry_t</code>类型的数组:weak_entries。在<code>weak_entry_t</code>结构体中，包含赋值 object 的指针以及所有指向该赋值 object 的 weak 变量列表(weak_referrer_t *referrers)。</p><p>那么，在 weaktable 中如何通过object 找到其对应的 entry？<br><img src="/img/weak_entry_for_referent.png" alt=""></p><p>最后一个问题，在 weak 指针所指向的 object 被 dealloc 时，weak 指针会被置为 nil。那么问题来了，如果 weak 变量的生命周期在其指向的 object 之前就结束了，会如何？</p><p>若在 weak 变量生命周期结束后，其所使用的内存块被重新利用赋上了新值，而此时上述 object 被 dealloc，若根据 weak table 中的条目将其对应的 weak 变量一一置为 nil，则上述被重新利用的变量也将被清0，这显然是不合适的。</p><p>在上面提到的 pseudo code 中，我们看到在 weak 变量 <code>weakNum</code> 生命周期结束时，调用了<code>objc_destroyWeak</code>方法，没错，该方法就是用于解决上述问题的。<br><code>objc_destroyWeak</code>方法最终会调用<code>weak_unregister_no_lock</code>方法，其会将 weak 变量从 weak table 中移除掉。<br><img src="/img/weak_unregister_no_lock.png" alt=""></p><h1 id="Toll-Free-Bridge-cast"><a href="#Toll-Free-Bridge-cast" class="headerlink" title="Toll-Free Bridge cast"></a>Toll-Free Bridge cast</h1><hr><h2 id="bridge-cast"><a href="#bridge-cast" class="headerlink" title="__bridge cast"></a>__bridge cast</h2><p>在 ARC 下，id 与 <code>void*</code>之间不再像 MRC 时代可以任意转换，在 ARC 下若需在两者之间转换可以使用<code>__bridge cast</code>。<br>在使用时需注意，在将 id 转换为 <code>void*</code>时，其不再在 ARC 的内存管理范畴内，极有可能出现dangling pointer。</p><h2 id="bridge-retained-cast"><a href="#bridge-retained-cast" class="headerlink" title="__bridge_retained cast"></a>__bridge_retained cast</h2><p>__bridge_retained的作用是使得被赋值变量持有赋值 object。<br><img src="/img/bridge_retainedARC.png" alt=""><br>上述 ARC 代码与下面的 MRC 代码在内存管理上是等价的<br><img src="/img/bridge_retainedMRC.png" alt=""></p><h2 id="bridge-transfer-cast"><a href="#bridge-transfer-cast" class="headerlink" title="__bridge_transfer cast"></a>__bridge_transfer cast</h2><p><strong>bridge_transfer的作用是使得赋值 object 在赋值后被 release。<br><img src="/img/bridge_transferARC.png" alt=""><br><img src="/img/bridge_transferMRC.png" alt=""><br>上面两段代码是等价的，正如</strong>bridge_transfer名称所示，其作用是将持有权从赋值 object 转到被赋值变量。</p><p>在 ARC 下，需要转换的情况发生在Objective-C object 与 Core Foundation object 间，此时可以使用以下方法：<br><img src="/img/CFBridgingRetainRelease.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>关于内存管理有很多的问题值得探讨，随着 Apple 相关代码的开源，一切的私密都能在源码中找到答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文探讨了在 Memory Management 中的命名规则、引用计数的实现机制以及 weak 变量的内部实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
