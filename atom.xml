<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雪峰的blog</title>
  <icon>https://www.gravatar.com/avatar/00bbf828835d0686e9010b2a2e951bdd</icon>
  <subtitle>善于总结, 乐于分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zxfcumtcs.github.io/"/>
  <updated>2020-05-16T13:40:06.628Z</updated>
  <id>http://zxfcumtcs.github.io/</id>
  
  <author>
    <name>赵雪峰</name>
    <email>zxfcumtcs@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入浅出 Flutter Framework 之 Element</title>
    <link href="http://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/"/>
    <id>http://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/</id>
    <published>2020-05-17T02:08:21.000Z</published>
    <updated>2020-05-16T13:40:06.628Z</updated>
    
    <content type="html"><![CDATA[<p>本文是『 深入浅出 Flutter Framework 』系列文章的第三篇，主要围绕 Element 相关内容进行分析介绍，包括 Element 分类、Element 与其他几个核心元素的关系、Element 生命周期以及核心方法解读等。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><p>本系列文章将深入 Flutter Framework 内部逐步去分析其核心概念和流程，主要包括：<br><a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">『 深入浅出 Flutter Framework 之 Widget 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">『 深入浅出 Flutter Framework 之 BuildOwner 』</a><br>『 深入浅出 Flutter Framework 之 Element 』<br>『 深入浅出 Flutter Framework 之 PipelineOwner 』<br>『 深入浅出 Flutter Framework 之 RenderObejct 』<br>『 深入浅出 Flutter Framework 之 Layer 』<br>『 深入浅出 Flutter Framework 之 Binding 』<br>『 深入浅出 Flutter Framework 之 Rendering Pipeline 』<br>『 深入浅出 Flutter Framework 之 自定义 Widget 』</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>通过<a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">『 深入浅出 Flutter Framework 之 Widget 』</a>的介绍，我们知道 Widget 本质上是 UI 的配置数据 (静态、不可变)，Element 则是通过 Widget 生成的『实例』，两者间的关系就像是 json 与 object。</p><blockquote><p>同一份配置 (Widget) 可以生成多个实例 (Element)，这些实例可能会被安插在树上不同的位置。</p></blockquote><p>UI 的层级结构在 Element 间形成一棵真实存在的树「Element Tree」，Element 有 2 个主要职责：</p><ul><li>根据 UI (「Widget Tree」) 的变化来维护「Element Tree」，包括：节点的插入、更新、删除、移动等；</li><li>Widget 与 RenderObject 间的协调者。</li></ul><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><hr><p><img src="/img/Element.png" alt=""><br>如图所示，Element 根据特点可以分为 2 类：</p><ul><li><em>「Component Element」</em> —— 组合型 Element，「Component Widget」、「Proxy Widget」对应的 Element 都属于这一类型，其特点是子节点对应的 Widget 需要通过<code>build</code>方法去创建。同时，该类型 Element 都只有一个子节点 (single child)；</li><li><em>「Renderer Element」</em> —— 渲染型 Element，对应「Renderer Widget」，其不同的子类型包含的子节点个数也不一样，如：LeafRenderObjectElement 没有子节点，RootRenderObjectElement、SingleChildRenderObjectElement 有一个子节点，MultiChildRenderObjectElement 有多个子节点。<blockquote><p>原生型 Element，只有 MultiChildRenderObjectElement 是多子节点的，其他都是单子节点。</p></blockquote></li></ul><p>同时，可以看到，<code>Element</code>实现了<code>BuildContext</code>接口 —— 我们在 Widget 中遇到的<code>context</code>，其实就是该 Widget 对应的 Element。</p><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><hr><p>在继续之前有必要先了解一下 Element 与其他几个核心元素间的关系，以便在全局上有个认识。<br><img src="/img/Element_Relationship.png" alt=""></p><p>如图：</p><ul><li>Element 通过 parent、child 指针形成「Element Tree」；</li><li>Element 持有 Widget、「Render Object」；</li><li>State 是绑定在 Element 上的，而不是绑在「Stateful Widget」上(这点很重要)。<blockquote><p>上述这些关系并不是所有类型的 Element 都有，如：「Render Object」只有「RenderObject Element」才有，State 只有「Stateful Element」才有。</p></blockquote></li></ul><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><hr><p>Element 作为『实例』，随着 UI 的变化，有较复杂的生命周期：</p><ul><li><p>parent 通过<code>Element.inflateWidget</code>-&gt;<code>Widget.createElement</code>创建 child element，触发场景有：UI 的初次创建、UI 刷新时新老 Widget 不匹配(old element 被移除，new element 被插入)；</p></li><li><p>parent 通过<code>Element.mount</code>将新创建的 child 插入「Element Tree」中指定的插槽处 (slot);</p><blockquote><p><code>dynamic Element.slot</code>——其含意对子节点透明，父节点用于确定其下子节点的排列顺序 (兄弟节点间的排序)。因此，对于单子节点的节点 (single child)，child.slot 通常为 null。<br>另外，slot 的类型是动态的，不同类型的 Element 可能会使用不同类型的 slot，如：Sliver 系列使用的是 int 型的 index，MultiChildRenderObjectElement 用兄弟节点作为后一个节点的 slot。<br>对于「component element」，<code>mount</code>方法还要负责所有子节点的 build (这是一个递归的过程)，对于「render element」，<code>mount</code>方法需要负责将「render object」添加到「render tree」上。其过程在介绍到相应类型的 Element 时会详情分析。</p></blockquote></li><li><p>此时，(child) element 处于 <strong>active</strong> 状态，其内容随时可能显示在屏幕上；</p></li><li><p>此后，由于状态更新、UI 结构变化等，element 所在位置对应的 Widget 可能发生了变化，此时 parent 会调用<code>Element.update</code>去更新子节点，update 操作会在以当前节点为根节点的子树上递归进行，直到叶子节点；(执行该步骤的前提是新老 Widget.[key &amp;&amp; runtimeType] 相等，否则创建新 element，而不是更新现有 element)；</p></li><li><p>状态更新时，element 也可能会被移除 (如：新老 Widget.[key || runtimeType] 不相等)，此时，parent 将调用<code>deactivateChild</code>方法，该方法主要做了 3 件事：</p><ul><li>从「Element Tree」中移除该 element (将 parent 置为 null)；</li><li>将相应的「render object」从「render tree」上移除；</li><li>将 element 添加到<code>owner._inactiveElements</code>中，在添加过程中会对『以该 element 为根节点的子树上所有节点』调用<code>deactivate</code>方法 (移除的是整棵子树)。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> deactivateChild(<span class="built_in">Element</span> child) &#123;</span><br><span class="line">  child._parent = <span class="keyword">null</span>;</span><br><span class="line">  child.detachRenderObject();</span><br><span class="line">  owner._inactiveElements.add(child); <span class="comment">// this eventually calls child.deactivate()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>此时，element 处于 “inactive” 状态，并从屏幕上消失，该状态一直持续到当前帧动画结束；</p></li><li><p>从 element 进入 “inactive” 状态到当前帧动画结束期间，其还有被『抢救』的机会，前提是『带有「global key」&amp;&amp; 被重新插入树中』，此时：</p><ul><li>该 element 将会从<code>owner._inactiveElements</code>中移除；</li><li>对该 element subtree 上所有节点调用<code>activate</code>方法 (它们又复活了！)；</li><li>将相应的「render object」重新插入「render tree」中；</li><li>该 element subtree 又进入 “active” 状态，并将再次出现在屏幕上。<blockquote><p>上述过程经历这几个方法：<code>Parent Element.inflateWidget</code>–&gt;<code>Parent Element._retakeInactiveElement</code>–&gt;<code>BuildOwner._inactiveElements.remove</code>–&gt;<code>Child Element._activateWithParent</code>…</p></blockquote></li></ul></li><li><p>对于所有在当前帧动画结束时未能成功『抢救』回来的「Inactive Elements」都将被 unmount；</p></li><li>至此，element 生命周期圆满结束。<br><img src="/img/Element_Lifecycle.jpg" alt=""></li></ul><h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><hr><p>下面对 Element 中的几个核心方法进行简单介绍：</p><h2 id="updateChild"><a href="#updateChild" class="headerlink" title="updateChild"></a>updateChild</h2><p><code>updateChild</code>是 flutter framework 中的核心方法之一：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span> updateChild(<span class="built_in">Element</span> child, Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">      deactivateChild(child);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.widget == newWidget) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">        updateSlotForChild(child, newSlot);</span><br><span class="line">      <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">        updateSlotForChild(child, newSlot);</span><br><span class="line">      child.update(newWidget);</span><br><span class="line">      <span class="keyword">assert</span>(child.widget == newWidget);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deactivateChild(child);</span><br><span class="line">    <span class="keyword">assert</span>(child._parent == <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> inflateWidget(newWidget, newSlot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在「Element Tree」上，<strong>父节点通过该方法来修改子节点对应的 Widget</strong>。<br><img src="/img/updateChild.jpg" alt=""></p><p>根据传入参数的不同，有以下几种不同的行为：</p><ul><li><code>newWidget</code> == <code>null</code> —— 说明子节点对应的 Widget 已被移除，直接 remove child element (如有)；</li><li><code>child</code> == <code>null</code> —— 说明 newWidget 是新插入的，创建子节点 (inflateWidget)；</li><li><code>child</code> != <code>null</code> —— 此时，分为 3 种情况：<ul><li>若 child.widget == newWidget，说明 child.widget 前后没有变化，若 child.slot != newSlot 表明子节点在兄弟结点间移动了位置，通过<code>updateSlotForChild</code>修改 child.slot 即可；</li><li>通过<code>Widget.canUpdate</code>判断是否可以用 newWidget 修改 child element，若可以，则调用<code>update</code>方法；</li><li>否则先将 child element 移除，并通 newWidget 创建新的 element 子节点。</li></ul></li></ul><blockquote><p>子类一般不需要重写该方法，该方法有点类似设计模式中的『模板方法』。</p></blockquote><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>在更新流程中，若新老 Widget.[runtimeType &amp;&amp; key] 相等，则会走到该方法。<br>子类需要重写该方法以处理具体的更新逻辑：</p><h3 id="Element-基类"><a href="#Element-基类" class="headerlink" title="Element 基类"></a>Element 基类</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@mustCallSuper</span></span><br><span class="line"><span class="keyword">void</span> update(covariant Widget newWidget) &#123;</span><br><span class="line">  _widget = newWidget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类中的<code>update</code>很简单，只是对<code>_widget</code>赋值。</p><blockquote><p>子类重写该方法时必须调用 super.</p></blockquote><h3 id="StatelessElement"><a href="#StatelessElement" class="headerlink" title="StatelessElement"></a>StatelessElement</h3><blockquote><p>父类<code>ComponentElement</code>没有重写该方法</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(StatelessWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  rebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>rebuild</code>方法触发重建 child widget (第 4 行)，并以此来 update child element，期间会调用到<code>StatelessWidget.build</code>方法 (也就是我们写的 Flutter 代码)。</p><blockquote><p>组合型 Element 都会在<code>update</code>方法中触发<code>rebuild</code>操作，以便重新 build child widget。</p></blockquote><h3 id="StatefulElement"><a href="#StatefulElement" class="headerlink" title="StatefulElement"></a>StatefulElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(StatefulWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  <span class="keyword">final</span> StatefulWidget oldWidget = _state._widget;</span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  _state._widget = widget;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _state.didUpdateWidget(oldWidget) <span class="keyword">as</span> <span class="keyword">dynamic</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  rebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比<code>StatelessElement</code>，<code>StatefulElement.update</code>稍微复杂一些，需要处理<code>State</code>，如：</p><ul><li>修改 State 的 <code>_widget</code>属性；</li><li>调用<code>State.didUpdateWidget</code> (熟悉么)。</li></ul><p>最后，同样会触发<code>rebuild</code>操作，期间会调用到<code>State.build</code>方法。</p><h3 id="ProxyElement"><a href="#ProxyElement" class="headerlink" title="ProxyElement"></a>ProxyElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(ProxyWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">final</span> ProxyWidget oldWidget = widget;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  updated(oldWidget);</span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  rebuild();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> updated(covariant ProxyWidget oldWidget) &#123;</span><br><span class="line">  notifyClients(oldWidget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget build() =&gt; widget.child;</span><br></pre></td></tr></table></figure><p><code>ProxyElement.update</code>方法需要关注的是对<code>updated</code>的调用，其主要用于通知关联对象 Widget 有更新。<br>具体通知逻辑在子类中处理，如：<code>InheritedElement</code>会触发所有依赖者 rebuild (对于 StatefulElement 类型的依赖者，会调用<code>State.didChangeDependencies</code>)。</p><p>ProxyElement 的<code>build</code>操作很简单：直接返回<code>widget.child</code>。</p><h3 id="RenderObjectElement"><a href="#RenderObjectElement" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(covariant RenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RenderObjectElement.update</code>方法调用了<code>widget.updateRenderObject</code>来更新「Render Object」(熟悉么)。</p><h3 id="SingleChildRenderObjectElement"><a href="#SingleChildRenderObjectElement" class="headerlink" title="SingleChildRenderObjectElement"></a>SingleChildRenderObjectElement</h3><blockquote><p><code>SingleChildRenderObjectElement</code>、<code>MultiChildRenderObjectElement</code>是<code>RenderObjectElement</code>的子类。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(SingleChildRenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  _child = updateChild(_child, widget.child, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 3 行，通过<code>newWidget.child</code>调用<code>updateChild</code>方法递归修改子节点。</p><h3 id="MultiChildRenderObjectElement"><a href="#MultiChildRenderObjectElement" class="headerlink" title="MultiChildRenderObjectElement"></a>MultiChildRenderObjectElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(MultiChildRenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  _children = updateChildren(_children, widget.children, forgottenChildren: _forgottenChildren);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现看似简单，实则非常复杂，在<code>updateChildren</code>方法中处理了子节点的插入、移动、更新、删除等所有情况。</p><h2 id="inflateWidget"><a href="#inflateWidget" class="headerlink" title="inflateWidget"></a>inflateWidget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">final</span> Key key = newWidget.key;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = _retakeInactiveElement(key, newWidget);</span><br><span class="line">    <span class="keyword">if</span> (newChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">      newChild._activateWithParent(<span class="keyword">this</span>, newSlot);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Element</span> updatedChild = updateChild(newChild, newWidget, newSlot);</span><br><span class="line">      <span class="keyword">return</span> updatedChild;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</span><br><span class="line">  newChild.mount(<span class="keyword">this</span>, newSlot);</span><br><span class="line">  <span class="keyword">return</span> newChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>inflateWidget</code> 属于模板方法，故一般情况下子类不用重写。</p></blockquote><p>该方法的主要职责：通过 Widget 创建对应的 Element，并将其挂载 (mount) 到「Element Tree」上。</p><blockquote><p>如果 Widget 带有 GlobalKey，首先在 Inactive Elements 列表中查找是否有处于 inactive 状态的节点 (即刚从树上移除)，如找到就直接复活该节点。</p></blockquote><p>主要调用路径来自上面介绍的<code>updateChild</code>方法。</p><h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>当 Element 第一次被插入「Element Tree」上时，调用该方法。由于此时 parent 已确定，故在该方法中可以做依赖 parent 的初始化操作。经过该方法后，element 的状态从 “initial” 转到了 “active”。</p><h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@mustCallSuper</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  _parent = parent;</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _depth = _parent != <span class="keyword">null</span> ? _parent.depth + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  _active = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) <span class="comment">// Only assign ownership if the parent is non-null</span></span><br><span class="line">    _owner = parent.owner;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (widget.key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">    <span class="keyword">final</span> GlobalKey key = widget.key;</span><br><span class="line">    key._register(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _updateInheritance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得<code>BuildOwner</code>吗，正是在该方法中父节点的 owner 传给了子节点。<br>如果，对应的 Widget 带有 GlobalKey，进行相关的注册。<br>最后，继承来自父节点的「Inherited Widgets」。</p><blockquote><p>子类重写该方法时，必须调用 super。<br>关于「Inherited Widgets」，后文会详细分析</p></blockquote><h3 id="ComponentElement"><a href="#ComponentElement" class="headerlink" title="ComponentElement"></a>ComponentElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _firstBuild();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _firstBuild() &#123;</span><br><span class="line">  rebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合型 Element 在挂载时会执行<code>_firstBuild-&gt;rebuild</code>操作。</p><h3 id="RenderObjectElement-1"><a href="#RenderObjectElement-1" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>RenderObjectElement.mount</code>中做的最重要的事就是通过 Widget 创建了「Render Object」(第 3 行)，并将其插入到「RenderObject Tree」上 (第 4 行)。</p><h3 id="SingleChildRenderObjectElement-1"><a href="#SingleChildRenderObjectElement-1" class="headerlink" title="SingleChildRenderObjectElement"></a>SingleChildRenderObjectElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _child = updateChild(_child, widget.child, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SingleChildRenderObjectElement</code>在 super (<code>RenderObjectElement</code>) 的基础上，调用<code>updateChild</code>方法处理子节点，其实此时<code>_child</code>为<code>nil</code>，前面介绍过当 child 为<code>nil</code>时，<code>updateChild</code>会调用<code>inflateWidget</code>方法创建 Element 实例。</p><h3 id="MultiChildRenderObjectElement-1"><a href="#MultiChildRenderObjectElement-1" class="headerlink" title="MultiChildRenderObjectElement"></a>MultiChildRenderObjectElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _children = <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt;(widget.children.length);</span><br><span class="line">  <span class="built_in">Element</span> previousChild;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _children.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = inflateWidget(widget.children[i], previousChild);</span><br><span class="line">    _children[i] = newChild;</span><br><span class="line">    previousChild = newChild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MultiChildRenderObjectElement</code>在 super (<code>RenderObjectElement</code>) 的基础上，对每个子节点直接调用<code>inflateWidget</code>方法。</p><h2 id="markNeedsBuild"><a href="#markNeedsBuild" class="headerlink" title="markNeedsBuild"></a>markNeedsBuild</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_active)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dirty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  owner.scheduleBuildFor(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>markNeedsBuild</code>方法其实在介绍<a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">BuildOwer</a>时已经分析过，其作用就是将当前 Element 加入<code>_dirtyElements</code>中，以便在下一帧可以rebuild。<br>那么，哪些场景会调用<code>markNeedsBuild</code>呢？</p><ul><li><code>State.setState</code> —— 这个在介绍 <a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">Widget</a> 时已分析过了；</li><li><code>Element.reassemble</code> —— debug hot reload；</li><li><code>Element.didChangeDependencies</code> —— 前面介绍过当依赖的「Inherited Widget」有变化时会导致依赖者 rebuild，就是从这里触发的；</li><li><code>StatefulElement.activate</code> —— 还记得<code>activate</code>吗？前文介绍过当 Element 从 “inactive” 到 “active” 时，会调用该方法。为什么<code>StatefulElement</code>要重写<code>activate</code>？因为<code>StatefulElement</code>有附带的 State，需要给它一个<code>activate</code>的机会。</li></ul><blockquote><p>子类一般不必重写该方法。</p></blockquote><h2 id="rebuild"><a href="#rebuild" class="headerlink" title="rebuild"></a>rebuild</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_active || !_dirty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  performRebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法逻辑非常简单，对于活跃的、脏节点调用<code>performRebuild</code>，在 3 种场景下被调用：</p><ul><li>对于 dirty element，在新一帧绘制过程中由<code>BuildOwner.buildScope</code>；</li><li>在 element 挂载时，由<code>Element.mount</code>调用；</li><li>在<code>update</code>方法内被调用。</li></ul><blockquote><p>上述第 2、3 点仅「Component Element」需要</p></blockquote><h2 id="performRebuild"><a href="#performRebuild" class="headerlink" title="performRebuild"></a>performRebuild</h2><p>Element 基类中该方法是<code>no-op</code>。</p><h3 id="ComponentElement-1"><a href="#ComponentElement-1" class="headerlink" title="ComponentElement"></a>ComponentElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">  Widget built;</span><br><span class="line">  built = build();</span><br><span class="line"></span><br><span class="line">  _child = updateChild(_child, built, slot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于组合型 Element，rebuild 过程其实就是调用<code>build</code>方法生成「child widget」，再由其更新「child element」。</p><blockquote><p>StatelessElement.build: <code>Widget build() =&gt; widget.build(this);</code><br>StatefulElement.build: <code>Widget build() =&gt; state.build(this);</code><br>ProxyElement.build: <code>Widget build() =&gt; widget.child;</code></p></blockquote><h3 id="RenderObjectElement-2"><a href="#RenderObjectElement-2" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">  widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在渲染型 Element 基类中只是用 Widget 更新了对应的「Render Object」。<br>在相关子类中可以执行更具体的逻辑。</p><h2 id="生命周期视角"><a href="#生命周期视角" class="headerlink" title="生命周期视角"></a>生命周期视角</h2><p>至此，Element 的核心方法基本已介绍完，是不是有点晕乎乎的感觉？<code>inflateWidget</code>、<code>updateChild</code>、<code>update</code>、<code>mount</code>、<code>rebuild</code>以及<code>performRebuild</code>等你中有我、我中有你，再加上不同类型的子类对这些方法的重写。</p><p>下面，我们以 Element 生命周期为切入点将这些方法串起来。<br>对于一个 Element 节点来说在其生命周期内可能会历经几次『重大事件』：</p><ul><li><p>被创建 —— 起源于父节点调用<code>inflateWidget</code>，随之被挂载到「Element Tree」上， 此后递归创建子节点；<br><img src="/img/element0to1.jpg" alt=""></p></li><li><p>被更新 —— 由「Element Tree」上祖先节点递归传递下来的更新操作，<code>parent.updateChild</code>-&gt;<code>child.update</code>；<br><img src="/img/element1to1.1.jpg" alt=""></p></li><li><p>被重建 —— 被调用<code>rebuild</code>方法(调用场景上面已分析)；<br><img src="/img/element1ton.jpg" alt=""></p></li><li><p>被销毁 —— element 节点所在的子树随着 UI 的变化被移除。<br><img src="/img/element-deactivate.jpg" alt=""></p></li></ul><h1 id="依赖-Dependencies"><a href="#依赖-Dependencies" class="headerlink" title="依赖 (Dependencies)"></a>依赖 (Dependencies)</h1><hr><p>在 Element 基类中有这样两个成员：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, InheritedElement&gt; _inheritedWidgets;</span><br><span class="line"><span class="built_in">Set</span>&lt;InheritedElement&gt; _dependencies;</span><br></pre></td></tr></table></figure></p><p>它们是干嘛用的呢？</p><ul><li><code>_inheritedWidgets</code> —— 用于收集从「Element Tree」根节点到当前节点路径上所有的「Inherited Elements」；<br>前文提到过在<code>mount</code>方法结束处会调用<code>_updateInheritance</code>：<br>以下是 Element 基类的实现，可以看到子节点直接获得父节点的<code>_inheritedWidgets</code>：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">  _inheritedWidgets = _parent?._inheritedWidgets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以下是<code>InheritedElement</code>类的实现，其在父节点的基础上将自己加入到<code>_inheritedWidgets</code>中，以便其子孙节点的<code>_inheritedWidgets</code>包含它 (第 8 行)：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, InheritedElement&gt; incomingWidgets = _parent?._inheritedWidgets;</span><br><span class="line">  <span class="keyword">if</span> (incomingWidgets != <span class="keyword">null</span>)</span><br><span class="line">    _inheritedWidgets = HashMap&lt;<span class="built_in">Type</span>, InheritedElement&gt;.from(incomingWidgets);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    _inheritedWidgets = HashMap&lt;<span class="built_in">Type</span>, InheritedElement&gt;();</span><br><span class="line"></span><br><span class="line">  _inheritedWidgets[widget.runtimeType] = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>_dependencies</code> —— 用于记录当前节点依赖了哪些「Inherited Elements」，通常我们调用<code>context.dependOnInheritedWidgetOfExactType&lt;T&gt;</code>时就会在当前节点与目标 Inherited 节点间形成依赖关系。<blockquote><p>在 Element 上提供的便利方法<code>of</code>，一般殾会调用<code>dependOnInheritedWidgetOfExactType</code>。</p></blockquote></li></ul><p>同时，在<code>InheritedElement</code>中还有用于记录所有依赖于它的节点：<code>final Map&lt;Element, Object&gt; _dependents</code>。<br>最终，在「Inherited Element」发生变化，需要通知依赖者时，会利用依赖者的<code>_dependencies</code>信息做一下 (debug) check (第 4 行)：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> notifyClients(InheritedWidget oldWidget) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">Element</span> dependent <span class="keyword">in</span> _dependents.keys) &#123;</span><br><span class="line">    <span class="comment">// check that it really depends on us</span></span><br><span class="line">    <span class="keyword">assert</span>(dependent._dependencies.contains(<span class="keyword">this</span>));</span><br><span class="line">    notifyDependent(oldWidget, dependent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至此，Element 相关的内容基本已介绍完。总结提炼一下：</p><ul><li>Element 与 Widget 一一对应，它们间的关系就像 object 与 json；</li><li>只有「Render Element」才有对应的「Render Object」；</li><li>Element 作为 Widget 与 RenderObejct 间协调者，会根据 UI(「Widget Tree」) 的变化对「Element Tree」作出相应的调整，同时对「RenderObject Tree」进行必要的修改；</li><li>Widget 是不可变的、无状态的，而 Element 是有状态的。</li></ul><p>最后，强烈推荐<a href="https://medium.com/flutter/keys-what-are-they-good-for-13cb51742e7d" target="_blank" rel="noopener">Keys! What are they good for?</a>这篇文章，对于理解本文相关的内容有很大的帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是『 深入浅出 Flutter Framework 』系列文章的第三篇，主要围绕 Element 相关内容进行分析介绍，包括 Element 分类、Element 与其他几个核心元素的关系、Element 生命周期以及核心方法解读等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://zxfcumtcs.github.io/tags/flutter/"/>
    
      <category term="移动开发" scheme="http://zxfcumtcs.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨平台" scheme="http://zxfcumtcs.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Flutter Framework 之 BuildOwner</title>
    <link href="http://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/"/>
    <id>http://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/</id>
    <published>2020-05-16T07:39:12.000Z</published>
    <updated>2020-05-16T13:38:33.463Z</updated>
    
    <content type="html"><![CDATA[<p>本文是『 深入浅出 Flutter Framework 』系列文章的第二篇，对 BuildOwer 相关内容进行简要地分析介绍，为下一篇文章介绍 Element 作准备 (由于篇幅原因将其单独提出来)。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><p>本系列文章将深入 Flutter Framework 内部逐步去分析其核心概念和流程，主要包括：<br><a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">『 深入浅出 Flutter Framework 之 Widget 』</a><br>『 深入浅出 Flutter Framework 之 BuildOwner 』<br><a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">『 深入浅出 Flutter Framework 之 Element 』</a><br>『 深入浅出 Flutter Framework 之 PipelineOwner 』<br>『 深入浅出 Flutter Framework 之 RenderObejct 』<br>『 深入浅出 Flutter Framework 之 Layer 』<br>『 深入浅出 Flutter Framework 之 Binding 』<br>『 深入浅出 Flutter Framework 之 Rendering Pipeline 』<br>『 深入浅出 Flutter Framework 之 自定义 Widget 』</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p><code>BuildOwer</code>在 Element 状态管理上起到重要作用：</p><ul><li>在 UI 更新过程中跟踪、管理需要 rebuild 的 Element (「dirty elements」);</li><li>在有「dirty elements」时，及时通知引擎，以便在下一帧安排上对「dirty elements」的 rebuild，从而去刷新 UI；</li><li>管理处于 “inactive” 状态的 Element。</li></ul><blockquote><p>这是我们遇到的第一个 Owner，后面还有<code>PipeOwner</code>。</p></blockquote><p>整棵「Element Tree」共享同一个<code>BuildOwer</code>实例 (全局的)，在 Element 挂载过程中由 parent 传递给 child element。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@mustCallSuper</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  _parent = parent;</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _depth = _parent != <span class="keyword">null</span> ? _parent.depth + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  _active = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) <span class="comment">// Only assign ownership if the parent is non-null</span></span><br><span class="line">    _owner = parent.owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上是<code>Element</code>基类的<code>mount</code>方法，第 8 行将 parent.owner 赋给了 child。</p><blockquote><p><code>BuildOwer</code>实例由<code>WidgetsBinding</code>负责创建，并赋值给「Element Tree」的根节点<code>RenderObjectToWidgetElement</code>，此后随着「Element Tree」的创建逐级传递给子节点。(具体流程后续文章会详细分析)<br>一般情况下并不需要我们手动实例化<code>BuildOwer</code>，除非需要离屏沉浸 (此时需要构建 off-screen element tree)</p></blockquote><p><code>BuildOwer</code>两个关键成员变量：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> _InactiveElements _inactiveElements = _InactiveElements();</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt; _dirtyElements = &lt;<span class="built_in">Element</span>&gt;[];</span><br></pre></td></tr></table></figure></p><p>其命名已清晰表达了他们的用途：分别用于存储收集到的「Inactive Elements」、「Dirty Elements」。</p><h1 id="Dirty-Elements"><a href="#Dirty-Elements" class="headerlink" title="Dirty Elements"></a>Dirty Elements</h1><hr><p>那么<code>BuildOwer</code>是如何收集「Dirty Elements」的呢？<br>对于需要更新的 element，首先会调用<code>Element.markNeedsBuild</code>方法，如<a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">前文</a>讲到的<code>State.setState</code>方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">dynamic</span> result = fn() <span class="keyword">as</span> <span class="keyword">dynamic</span>;</span><br><span class="line">  _element.markNeedsBuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如下，<code>Element.markNeedsBuild</code>调用了<code>BuildOwer.scheduleBuildFor</code>方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_active)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dirty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  owner.scheduleBuildFor(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>BuildOwer.scheduleBuildFor</code>方法做了 2 件事：</p><ul><li>调用<code>onBuildScheduled</code>，该方法(其实是个callback)会通知 Engine 在下一帧需要做更新操作；</li><li>将「Dirty Elements」加入到<code>_dirtyElements</code>中。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleBuildFor(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(element.owner == <span class="keyword">this</span>);</span><br><span class="line">  onBuildScheduled();</span><br><span class="line"></span><br><span class="line">  _dirtyElements.add(element);</span><br><span class="line">  element._inDirtyList = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此后，在新一帧绘制到来时，<code>WidgetsBinding.drawFrame</code>会调用<code>BuildOwer.buildScope</code>方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [ VoidCallback callback ]) &#123;</span><br><span class="line">  <span class="keyword">if</span> (callback == <span class="keyword">null</span> &amp;&amp; _dirtyElements.isEmpty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dirtyElements.sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">    <span class="built_in">int</span> dirtyCount = _dirtyElements.length;</span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; dirtyCount) &#123;</span><br><span class="line">      _dirtyElements[index].rebuild();</span><br><span class="line">      index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">Element</span> element <span class="keyword">in</span> _dirtyElements) &#123;</span><br><span class="line">      element._inDirtyList = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _dirtyElements.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如有回调，先执行回调 (第 7 行)；</li><li><p>对「dirty elements」按在「Element Tree」上的深度排序 (即 parent 排在 child 前面) (第 10 行)；</p><blockquote><p>为啥要这样排？确保 parent 先于 child 被 rebuild，以免 child 被重复 rebuild (因为 parent 在 rebuild 时会递归地 update child)。</p></blockquote></li><li><p>对<code>_dirtyElements</code>中的元素依次调用<code>rebuild</code> (第 14 行)；</p></li><li>清理<code>_dirtyElements</code> (第 21 行)。</li></ul><h1 id="Inactive-Elements"><a href="#Inactive-Elements" class="headerlink" title="Inactive Elements"></a>Inactive Elements</h1><hr><p>所谓「Inactive Element」，是指 element 从「Element Tree」上被移除到 dispose 或被重新插入「Element Tree」间的一个中间状态。<br><strong>设计 inactive 状态的主要目的是实现『带有「global key」的 element』可以带着『状态』在树上任意移动。</strong></p><p>BuildOwer 负责对「Inactive Element」进行管理，包括添加、删除以及对过期的「Inactive Element」执行 unmount 操作。<br>关于「Inactive Element」的更多信息将在介绍 Element 时一起介绍。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>BuildOwner 主要是用于收集那些需要 rebuild 的「Dirty Elements」以及处于 Inactive 状态的 Elements。</p><p>结束了！就是这么简单，下篇再见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是『 深入浅出 Flutter Framework 』系列文章的第二篇，对 BuildOwer 相关内容进行简要地分析介绍，为下一篇文章介绍 Element 作准备 (由于篇幅原因将其单独提出来)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://zxfcumtcs.github.io/tags/flutter/"/>
    
      <category term="移动开发" scheme="http://zxfcumtcs.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨平台" scheme="http://zxfcumtcs.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Flutter Framework 之 Widget</title>
    <link href="http://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/"/>
    <id>http://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/</id>
    <published>2020-05-01T13:29:16.000Z</published>
    <updated>2020-05-16T13:38:13.984Z</updated>
    
    <content type="html"><![CDATA[<p>本文是『 深入浅出 Flutter Framework 』系列文章的第一篇，主要以不同类型 Widget 的核心方法为切入点，对其展开详细分析。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>Flutter 作为一种新兴跨平台解决方案，自 2017 年 Google 在 I/O 大会上推出后，尤其是在 2018 年 I/O 大会上发布第一个预览版后，迅速引起移动开发者的广泛关注，并成为时下最热门的跨平台解决方案 ( 没有之一 ) ！</p><p>本系列文章将深入 Flutter Framework 内部逐步去分析其核心概念和流程，主要包括：<br>『 深入浅出 Flutter Framework 之 Widget 』<br><a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">『 深入浅出 Flutter Framework 之 BuildOwner 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">『 深入浅出 Flutter Framework 之 Element 』</a><br>『 深入浅出 Flutter Framework 之 PipelineOwner 』<br>『 深入浅出 Flutter Framework 之 RenderObejct 』<br>『 深入浅出 Flutter Framework 之 Layer 』<br>『 深入浅出 Flutter Framework 之 Binding 』<br>『 深入浅出 Flutter Framework 之 Rendering Pipeline 』<br>『 深入浅出 Flutter Framework 之 自定义 Widget 』</p><p>其中，前 7 篇属于基础篇，分别介绍 Flutter 中几个最核心的概念。Rendering Pipeline 篇则是在此基础上从 Build、Layout 到 Paint 的流程将它们串起来，分析 Flutter UI 是如何创建的、如何更新的。最后，自定义 Widget 属于回顾、实践篇，分析自定义一个 Render Widget 至少需要哪些步骤。</p><blockquote><p>如<a href="https://flutter.dev/docs/resources/technical-overview#layer-cakes-are-delicious" target="_blank" rel="noopener">下图</a>所示，Flutter 整体分为三层：Framework (dart)、Engine (C/C++)、Embedder (Platform)，上述文章主要集中在 Framework 这一层。<br><img src="/img/flutter-layercake.png" alt=""></p></blockquote><h1 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h1><hr><blockquote><p>Everything’s a widget.</p></blockquote><p>在开发 Flutter 应用过程中，接触最多的无疑就是<code>Widget</code>，是『描述』 Flutter UI 的基本单元，通过<code>Widget</code>可以做到：</p><ul><li>描述 UI 的层级结构 (通过<code>Widget</code>嵌套)；</li><li>定制 UI 的具体样式 (如：<code>font</code>、<code>color</code>等)；</li><li>指导 UI 的布局过程 (如：<code>padding</code>、<code>center</code>等)；</li><li>…</li></ul><p>Google 在设计<code>Widget</code>时，还赋予它一些鲜明的特点：</p><ul><li><p>声明式 UI —— 相对于传统 Native 开发中的命令式 UI，声明式 UI 有不少优势，如：开发效率显著提升、UI 可维护性明显加强等；</p></li><li><p>不可变性 —— Flutter 中所有<code>Widget</code>都是不可变的(immutable)，即其内部成员都是不可变的(<code>final</code>)，对于变化的部分需要通过「Stateful Widget-State」的方式实现；</p></li><li><p>组合大于继承 —— <code>Widget</code>设计遵循组合大于继承这一优秀的设计理念，通过将多个功能相对单一的<code>Widget</code>组合起来便可得到功能相对复杂的<code>Widget</code>。</p></li></ul><p>在<code>Widget</code>类定义处有这样一段注释：<br><img src="/img/Widget_Comment.png" alt=""><br>这段注释阐明了<code>Widget</code>的本质：<strong>用于配置<code>Element</code>的，<code>Widget</code>本质上是 UI 的配置信息 (附带部分业务逻辑)。</strong></p><blockquote><p>我们通常会将通过<code>Widget</code>描述的 UI 层级结构称之为「Widget Tree」，但与「Element Tree」、「RenderObject Tree」以及「Layer Tree」相比，实质上并不存在「Widget Tree」。为了描述方便，将 Widget 组合描述的 UI 层级结构称之为「Widget Tree」，也未尝不可。</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><img src="/img/Widget.png" alt=""><br>如上图所示，按照功能划分<code>Widget</code>大致可以分为 3 类：</p><ul><li><p><em>「Component Widget」</em> —— 组合类 Widget，这类 Widget 都直接或间接继承于<code>StatelessWidget</code>或<code>StatefulWidget</code>，上一小节提到过在 Widget 设计上遵循组合大于继承的原则，通过组合功能相对单一的 Widget 可以得到功能更为复杂的 Widget。平常的业务开发主要是在开发这一类型的 Widget；</p></li><li><p><em>「Proxy Widget」</em> —— 代理类 Widget，正如其名，「Proxy Widget」本身并不涉及 Widget 内部逻辑，只是为「Child Widget」提供一些附加的中间功能。典型的如：<code>InheritedWidget</code>用于在「Descendant Widgets」间传递共享信息、<code>ParentDataWidget</code>用于配置「Descendant Renderer Widget」的布局信息；</p></li><li><p><em>「Renderer Widget」</em> —— 渲染类 Widget，是最核心的<code>Widget</code>类型，会直接参与后面的「Layout」、「Paint」流程，无论是「Component Widget」还是「Proxy Widget」最终都会映射到「Renderer Widget」上，否则将无法被绘制到屏幕上。这 3 类 Widget 中，<strong>只有「Renderer Widget」有与之一一对应的「Render Object」</strong>。</p></li></ul><h2 id="核心方法源码分析"><a href="#核心方法源码分析" class="headerlink" title="核心方法源码分析"></a>核心方法源码分析</h2><p>下面，我们重点介绍各类型 Widget 的核心方法，以便更好地理解 Widget 是如何参与整个 UI 的构建过程。</p><h3 id="Widget-1"><a href="#Widget-1" class="headerlink" title="Widget"></a>Widget</h3><p><code>Widget</code>，所有 Widget 的基类。</p><div style="width: 400px; margin: auto"><img src="/img/Widget_Method.png" alt=""></div><p>如上图所示，在 <code>Widget</code>基类中有 3 个重要的方法 (属性)：</p><ul><li><p><em>Key key</em> —— 在同一父节点下，用作兄弟节点间的唯一标识，主要用于控制当 Widget 更新时，对应的 Element 如何处理 (是更新还是新建)。若某 Widget 是其「Parent Widget」唯一的子节点时，一般不用设置 key；</p><blockquote><p>GlobalKey 是一类较特殊的 key，在介绍 Element 时会附带介绍。</p></blockquote></li><li><p><em>Element createElement()</em> —— 每个<code>Widget</code>都有一个与之对应的<code>Element</code>，由该方法负责创建，<code>createElement</code>可以理解为设计模式中的<em>工厂方法</em>，具体的<code>Element</code>类型由对应的<code>Widget</code>子类负责创建；</p></li><li><p><em>static bool canUpdate(Widget oldWidget, Widget newWidget)</em> —— 是否可以用 new widget 修改前一帧用 old widget 生成的 Element，而不是创建新的 Element，<code>Widget</code>类的默认实现为：2个<code>Widget</code>的<code>runtimeType</code>与<code>key</code>都相等时，返回<code>true</code>，即可以直接更新 (key 为 null 时，认为相等)。</p><blockquote><p>上述更新流程，同样在介绍 Element 时会重点分析。</p></blockquote></li></ul><h3 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h3><p>无状态-组合型 Widget，由其<code>build</code>方法描述组合 UI 的层级结构。在其生命周期内状态不可变。<br><img src="/img/StatelessWidget_Comment.png" alt=""></p><div style="width: 400px; margin: auto"><img src="/img/StatelessWidget_Method.png" alt=""></div><blockquote><p>ps: 对于有父子关系的类，在子类中只会介绍新增或有变化的方法</p></blockquote><ul><li><p><em>StatelessElement createElement()</em> ——「Stateless Widget」对应的 Element 为<code>StatelessElement</code>，一般情况下<code>StatelessWidget</code>子类不必重写该方法，即子类对应的 Element 也是<code>StatelessElement</code>；</p></li><li><p><em>Widget build(BuildContext context)</em> —— 算是 Flutter 体系中的核心方法之一，以『声明式 UI』的形式描述了该组合式 Widget 的 UI 层级结构及样式信息，也是开发 Flutter 应用的主要工作『场所』。该方法在 3 种情况下被调用：</p><ul><li>Widget 第一次被加入到 Widget Tree 中 (更准确地说是其对应的 Element 被加入到 Element Tree 时，即 Element 被挂载『mount』时)；</li><li>「Parent Widget」修改了其配置信息；</li><li>该 Widget 依赖的「Inherited Widget」发生变化时。</li></ul></li></ul><p>当「Parent Widget」或 依赖的「Inherited Widget」频繁变化时，<code>build</code>方法也会频繁被调用。因此，提升<code>build</code>方法的性能就显得十分重要，Flutter 官方给出了几点建议：</p><ul><li><p><em>减少不必要的中间节点，即减少 UI 的层级，</em>如：对于「Single Child Widget」，没必要通过组合「Row」、「Column」、「Padding」、「SizedBox」等复杂的 Widget 达到某种布局的目标，或许通过简单的「Align」、「CustomSingleChildLayout」即可实现。又或者，为了实现某种复杂精细的 UI 效果，不一定要通过组合多个「Container」，再附加「Decoration」来实现，通过 「CustomPaint」自定义或许是更好的选择；</p></li><li><p><em>尽可能使用<code>const</code> Widget，</em>为 Widget 提供<code>const</code>构造方法；</p><blockquote><p>关于 const constructor 推荐 <a href="https://japhr.blogspot.com/2012/12/dart-constant-constructors.html" target="_blank" rel="noopener">Dart Constant Constructors</a> 看看这篇文章的评论。</p></blockquote></li><li><p>必要时，<em>可以将「Stateless Widget」重构成「Stateful Widget」，</em>以便可以使用「Stateful Widget」中一些特定的优化手法，如：缓存「sub trees」的公共部分，并在改变树结构时使用<code>GlobalKey</code>；</p></li><li><p><em>尽量减小 rebuilt 范围，</em>如：某个 Widget 因使用了「Inherited Widget」，导致频繁 rebuilt，可以将真正依赖「Inherited Widget」的部分提取出来，封装成更小的独立 Widget，并尽量将该独立 Widget 推向树的叶子节点，以便减小 rebuilt 时受影响的范围。</p></li></ul><h3 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h3><p>有状态-组合型 Widget，但要注意的是<code>StatefulWidget</code>本身还是不可变的，其可变状态存在于<code>State</code>中。<br><img src="/img/Stateful_Comment.png" alt=""></p><div style="width: 400px; margin: auto"><img src="/img/StatefulWidget_Method.png" alt=""></div><ul><li><p><em>StatefulElement createElement()</em> ——「Stateful Widget」对应的 Element 为<code>StatefulElement</code>，一般情况下<code>StatefulWidget</code>子类不用重写该方法，即子类对应的Element 也是<code>StatefulElement</code>；</p></li><li><p><em>State createState()</em> —— 创建对应的 State，该方法在<code>StatefulElement</code>的构造方法中被调用。可以简单地理解为当「Stateful Widget」被添加到 Widget Tree 时会调用该方法。</p>  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码已精简处理(本文中其他代码会做同样的简化处理)</span></span><br><span class="line">StatefulElement(StatefulWidget widget)</span><br><span class="line">     : _state = widget.createState(),</span><br><span class="line">       <span class="keyword">super</span>(widget) &#123;</span><br><span class="line">   _state._element = <span class="keyword">this</span>;</span><br><span class="line">   _state._widget = widget;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>实际上是「Stateful Widget」对应的「Stateful Element」被添加到 Element Tree 时，伴随「Stateful Element」的初始化，<code>createState</code>方法被调用。从后文可知一个 Widget 实例可以对应多个 Element 实例 (也就是同一份配置信息 (Widget) 可以在 Element Tree 上不同位置配置多个 Element 节点)，因此，<code>createState</code>方法在「Stateful Widget」生命周期内可能会被调用多次。<br>另外，需要注意的是配有<code>GlobalKey</code>的 Widget 对应的 Element 在整个 Element Tree 中只有一个实例。</p></blockquote><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><blockquote><p>The logic and internal state for a 「Stateful Widget」.</p></blockquote><p>State 用于处理「Stateful Widget」的业务逻辑以及可变状态。<br>由于其内部状态是可变的，故 State 有较复杂的生命周期：<br><img src="/img/StateLifecycle.png" alt=""><br>如上图，State 的生命周期大致可以分为 8 个阶段：</p><ul><li><p>在对应的「Stateful Element」被挂载 (mount) 到树上时，通过<code>StatefulElement.constructor</code> –&gt; <code>StatefulWidget.createState</code>创建 State 实例；</p><blockquote><p>从<code>StatefulElement.constructor</code>中的<code>_state._element = this;</code>可知，<code>State._emelent</code>指向了对应的 Element 实例，而我们熟知的<code>State.context</code>引用的就是这个<code>_element</code>：<code>BuildContext get context =&gt; _element;</code>。<br><code>State</code>实例与<code>Element</code>实例间的绑定关系一经确定，在整个生命周期内不会再变了 (<strong>Element 对应的 Widget 可能会变，但对应的 State 永远不会变</strong>)，期间，<code>Element</code>可以在树上移动，但上述关系不会变 (即「Stateful Element」是带着状态移动的)。</p></blockquote></li><li><p>StatefulElement 在挂载过程中接着会调用<code>State.initState</code>，子类可以重写该方法执行相关的初始化操作 (此时可以引用<code>context</code>、<code>widget</code>属性)；</p></li><li><p>同样在挂载过程中会调用<code>State.didChangeDependencies</code>，该方法在 State 依赖的对象 (如：「Inherited Widget」) 状态发生变化时也会被调用，<em>子类很少需要重写该方法，</em>除非有非常耗时不宜在<code>build</code>中进行的操作，因为在依赖有变化时<code>build</code>方法也会被调用；</p></li><li><p>此时，State 初始化已完成，其<code>build</code>方法此后可能会被多次调用，在状态变化时 State 可通过<code>setState</code>方法来触发其子树的重建；</p></li><li><p>此时，「element tree」、「renderobject tree」、「layer tree」已构建完成，完整的 UI 应该已呈现出来。此后因为变化，「element tree」中「parent element」可能会对树上该位置的节点用新配置 (Widget) 进行重建，当新老配置 (oldWidget、newWidget)具有相同的「runtimeType」&amp;&amp;「key」时，framework 会用 newWidget 替换 oldWidget，并触发一系列的更新操作 (在子树上递归进行)。同时，<code>State.didUpdateWidget</code>方法被调用，子类重写该方法去响应 Widget 的变化；</p><blockquote><p>上述 3 棵树以及更新流程在后续文章中会有详细介绍</p></blockquote></li><li><p>在 UI 更新过程中，任何节点都有被移除的可能，State 也会随之移除，(如上一步中「runtimeType」||「key」不相等时)。此时会调用<code>State.deactivate</code>方法，由于被移除的节点可能会被重新插入树中某个新的位置上，故子类重写该方法以清理与节点位置相关的信息 (如：该 State 对其他 element 的引用)、同时，不应在该方法中做资源清理；</p><blockquote><p>重新插入操作必须在当前帧动画结束之前</p></blockquote></li><li><p>当节点被重新插入树中时，<code>State.build</code>方法被再次调用；</p></li><li><p>对于在当前帧动画结束时尚未被重新插入的节点，<code>State.dispose</code>方法被执行，State 生命周期随之结束，此后再调用<code>State.setState</code>方法将报错。子类重写该方法以释放任何占用的资源。</p></li></ul><p><img src="/img/State_Method.png" alt=""><br>至此，State 中的核心方法基本都已在上述过程中介绍了，下面重点看一下<code>setState</code>方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(fn != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_debugLifecycleState == _StateLifecycle.defunct) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_debugLifecycleState == _StateLifecycle.created &amp;&amp; !mounted) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">dynamic</span> result = fn() <span class="keyword">as</span> <span class="keyword">dynamic</span>;</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">is</span> Future) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">  _element.markNeedsBuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述源码可以看到，关于<code>setState</code>方法有几点值得关注：</p><ul><li><p>在<code>State.dispose</code>后不能调用<code>setState</code> (第 4 行)；</p></li><li><p>在 State 的构造方法中不能调用<code>setState</code> (第 7 行)；</p></li><li><p><code>setState</code>方法的回调函数 (<code>fn</code>) 不能是异步的 (返回值为<code>Future</code>)，原因很简单，因为从流程设计上 framework 需要根据回调函数产生的新状态去刷新 UI (第 14 行)；</p></li><li><p>通过<code>setState</code>方法之所以能更新 UI，是在其内部调用<code>_element.markNeedsBuild()</code>实现的 (具体过程在介绍 Element 时再详细分析)。</p></li></ul><p>关于 State 最后再强调 2 点：</p><ul><li>若<code>State.build</code>方法依赖了自身状态会变化的对象，如：<code>ChangeNotifier</code>、<code>Stream</code>或其他可以被订阅的对象，需要确保在<code>initState</code>、<code>didUpdateWidget</code>、<code>dispose</code>等 3 方法间有正确的订阅 (subscribe) 与取消订阅 (unsubscribe) 的操作：<ul><li>在<code>initState</code>中执行 subscribe；</li><li>如果关联的「Stateful Widget」与订阅有关，在<code>didUpdateWidget</code>中先取消旧的订阅，再执行新的订阅；</li><li>在<code>dispose</code>中执行 unsubscribe。</li></ul></li></ul><ul><li>在<code>State.initState</code>方法中不能调用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>，但<code>State.didChangeDependencies</code>会随之执行，在该方法中可以调用。</li></ul><h3 id="ParentDataWidget"><a href="#ParentDataWidget" class="headerlink" title="ParentDataWidget"></a>ParentDataWidget</h3><p><code>ParentDataWidget</code>以及下面要介绍的<code>InheritedElement</code>都继承自<code>ProxyWidget</code>，由于<code>ProxyWidget</code>作为抽象基类本身没有任何功能，故下面直接介绍<code>ParentDataWidget</code>、<code>InheritedElement</code>。<br><img src="/img/ParentDataWidget_Comment.png" alt=""><br><code>ParentDataWidget</code>作为 Proxy 型 Widget，其功能主要是为其他 Widget 提供<code>ParentData</code>信息。虽然其 child widget 不一定是 RenderObejctWidget 类型，但其提供的<code>ParentData</code>信息最终都会落地到 RenderObejctWidget 类型子孙 Widget 上。</p><blockquote><p>ParentData 是『parent renderobject』在 layout『child renderobject』时使用的辅助定位信息，详细信息会在介绍 RenderObject 时介绍。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRenderObject(<span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_ancestorRenderObjectElement == <span class="keyword">null</span>);</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class="line">  _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);</span><br><span class="line">  <span class="keyword">final</span> ParentDataElement&lt;RenderObjectWidget&gt; parentDataElement = _findAncestorParentDataElement();</span><br><span class="line">  <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</span><br><span class="line">    _updateParentData(parentDataElement.widget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ParentDataElement&lt;RenderObjectWidget&gt; _findAncestorParentDataElement() &#123;</span><br><span class="line">  <span class="built_in">Element</span> ancestor = _parent;</span><br><span class="line">  <span class="keyword">while</span> (ancestor != <span class="keyword">null</span> &amp;&amp; ancestor <span class="keyword">is</span>! RenderObjectElement) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ancestor <span class="keyword">is</span> ParentDataElement&lt;RenderObjectWidget&gt;)</span><br><span class="line">      <span class="keyword">return</span> ancestor;</span><br><span class="line">    ancestor = ancestor._parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _updateParentData(ParentDataWidget&lt;RenderObjectWidget&gt; parentData) &#123;</span><br><span class="line">  parentData.applyParentData(renderObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码来自<code>RenderObjectElement</code>，可以看到在其<code>attachRenderObject</code>方法第 6 行从祖先节点找<code>ParentDataElement</code>，如果找到就用其 Widget(ParentDataWidget) 中的 parentData 信息去设置 Render Obejct。在查找过程中如查到<code>RenderObjectElement</code> (第 13 行)，说明当前 RenderObject 没有 Parent Data 信息。<br>最终会调用到<code>ParentDataWidget.applyParentData(RenderObject renderObject)</code>，子类需要重写该方法，以便设置对应<code>RenderObject.parentData</code>。</p><div style="width: 400px; margin: auto"><img src="/img/ParentDataWidget_Method.png" alt=""></div><p>来看个例子，通常配合<code>Stack</code>使用的<code>Positioned</code>(继承自ParentDataWidget)：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> applyParentData(RenderObject renderObject) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(renderObject.parentData <span class="keyword">is</span> StackParentData);</span><br><span class="line">  <span class="keyword">final</span> StackParentData parentData = renderObject.parentData;</span><br><span class="line">  <span class="built_in">bool</span> needsLayout = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parentData.left != left) &#123;</span><br><span class="line">    parentData.left = left;</span><br><span class="line">    needsLayout = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (parentData.width != width) &#123;</span><br><span class="line">    parentData.width = width;</span><br><span class="line">    needsLayout = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (needsLayout) &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNode targetParent = renderObject.parent;</span><br><span class="line">    <span class="keyword">if</span> (targetParent <span class="keyword">is</span> RenderObject)</span><br><span class="line">      targetParent.markNeedsLayout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<code>Positioned</code>在必要时将自己的属性赋值给了对应的<code>RenderObject.parentData</code> (此处是<code>StackParentData</code>)，并对「parent render object」调用<code>markNeedsLayout</code>(第 19 行)，以便重新 layout，毕竟修改了布局相关的信息。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentDataWidget</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span>&gt; <span class="keyword">extends</span> <span class="title">ProxyWidget</span></span></span><br></pre></td></tr></table></figure><p>如上所示，<code>ParentDataWidget</code>在定义上使用了泛型<code>&lt;T extends RenderObjectWidget&gt;</code>，其背后的含义是：<br><em>从当前<code>ParentDataWidget</code>节点向上追溯形成的祖先节点链(『parent widget chain』)上，在 2 个<code>ParentDataWidget</code>类型的节点形成的链上至少要有一个『RenderObject Widget』类型的节点。因为一个『RenderObject Widget』不能接受来自 2 个及以上『ParentData Widget』的信息。</em></p><div style="width: 400px; margin: auto"><img src="/img/ParentDataWidget_Chain.png" alt=""></div><h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p><img src="/img/InheritedWidget_Comment.jpg" alt=""><br>InheritedWidget 用于在树上向下传递数据。<br>通过<code>BuildContext.dependOnInheritedWidgetOfExactType</code>可以获取最近的「Inherited Widget」，需要注意的是通过这种方式获取「Inherited Widget」时，当「Inherited Widget」状态有变化时，会导致该引用方 rebuild。</p><blockquote><p>具体原理在介绍 Element 时会详细分析。</p></blockquote><p>通常，为了使用方便会「Inherited Widget」会提供静态方法<code>of</code>，在该方法中调用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>。<code>of</code>方法可以直接返回「Inherited Widget」，也可以是具体的数据。</p><p>有时，「Inherited Widget」是作为另一个类的实现细节而存在的，其本身是私有的(外部不可见)，此时<code>of</code>方法就会放到对外公开的类上。最典型的例子就是<code>Theme</code>，其本身是<code>StatelessWidget</code>类型，但其内部创建了一个「Inherited Widget」：<code>_InheritedTheme</code>，<code>of</code>方法就定义在上<code>Theme</code>上：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThemeData of(BuildContext context, &#123; <span class="built_in">bool</span> shadowThemeOnly = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> _InheritedTheme inheritedTheme = context.dependOnInheritedWidgetOfExactType&lt;_InheritedTheme&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ThemeData.localize(theme, theme.typography.geometryThemeFor(category));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该<code>of</code>方法返回的是<code>ThemeData</code>类型的具体数据，并在其内部首先调用了<code>BuildContext.dependOnInheritedWidgetOfExactType</code>。</p><p>我们经常使用的「Inherited Widget」莫过于<code>MediaQuery</code>，同样提供了<code>of</code>方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MediaQueryData of(BuildContext context, &#123; <span class="built_in">bool</span> nullOk = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> MediaQuery query = context.dependOnInheritedWidgetOfExactType&lt;MediaQuery&gt;();</span><br><span class="line">  <span class="keyword">if</span> (query != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> query.data;</span><br><span class="line">  <span class="keyword">if</span> (nullOk)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="width: 400px; margin: auto"><img src="/img/InheritedWidget_Method.png" alt=""></div><ul><li><p><em>InheritedElement createElement()</em> ——「Inherited Widget」对应的 Element 为<code>InheritedElement</code>，一般情况下<code>InheritedElement</code>子类不用重写该方法；</p></li><li><p><em>bool updateShouldNotify(covariant InheritedWidget oldWidget)</em> —— 在「Inherited Widget」rebuilt 时判断是否需要 rebuilt 那些依赖它的 Widget；</p></li></ul><p>如下是<code>MediaQuery.updateShouldNotify</code>的实现，在新老<code>Widget.data</code> 不相等时才 rebuilt 那依赖的 Widget。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> updateShouldNotify(MediaQuery oldWidget) =&gt; data != oldWidget.data;</span><br></pre></td></tr></table></figure></p><h3 id="RenderObjectWidget"><a href="#RenderObjectWidget" class="headerlink" title="RenderObjectWidget"></a>RenderObjectWidget</h3><p>真正与渲染相关的 Widget，属于最核心的类型，一切其他类型的 Widget 要渲染到屏幕上，最终都要回归到该类型的 Widget 上。</p><div style="width: 400px; margin: auto"><img src="/img/RenderObjectWidget_Method.png" alt=""></div><ul><li><p><em>RenderObjectElement createElement()</em> ——「RenderObject Widget」对应的 Element 为<code>RenderObjectElement</code>，由于<code>RenderObjectElement</code>也是抽象类，故子类需要重写该方法；</p></li><li><p><em>RenderObject createRenderObject(BuildContext context)</em> —— 核心方法，创建 Render Widget 对应的 Render Object，同样子类需要重写该方法。该方法在对应的 Element 被挂载到树上时调用(<code>Element.mount</code>)，即在 Element 挂载过程中同步构建了「Render Tree」(详细过程后续文章会详细分析)；</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">RenderFlex createRenderObject(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> RenderFlex(</span><br><span class="line">    direction: direction,</span><br><span class="line">    mainAxisAlignment: mainAxisAlignment,</span><br><span class="line">    mainAxisSize: mainAxisSize,</span><br><span class="line">    crossAxisAlignment: crossAxisAlignment,</span><br><span class="line">    textDirection: getEffectiveTextDirection(context),</span><br><span class="line">    verticalDirection: verticalDirection,</span><br><span class="line">    textBaseline: textBaseline,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面是<code>Flex.createRenderObject</code>的源码，真实感受一下 (还是代码更有感觉)。可以看到，用<code>Flex</code>的信息(配置)初始化了<code>RenderFlex</code>。</p><blockquote><p><code>Flex</code>是<code>Row</code>、<code>Column</code>的基类，<code>RenderFlex</code>继承自<code>RenderBox</code>，后者继续自<code>RenderObject</code>。</p></blockquote></li><li><p><em>void updateRenderObject(BuildContext context, covariant RenderObject renderObject)</em> —— 核心方法，在 Widget 更新后，修改对应的 Render Object。该方法在首次 build 以及需要更新 Widget 时都会调用；</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> updateRenderObject(BuildContext context, covariant RenderFlex renderObject) &#123;</span><br><span class="line">  renderObject</span><br><span class="line">    ..direction = direction</span><br><span class="line">    ..mainAxisAlignment = mainAxisAlignment</span><br><span class="line">    ..mainAxisSize = mainAxisSize</span><br><span class="line">    ..crossAxisAlignment = crossAxisAlignment</span><br><span class="line">    ..textDirection = getEffectiveTextDirection(context)</span><br><span class="line">    ..verticalDirection = verticalDirection</span><br><span class="line">    ..textBaseline = textBaseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>Flex.updateRenderObject</code>的源码也很简单，与<code>Flex.createRenderObject</code>几乎一一对应，用当前<code>Flex</code>的信息修改<code>renderObject</code>。</p></li><li><p><em>void didUnmountRenderObject(covariant RenderObject renderObject)</em> —— 对应的「Render Object」从「Render Tree」上移除时调用该方法。</p></li></ul><blockquote><p><code>RenderObjectWidget</code>的几个子类：<code>LeafRenderObjectWidget</code>、<code>SingleChildRenderObjectWidget</code>、<code>MultiChildRenderObjectWidget</code>只是重写了<code>createElement</code>方法以便返回各自对应的具体的 Element 类实例。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>至此，重要的基础型 Widget 基本介绍完了，总结一下：</p><ul><li><p>Widget 本质上是 UI 的配置信息 (附加部分业务逻辑)，并不存在一颗真实的「Widget Tree」(与「Element Tree」、「RenderObject Tree」以及「Layer Tree」相比)；</p></li><li><p>Widget 从功能上可以分为 3 类：「Component Widget」、「Proxy Widget」以及「Renderer Widget」；</p></li><li><p>Widget 与 Element 一一对应，Widget 提供创建 Element 的方法 (<code>createElement</code>，本质上是一个工厂方法)；</p></li><li><p>只有「Renderer Widget」才会参与最终的 UI 生成过程(Layout、Paint)，只有该类型的 Widget 才有与之对应的「Render Object」，同样由其提供创建方法(<code>createRenderObject</code>)。</p></li></ul><p>下篇再见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是『 深入浅出 Flutter Framework 』系列文章的第一篇，主要以不同类型 Widget 的核心方法为切入点，对其展开详细分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://zxfcumtcs.github.io/tags/flutter/"/>
    
      <category term="移动开发" scheme="http://zxfcumtcs.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨平台" scheme="http://zxfcumtcs.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>论面向接口编程</title>
    <link href="http://zxfcumtcs.github.io/2019/12/04/InterfaceBasedProgramming/"/>
    <id>http://zxfcumtcs.github.io/2019/12/04/InterfaceBasedProgramming/</id>
    <published>2019-12-04T14:25:55.000Z</published>
    <updated>2019-12-08T09:43:37.439Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先从接口的实现方、使用方角度阐述了什么是接口，其次分析了面向接口编程的意义。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="我看中的接口"><a href="#我看中的接口" class="headerlink" title="我看中的接口"></a>我看中的接口</h1><hr><p>面向接口编程作为口号可以说是妇孺皆知，臭大街了！<br>但在日常开发、交流过程中发现很多同学对面向接口编程的理解还是有所偏差。<br>因此，想通过这篇小短文，谈谈我对面向接口编程的理解，希望对大家有所帮助。</p><p>首先要回答的问题就是：<br>接口是什么？</p><ul><li><code>C++</code>、<code>JavaScript</code>、<code>dart</code>的 (abstract)<code>class</code>——『形式上的接口』</li><li><code>Objective-C</code>的<code>delegate</code>、<code>Swift</code>的<code>protocol</code>、<code>Java</code>的<code>interface</code>——『语义上的接口』</li></ul><blockquote><p>接口属于面向对象编程(OOP)的范畴</p></blockquote><p>这样的答案无疑是『政治正确』的，但并非我们想要的，我想从另外一个角度来看待这个问题：</p><blockquote><p>接口是一种抽象</p></blockquote><ul><li>接口使用方：<strong>对外界『依赖』的抽象，表明其依赖哪些能力</strong>；</li><li>接口实现方：<strong>对自我『能力』的抽象，宣称其具备哪些能力</strong>。</li></ul><p>正是由于接口的抽象性，接口使用方与实现方才得以解耦。<br>下面，我们以<code>UITableViewDataSource</code>为例，来具体感受一下：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITableViewDataSource</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section;</span><br><span class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>UITableView</code>对 iOS 开发同学来说再熟悉不过了，其有一个需要实现<code>UITableViewDataSource</code>接口的属性<code>dataSource</code>。<br><code>UITableView</code>作为<code>UITableViewDataSource</code>接口的<strong>使用方</strong>，很清楚的表明了其对外界的依赖：</p><ul><li><code>numberOfRowsInSection:</code>——依赖外界告诉它，某个 section 有几行；</li><li><code>cellForRowAtIndexPath:</code>——依赖外界提供某个 indexPath 处的cell；</li><li>…</li></ul><p>总之，通过<code>UITableViewDataSource</code>清楚地表明了<code>UITableView</code>需要哪些能力的支持，也就清楚地说明了该如何去使用<code>UITableView</code>。</p><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ABCViewController</span> () &lt;<span class="title">UITableViewDelegate</span>,<span class="title">UITableViewDataSource</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>通过上面这行代码，我们就能清晰地知道，<code>ABCViewController</code>具有<code>numberOfRowsInSection</code>、<code>cellForRowAtIndexPath</code>等能力，因为其实现了<code>UITableViewDataSource</code>接口！也就是其可以供<code>UITableView</code>使用。</p><blockquote><p><code>UITableView</code>之所以有如此好的通用性，就是采用了面向接口编程，将其对外界的依赖抽象成2个接口：<code>UITableViewDelegate</code>、<code>UITableViewDataSource</code>，即只要是实现了这两个接口的都可以为其所用。</p></blockquote><h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><hr><ul><li><strong>简洁、易维护</strong>——如上节所提到的<code>UITableView</code>，其内部实现想必非常复杂，但由于有<code>UITableViewDelegate</code>、<code>UITableViewDataSource</code>两个抽象接口，表明了其对使用方的依赖，我们非常容易地就可以使用<code>UITableView</code>，无须关心其内部细节，只要实现这两个接口即可；</li><li><strong>解耦</strong>——接口作为一个抽象层，很好地将使用方与实现方隔离开来，使得两者不再有直接依赖关系，双方的复用性、扩展性(尤其是接口使用方)得到极大提高，具体例子可以参考<a href="https://zxfcumtcs.github.io/2017/03/04/CustomUIControls/">自定义 UI 组件库</a>这篇文章；</li><li><strong>分工协作</strong>——通过接口使得原本相互依赖的双方得以很好的解耦，分工协作更加顺畅，双方可以并行开发，互不干扰；</li><li><strong>可测性更好</strong>——这里主要指接口使用方的测试，因为通过接口可以更方便地 mock 数据供接口使用方测试用；</li><li><strong>拥抱变化</strong>——对开发同学来说最憎恨的莫过于已经开发好的或开发中的需求又变了，除了『撕』之外，我们还可以采取积极的防御措施，通过接口『隔离变化』，将变化带来的影响降到最低。</li></ul><p><img src="/img/tab_page.png" alt=""><br>这是一个前不久在项目中真实遇到的例子，某个页面，当初只有 A、B 两个 tab，但在开发过程中又变成 A、B、C 三个 tab，之后又变成了 D、E 两个 tab。(每个 tab 的数据开源、UI 样式完成不一样)</p><p>刚开始时，A、B 两个 tab 的逻辑是直接放在主页面里面的<br>当产品需要增加 C tab 时，隐约感到情况不妙<br>为了，防止后续还有改动带来的影响，决定将 tab 相关的逻辑抽离出来，主页面不再依赖于某个特定的 tab，而是依赖于抽象后的接口。<br>需要放到该主页面的 tab 自行实现这套接口即可。<br>从此，tab 的增删改就与主页面无关了，即实现了 『OCP』，这也是23种经典设计模式之一的：『策略模式』。</p><p>总之，面向接口，即面向简洁、面向变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先从接口的实现方、使用方角度阐述了什么是接口，其次分析了面向接口编程的意义。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计" scheme="http://zxfcumtcs.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>函数式思维</title>
    <link href="http://zxfcumtcs.github.io/2019/11/17/functional/"/>
    <id>http://zxfcumtcs.github.io/2019/11/17/functional/</id>
    <published>2019-11-17T14:04:04.000Z</published>
    <updated>2019-11-24T09:23:40.887Z</updated>
    
    <content type="html"><![CDATA[<p>函数式编程中有很多优秀的设计理念值得我们去学习，本文对函数式编程中的基础理念进行了简要的介绍，但更重要的是思考、总结如何将它们应用到我们日常开发中，帮助我们去提升代码的可读性、可维护性等。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>对函数式编程一直有所耳闻，但并未深入研究过，在日常开发中也很少去思考这方面的问题。<br>直到最近，在开发 flutter 应用时，由于 dart 对函数式编程有较好地支持，对函数式编程有了更新的认识。<br>纯函数式的编程对我们正常的业务开发来说是一种『乌托邦』式的存在，但其中有很多的设计理念值得我们去学习。<br>函数式编程相关的文章也有不少，本文的不同之处在于其立足点是：<br>如何利用函数式编程理念帮助我们写出更好的代码，这也是本文标题叫做函数式思维而不是函数式编程的原因。</p><blockquote><p>函数式编程的理论基础是<code>λ</code>演算(lambda calculus)，但本文并不打算在理论层面上做过多的讨论。</p></blockquote><p>首先，总结一下我个人的观点：函数式编程能给我们带来什么？<br>简单、清晰、易维护、可复用的代码。</p><blockquote><p>简单、清晰、易维护、可复用可以说是各种架构设计、设计规范追求的第一目标。</p></blockquote><p>那函数式编程又是通过什么方式实现这样的收益的：</p><ul><li>状态不可变、纯函数；</li><li>避免引入状态，Pointfree；</li><li>强调组合、提高复用性；</li><li>更高层次的抽象，丰富的集合操作。</li></ul><p>本文将主要围绕以上几方面对函数式编程展开讨论。</p><h1 id="Functional-vs-Imperative"><a href="#Functional-vs-Imperative" class="headerlink" title="Functional vs. Imperative"></a>Functional vs. Imperative</h1><hr><p>函数式编程作为编程范式(Programming Paradigm)之一，与之对应的，也是我们最熟悉的命令式编程(Imperative programming，面向对象编程也属于该范式)。</p><p>从思维模式上说：</p><ul><li>命令式编程：『过程导向』，<strong>强调怎么做</strong>——关注点在执行步骤，如何一步一步地去完成任务；</li><li>函数式编程：『结果导向』，<strong>强调做什么</strong>——关注点在执行结果，相比属于更高层次的抽象，并不关心实现细节。</li></ul><p>从理论依据上说：</p><ul><li>命令式编程：面向计算机的模型，变量、赋值、控制语句等分别对应计算机的物理存储、读写指令、跳转指令；</li><li>函数式编程：面向数学的模型，将任务以表达式求值的形式表现。</li></ul><p>从实现手法上说：<br>函数式编程是对命令式编程进一步的抽象，屏蔽具体细节，以更加抽象、更加接近自然语言的方式去描述程序的意图，将实现细节交由语言运行时或三方扩展去完成。<br>从而，开发人员可以从实现细节中解脱出来，站在更高的抽象层次上去思考业务问题。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>纯函数、高阶函数、函数一等公民身份、集合操作三板斧等理念极大地提高了语言的创造力、表现力。<br>虽然无法做到纯函数式，但越来越多的高级语言开始向函数式方向发展，将函数式中的若干重要理念引入自身语法中，如：JavaScript、Swift、Java、dart 等。</p><h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><hr><p>函数式编程中的『函数』并非我们日常开发中所说的函数(方法)，而是数学意义上的函数——映射。<br>我们知道数学上函数(映射)对相同的输入必定有相同的输出(映射关系是一一对应的)。<br>因此，函数式编程中纯函数也要满足同样的特征：</p><ul><li>相同的输入，必定得到相同的输出；</li><li>函数调用没有任何副作用。</li></ul><h2 id="相同的输入，相同的输出"><a href="#相同的输入，相同的输出" class="headerlink" title="相同的输入，相同的输出"></a>相同的输入，相同的输出</h2><p>要满足这一点，意味着函数不能依赖除入参以外的任何外部状态。<br>面向对象中类的成员函数隐式地包含<code>this</code>指针，通过它可以很方便地在成员函数中引用成员变量，这就是纯函数的典型反面教材。</p><p>为什么？<br>实现了函数级的解耦，除了入参没有复杂的依赖关系，这样的函数可读性、可维护性就变得很高。<br>相信大家在平常开发中，也能有这样的感受：<br>在理解、维护一个函数时，若其依赖了大量的外部状态，必定会造成不小的认知压力。<br>除了要理解函数本身的逻辑外，还要去关心其引用的外部状态信息。<br>有时不得不跳出函数本身去查看这些依赖的外部信息，阅读流程也因此被打断。</p><h2 id="无副作用"><a href="#无副作用" class="headerlink" title="无副作用"></a>无副作用</h2><p>副作用是指除期望的函数输出值外的任何产出。</p><p>常见的副作用包括，但不限于：</p><ul><li>改变外部数据(如类的成员变量、全局变量)；</li><li>发送网络请求；</li><li>读写文件；</li><li>执行DB操作；</li><li>获取用户交互信息(用户输入)；</li><li>读取系统状态信息；</li><li>打日志；</li><li>…</li></ul><p>总之，纯函数就是不能与外部有任何的耦合关系，包括对外界的依赖以及对外界的影响。</p><p>很明显，纯函数的收益主要有：</p><ul><li>可维护性更高；</li><li>可测性更强；</li><li>可复用性更好；</li><li>高并发更容易，没有多线程问题；</li><li>可缓存，由于相同的输入，必定有相同的输出，因此对于高频、昂贵的操作可以缓存结果，避免重复计算。</li></ul><p>在实际开发中，虽然无法做到所有函数都是纯函数，但纯函数意识应该要深植我们脑海中，尽可能地写更多的纯函数。</p><h1 id="高阶函数-Higher-order-function"><a href="#高阶函数-Higher-order-function" class="headerlink" title="高阶函数(Higher-order function)"></a>高阶函数(Higher-order function)</h1><hr><p>函数式编程还有一个重要理念：<strong>函数是值</strong>，即一等函数(first-class)，或者说函数有一等公民身份。<br>这意味着任何可以使用值的地方都可以使用函数，如参数、返回值等。</p><p>所谓高阶函数就是其参数或返回值至少有一个是函数类型。<br>高阶函数使得复用粒度降到了函数级别，在面向对象中复用粒度一般在类级别。</p><blockquote><p>闭包(closure)是高阶函数得以实现的底层支撑能力。</p></blockquote><p>从另一个角度讲，高阶函数也实现了更高层级的抽象，因为实现细节可以通过参数的形式传入，即在函数级别上实现了依赖注入机制。因此，多种GoF设计模式可以通过高阶函数的形式来实现，如：Template Method模式、Strategy模式等。</p><h1 id="柯里化-Currying"><a href="#柯里化-Currying" class="headerlink" title="柯里化(Currying)"></a>柯里化(Currying)</h1><hr><p>简单讲，柯里化就是将『多参数函数』转换成『一系列单参数函数』的过程。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addCurrying = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，<code>add</code>是进行加法运算的函数，其接收2个参数，如<code>add(1, 2)</code>。<br>而<code>addCurrying</code>是经过柯里化处理过的，本质上<code>addCurrying</code>是单参数函数，其返回值也是一个单参数函数。<br><code>add(1, 2)</code>，等价于<code>addCurrying(1)(2)</code>。</p><p>柯里化有什么作用？</p><ul><li>在函数式集合操作上，如：<code>filter</code>、<code>map</code>、<code>reduce</code>、<code>expand</code>等只接收单参数函数，因此如果现有的函数是多参数，可通过柯里化转换成单参数；</li><li>当某个函数需要多次调用，且部分参数相同时，通过柯里化可以减少重复参数样板代码。</li></ul><p>如，有多次调用加法运算的需求，且每次都是加<code>10</code>时，用普通<code>add</code>函数实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(10, 1);</span><br><span class="line">add(10, 2);</span><br><span class="line">add(10, 3);</span><br></pre></td></tr></table></figure></p><p>而通过柯里化的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var addTen = addCurrying(10);</span><br><span class="line">addTen(1);</span><br><span class="line">addTen(2);</span><br><span class="line">addTen(3);</span><br></pre></td></tr></table></figure></p><p>著名的 JavaScript 三方库<code>lodash</code>提供了<code>curry</code>封装函数，使得柯里化更加方便，如上面的<code>addCurrying</code>用<code>lodash#curry</code>函数实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var curry = require(&apos;lodash&apos;).curry;</span><br><span class="line">var addCurrying = curry(function(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>对函数式编程来说，柯里化是一项不可或缺的技能。<br>对我们而言，即使不写函数式的代码，在解决重复参数等问题上柯里化也提供了一种全新的思路。</p><h1 id="集合操作三板斧"><a href="#集合操作三板斧" class="headerlink" title="集合操作三板斧"></a>集合操作三板斧</h1><hr><blockquote><p>函数式编程语言和面向对象语言对待代码重用的方式不一样。面向对象语言喜欢大量地建立有很多操作的各种数据结构，函数式语言也有很多的操作，但对应的数据结构却很少。面向对象语言鼓励我们建立专门针对某个类的方法，我们从类的关系中发现重复出现的模式并加以重用。函数式语言的重用表现在函数的通用性上，它们鼓励在数据结构上使用各种共通的变换，并通过高阶函数来调整操作以满足具体事项的要求。</p></blockquote><blockquote><p>在面向对象的命令式编程语言里面，重用的单元是类和用作类间通信的消息，通常可以表述成一幅类图(class diagram)。例如这个领域的开拓性著作《设计模式：可复用面向对象软件的基础》就给每一个模式都至少绘制了一幅类图。在OOP的世界里，开发者被鼓励针对具体的问题建立专门的数据结构，并以方法的形式，将专门的操作关联在数据结构上。函数式编程语言选择了另一种重用思路。它们用很少的一组关键数据结构(如list 、set 、map)来搭配专为这些数据结构深度优化过的操作。我们在这些关键数据结构和操作组成的一套运转机构上面，按需要“插入”另外的数据结构和高阶函数来调整机器，以适应具体的问题。例如我们已经在几种语言中操练过的filter函数，传给它的代码块就是这么一个“插入”的部件，筛选的条件由传入的高阶函数确定，而运转机构则负责高效率地实施筛选，并返回筛选后的列表。<br>——<a href="https://book.douban.com/subject/26587213/" target="_blank" rel="noopener">摘录来自: [美] 福特（Neal Ford）. “函数式编程思维 (图灵程序设计丛书)。”</a></p></blockquote><p>正如上述摘录所说，函数式编程的又一重要理念：<strong>在有限的集合(Collection)上提供丰富的操作</strong>。<br>现在，很多高级语言都提供了大量对集合操作的支持，如Swift、Java 8、JavaScript、dart等。<br>通过这些高度抽象的操作，可以写出非常简洁、易读的代码。</p><p>下面对一些常见集合操作作一个简要介绍。</p><h2 id="过滤-filter"><a href="#过滤-filter" class="headerlink" title="过滤(filter)"></a>过滤(filter)</h2><p>过滤就是将列表中不满足指定条件的元素过滤掉，满足条件的元素以新列表的形式返回。<br>在不同的语言中，该操作的名称有所不同：JavaScript、Swift、Java 8中是<code>filter</code>，dart是<code>where</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">filter(callback(element[, index[, array]])[, thisArg]);</span><br></pre></td></tr></table></figure></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;E&gt; where(<span class="built_in">bool</span> test(E element));</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(<span class="number">_</span> isIncluded: <span class="params">(<span class="keyword">Self</span>.Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">Self</span>.<span class="type">Element</span>];</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到，各语言表现形式上虽有所不同，但本质是一样的，即为<code>filter</code>注入一个回调，用于判断其中的元素是否满足指定条件。</p><p>如下例，将年龄未满18的过滤掉：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> ages = [<span class="number">19</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">30</span>, <span class="number">11</span>, <span class="number">18</span>];</span><br><span class="line"><span class="keyword">const</span> result = ages.filter(<span class="function"><span class="params">age</span> =&gt;</span> age &gt;= <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);    <span class="comment">// 19, 30, 18</span></span><br></pre></td></tr></table></figure></p><p>通过循环语句实现就不在这列了，两者的对比应该是很明显的。</p><h2 id="映射-map"><a href="#映射-map" class="headerlink" title="映射(map)"></a>映射(map)</h2><p>map就是将集合中的每个元素进行一次转换，得到一个新的值，其类型可以相同也可以不同。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>);</span></span><br></pre></td></tr></table></figure></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;T&gt; map&lt;T&gt;(T f(E e));</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>];</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure><p>map是日常开发中使用频率最高的操作之一，如将json转换成dart对象实例：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsons.map((json) =&gt; BusinessModel.fromJson(json)).toList();</span><br></pre></td></tr></table></figure></p><h2 id="折叠-化约-reduce、fold"><a href="#折叠-化约-reduce、fold" class="headerlink" title="折叠/化约(reduce、fold)"></a>折叠/化约(reduce、fold)</h2><p>折叠简单讲就是将指定操作依次作用于集合每个元素上，操作结果按操作规则依次叠加，并最终返回该叠加结果(结果类型一般是一个具体的值，而不是Iterable，因此经常出现在链式调用的末端。)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]);</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">E reduce(E combine(E value, E element))</span><br><span class="line">T fold&lt;T&gt;(T initialValue, T combine(T previousValue, E element));</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;Result&gt;<span class="params">(<span class="number">_</span> initialResult: Result, <span class="number">_</span> nextPartialResult: <span class="params">(Result, Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，dart提供了两个操作方法<code>reduce</code>、<code>fold</code>，主要区别在于后者可以提供折叠时的初始值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>,];</span><br><span class="line"><span class="comment">// reduceResult: 25</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">int</span> reduceResult = nums.reduce((value, elemnt) =&gt; value + elemnt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foldResult: 35</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">int</span> foldResult = nums.fold(<span class="number">10</span>, (value, elemnt) =&gt; value + elemnt);</span><br></pre></td></tr></table></figure><p>如上例，<code>reduce</code>是直接对列表元素求和(结果是25)，而<code>fold</code>在求和时提供了初始值10(结果是35).</p><p><img src="/img/reduce.png" alt=""><br><img src="/img/fold.png" alt=""><br>以上<code>reduce</code>、<code>fold</code>都是从左往右进行折叠，有的语言还提供了从右往左折叠的版本，如JavaScript:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure></p><blockquote><p>集合操作还有很多，在此不一一列举。当开始使用这些操作后，会惊奇地发现根本停不下来！</p></blockquote><p>集合上的操作还有一个重要特性：<strong>不可变性(immutable)</strong>，即这些操作不会改变它们正在作用的集合，而是生成新集合来提供操作结果。</p><blockquote><p>有很多的模式或框架都有类似的思想，如：flux、redux、bloc等，它们都强调(强制)任何操作都不能直接修改现有数据，而是在现有数据的基础上生成新数据，最终整体替换掉老数据。</p></blockquote><blockquote><p>在实际开发中我们也遇到过类似的问题，网络请求在子线程返回数据后直接修改了数据源，导致出现数据不同步的多线程问题。最好的解决方案是网络请求返回后在子线程组装好完整的数据，再到主线程进行一次性替换。</p></blockquote><p>不可变性很好地避免了中间状态、状态不同步等问题，也较好地规避了多线程问题。<br>同时，不变性语义使得代码可读性、维护推理性变得更好。</p><p>因为，通过<code>filter</code>、<code>map</code>、<code>reduce</code>等操作，而不是<code>for</code>、<code>while</code>循环语句操作集合，可以清楚地表达将会生成一个新集合，而不是修改现有集合的意图，代码更加简洁明了。</p><p>另外，由于集合上的这些操作的返回值类型大都是集合，因此，当有多个操作作用于集合时，就可以以链式调用的方式实现。这也进一步简化了代码。<br>看一个 flutter 的例子：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imperative flutter</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">memberIconURLs</span><br><span class="line">  .where(_isValidURL)</span><br><span class="line">  .take(<span class="number">4</span>)</span><br><span class="line">  .map(_memberWidgetBuilder)</span><br><span class="line">  .fold(stack, _addMemberWidget2Stack);</span><br></pre></td></tr></table></figure></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional flutter</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">String</span> url <span class="keyword">in</span> memberIconURLs) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_isValidURL(url)) &#123;</span><br><span class="line">    Widget memberWidget = _memberWidgetBuilder(url);</span><br><span class="line">    _addMemberWidget2Stack(stack, memberWidget);</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (count &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个代码片段分别用函数式集合操作、普通<code>for</code>循环语句实现相同的功能：将从后台获取的用户头像<code>url</code>转换成头像<code>widget</code>显示在界面上(最多显示4个，同时过滤掉无效<code>url</code>)。</p><p><img src="/img/stackusericon.jpeg" alt=""></p><p>再看个例子，进一步感受一下两者的差异：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imperative JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> excellentStudentEmails_I = <span class="function"><span class="keyword">function</span>(<span class="params">students</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> emails = [];</span><br><span class="line">  students.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">      emails.push(item.email);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> emails;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> excellentStudentEmails_F = <span class="function"><span class="params">students</span> =&gt;</span></span><br><span class="line">  students</span><br><span class="line">    .filter(<span class="function"><span class="params">_</span> =&gt;</span> _.score &gt;= <span class="number">90</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">_</span> =&gt;</span> _.email);</span><br></pre></td></tr></table></figure><p>上面这两段代码都是获取成绩&gt;=90分学生的 email。</p><p>很明显，函数式实现的代码简洁、易读、逻辑清晰、不易出错<br><code>for</code>循环版本需要很小心地维护实现上的细节问题，还引入了不必要的中间状态：<code>count</code>、<code>url</code>、<code>memberWidget</code>、<code>emails</code>等，这些都是滋生 bug 的温床！</p><p>好了，说到减少中间状态就不得不提 Pointfree。</p><h1 id="Pointfree"><a href="#Pointfree" class="headerlink" title="Pointfree"></a>Pointfree</h1><hr><p>仔细分析上节获取成绩&gt;=90分学生 email 的函数式版本，发现整个过程其实可以分为2个独立的步骤：</p><ul><li>过滤出成绩&gt;=90分的学生；</li><li>取学生的 email。</li></ul><p>将这两个步骤独立成2个小函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">excellentStudents</span>(<span class="params">students</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> students</span><br><span class="line">    .filter(<span class="function"><span class="params">_</span> =&gt;</span> _.score &gt;= <span class="number">90</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emails</span>(<span class="params">students</span>) </span>&#123;</span><br><span class="line">  students</span><br><span class="line">    .map(<span class="function"><span class="params">_</span> =&gt;</span> _.email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时<code>excellentStudentEmails</code>就可以写成下面这样了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> excellentStudentEmails_N = </span><br><span class="line">  students =&gt; emails(excellentStudents(students));</span><br></pre></td></tr></table></figure></p><p>这种嵌套调用的写法好像看不出有什么优势。<br>但有一点可以明确：一个函数的输出(<code>excellentStudents</code>)直接成为另一个函数的输入(<code>emails</code>)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> x =&gt; f(g(x));</span><br></pre></td></tr></table></figure><p>我们引入另外一个函数：<code>compose</code>，其入参为两个单参数函数(<code>f</code>、<code>g</code>)，输出还是一个单参数函数(<code>x =&gt; f(g(x))</code>)。<br>通过<code>compose</code>来改写<code>excellentStudentEmails</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> excellentStudentEmails_C = compose(emails, excellentStudents);</span><br></pre></td></tr></table></figure></p><p>相比嵌套调用版本<code>excellentStudentEmails_N</code>，组合版本<code>excellentStudentEmails_C</code>具有以下两点优势：</p><ul><li>可读性更好，从右往左而不是由内而外的阅读顺序更符合我们的思维习惯；</li><li><code>excellentStudentEmails_C</code>版本自始至终从未提及要操作的数据，减少了中间状态信息(状态越多越容易出错)。</li></ul><p>没有中间状态，没有参数，数据直接在组合的函数间流动，这也是 Pointfree 最直接的定义。<br>从本质上说，Pointfree 就是通过一系列『通用函数的组合』来完成更复杂的任务，其设计理念：</p><ul><li>鼓励写高内聚、可复用的『小』函数；</li><li>强调『组合』，而非『耦合』，复杂任务通过小任务组合完成，而不是将所有操作耦合在一个『大』函数里。</li></ul><p>组合后的函数就像是用管道连接的一样，数据在其中自由流动，无须外界干预：</p><p><img src="/img/pipe.png" alt=""></p><blockquote><p>在 UNIX shell 命令中有专门的管道命令 ‘|’，如：ls | grep Podfile，组合了 ls 与 grep 命令，用于判断当前目录下是否有 Podfile 文件。</p></blockquote><blockquote><p>注意，对于<code>excellentStudentEmails</code>来说，<code>excellentStudentEmails_F</code>版本是更好的写法，<code>excellentStudentEmails_C</code>只是用于解说 Pointfree 的概念。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>我们不奢望，也没办法做到纯函数式的编程，但函数式编程中很多优秀的设计理念都值得我们去学习和借鉴：</p><ul><li>状态不可变，避免过多的中间状态；</li><li>纯函数；</li><li>高内聚的小函数；</li><li>多用组合；</li><li>做好抽象，屏蔽细节；</li><li>…</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://legacy.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details" target="_blank" rel="noopener">JS 函数式编程指南</a><br><a href="https://book.douban.com/subject/26587213/" target="_blank" rel="noopener">函数式编程思维</a><br><a href="https://www.zhihu.com/question/28292740" target="_blank" rel="noopener">什么是函数式编程思维</a><br><a href="https://martinfowler.com/articles/collection-pipeline/" target="_blank" rel="noopener">Collection Pipeline</a><br><a href="https://github.com/getify/Functional-Light-JS" target="_blank" rel="noopener">Functional-Light JavaScript</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数式编程中有很多优秀的设计理念值得我们去学习，本文对函数式编程中的基础理念进行了简要的介绍，但更重要的是思考、总结如何将它们应用到我们日常开发中，帮助我们去提升代码的可读性、可维护性等。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://zxfcumtcs.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="函数式" scheme="http://zxfcumtcs.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS 高效开发解决方案</title>
    <link href="http://zxfcumtcs.github.io/2018/12/22/Efficient-Development-Solutions/"/>
    <id>http://zxfcumtcs.github.io/2018/12/22/Efficient-Development-Solutions/</id>
    <published>2018-12-22T09:36:54.000Z</published>
    <updated>2018-12-23T16:21:35.228Z</updated>
    
    <content type="html"><![CDATA[<p>本文作为 QQ 阅读 7.0 改版总结，从架构、页面元素模块化、UI 组件化、基于 iOS 系统响应链的事件处理、业务模板化等方面阐述了一套高效的列表类应用开发解决方案。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><hr><p>QQ 阅读迎来了7.0版本，作为惯例大版本需要大动作——『UI大改版』。<br>本文主要是对这次改版的一个总结并提炼出一套通用的『列表类业务』开发解决方案。<br>本文将从以下几个方面展开讨论：</p><ul><li>架构</li><li>页面元素模块化</li><li>UI 组件化</li><li>基于响应链的事件处理</li><li>业务模板化</li></ul><blockquote><p>本文部分内容来自<a href="https://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/">列表类应用场景模板化</a>和<a href="https://zxfcumtcs.github.io/2017/03/04/CustomUIControls/">自定义 UI 组件库</a></p></blockquote><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><hr><p>列表类业务应该说是大多数 App 的主要业务场景，如朋友圈、新闻类 App 首页、各类个性化推荐页、微博首页以及我们的书城等等。</p><p>列表类业务其流程主要是：</p><ul><li>从网络或本地磁盘获取数据；</li><li>再将数据以列表(<code>UITableView</code>、<code>UICollectionView</code>)形式展示出来；</li><li>最主要的交互就是点击进入次级页面。</li></ul><p>对于列表类业务每个项目团队可能都有一套架构，在 QQ 阅读不断迭代的过程中也演化出一套架构。<br><img src="/img/ListSceneClassDiagram.png" alt=""><br><img src="/img/ListSceneTimingDiagram.png" alt=""><br>上面分别是我们这套架构的关键类图和时序图。整体上是由经典 MVC 模式演化而来：</p><ul><li>Manager(Interface)：对应 MVC 中的 Model 『层』，主要负责数据的获取、管理等业务逻辑；</li><li>Controller：各个模块的协调枢纽，页面的承载主体；</li><li>Cell\View：对应 MVC 中的 View，仅仅负责 UI 布局、展示逻辑；</li><li>ViewModel(Interface)：View 与具体业务的中间抽象层，使两者解耦，达到 View 只负责 UI 布局的目的，最终实现 View 的高可复用性；</li><li>Module(Interface)： 称其为『业务模块』，一个页面由多个不同或相同类型的模块组成。</li></ul><h1 id="页面元素模块化"><a href="#页面元素模块化" class="headerlink" title="页面元素模块化"></a>页面元素模块化</h1><hr><p>MVC 模式饱受诟病的一点就是：Controller 经常会变得过于臃肿(Massive View Controller)。<br>为了解决这一问题，业界提出了多种解决方案，大部分都是通过添加中间层，将 Controller 的功能分解到中间层上，如 MVP (Model View Presenter) 模式。</p><p>为了解决 Controller 臃肿问题，在我们的架构中将页面元素抽象成一个个的 Module。<br><img src="/img/bookcitymodules.png" alt=""><br>如上图，红色虚线分隔的就是不同的 Module。从此，页面的生成过程就是拼接组装 Module 的过程。</p><p>在 TableView 中一个 Module 对应一个 section。<br>Module 的职责主要有：</p><ul><li>解析、存储业务数据(如今日必读 Module 需要负责解析、存储今日必读这块业务数据)；</li><li>为 TableView 提供数据(即实现<code>UITableViewDataSource</code>协议)；</li><li>处理用户事件；</li><li>埋点；</li><li>…</li></ul><p>——即负责『模块』的所有逻辑(与 React Component 类似)。</p><h2 id="Manager-与-Module"><a href="#Manager-与-Module" class="headerlink" title="Manager 与 Module"></a>Manager 与 Module</h2><p>通过上述分析可知，Module 解析、存储业务数据，Manager 存储、管理 Module。</p><p>这种做法也存在弊端，由于将解析业务数据、控制 UI 展示的逻辑(创建 cell 等)都放在了 Module 中。使得 Module 违反了『单一职责原则』。</p><blockquote><p>『单一职责原则』(SRP)作为面向对象设计的五大原则『SOLID』之一，很容易理解，也很难把握！『就好像生活中的各种”适量”，适量放点盐、适量加点水…』<br> Bob大叔在《敏捷软件开发》中，将类的单一职责原则描述为『应该仅有一个引起它变化的原因』。</p></blockquote><p>在 Module 中，业务数据解析、UI 展示就是两个可变的因素——『同样的 UI 用于展示不同的网络协议返回的数据、同一协议返回的数据展示为不用的 UI』。<br>在 QQ 阅读中，书籍列表页就属于『同样的 UI 展示不同协议返回的数据』：<br><img src="/img/BookList.jpeg" alt=""><br>针对这种情况，无非就是将其中一个变化因子抽取出来，如将业务数据解析抽取为一个单独的类。<br>由于 Module 中这两个变化因子变动的概率并不大，为了降低复杂度，只有在真正需要时才将这两者分离开。</p><blockquote><p>『敏捷开发』的原则之一就是尽量保持代码简单、并在必要时进行重构，防止代码变坏。</p></blockquote><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    QRBaseModule *module = [<span class="keyword">self</span>.manager moduleAtIndex:indexPath.section];</span><br><span class="line">    <span class="keyword">return</span> [module heightForRow:indexPath.row];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    QRBaseModule *module = [<span class="keyword">self</span>.manager moduleAtIndex:section];</span><br><span class="line">    <span class="keyword">return</span> [module numberOfRows];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    QRBaseModule *module = [<span class="keyword">self</span>.manager moduleAtIndex:indexPath.section];</span><br><span class="line">    <span class="keyword">return</span> [module cellForRow:indexPath.row tableView:tableView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.manager moduleCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码，模块化后<code>UITableViewDelegate</code>、<code>UITableViewDataSource</code>的大部分方法都转发给相应的 Module 去处理，大大简化了 Controller 的复杂度。</p><p>另外，在页面上增删任何元素都只需在 Manager 中增删相应的 Module 即可，Controller 无需任何改动——在 Controller 层面遵守了开放-封闭原则『OCP』。</p><blockquote><p>模块化不仅简化了 Controller，同时也提高了代码的复用性。Module 可以在不同页面间复用。如果这些逻辑全部放在 Controller 里，基本没有复用性可言。</p></blockquote><p>模块化有没有缺点？<br>答案是肯定的😒<br>模块化会增加类的数量、方法的数量(每个 Module 都要实现<code>UITableViewDelegate</code>、<code>UITableViewDataSource</code>的部分方法)。</p><p>当然啦，个人认为利大于弊😊</p><h1 id="UI-组件化"><a href="#UI-组件化" class="headerlink" title="UI 组件化"></a>UI 组件化</h1><hr><p>QQ 阅读7.0改版，UI 修改的工作量占大头，涉及200多个页面的修改。<br>此时，充分体现出 UI 复用的重要性。</p><p>虽然，我们很早就提出通过 View-ViewModel 的方式实现 UI 组件化，提高复用性。<br>遗憾的是，由于历史原因，在我们的工程中依然存在大量重复的实现，即『同一 UI 样式，N 份实现』。这对于 UI 大改版是灾难性了！——「不仅工作量成倍增加，还有漏改的可能性」</p><p>为了避免灾难再次上演(8.0、9.0…)，此次改版过程中，我们严格要求所有 UI 都必须以 View-ViewModel 模式做成 UI 组件。</p><h2 id="UI-组件"><a href="#UI-组件" class="headerlink" title="UI 组件"></a>UI 组件</h2><p>在继续之前，我们简单描述一下什么是 UI 组件：</p><ul><li>可复用的 UI 单元；</li><li>UI 组件可包含子 UI 组件；</li></ul><p>同时，我们将 UI 组件分为外部 UI 组件、内部 UI 组件：</p><ul><li><p>外部 UI 组件——与视觉对接，默认含有上下左右边距，为了提高其复用性，需实现<code>QRExternalUIComponent</code>协议，使得业务方可灵活控制其边距；</p><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">QRExternalUIComponent</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setEdgeInsets:(<span class="built_in">UIEdgeInsets</span>)edgeInsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p>内部 UI 组件——肯定是子 UI 组件，用于构造更大的 UI 组件，为了提高其复用性，同时控制复杂度，切边实现。</p></li></ul><p><img src="/img/fourbookUIComponent.png" alt=""><br>如上图，整体是一个四书的对外 UI 组件，含有视觉要求的上下左右边距，业务方可直接使用。<br>其中，红色虚线框住的则是一个内部组件，切边实现——没有上下左右边距，四书组件就是由4个这样的内部组件拼接而成。</p><h2 id="复用粒度"><a href="#复用粒度" class="headerlink" title="复用粒度"></a>复用粒度</h2><p><strong><em>复用没把握好火候就变成耦合了。</em></strong><br><strong>例1.</strong><br><img src="/img/banner1.jpeg" alt=""><br><img src="/img/banner2.jpeg" alt=""><br>我们书城顶部 banner 有如上图的推书样式、通栏广告图样式、还有柱状图动画样式。<br>在实现的时候，通通将这些样式塞到一个类里面，通过<code>if...else...</code>区分，这就是严重的耦合，给后面的维护造成很大的困难。<br><strong>例2.</strong><br><img src="/img/fourbook.jpeg" alt=""><br><img src="/img/threebook.jpeg" alt=""><br>三书与四书 UI 也是通过<code>if...else...</code>区分，内部还要处理六书、八书的情况，还要兼容 iPad，内部实现异常复杂，导致大家都不敢去碰这块代码。</p><p>为此，我们制定了如下规则：</p><ul><li>UI 布局相同才复用内部实现，所谓布局相同是指 UI 组件在结构上是相同的，如左边都是一个书封，右边都是两行文字，但书封大小、文字字号不同，则认为布局相同；</li><li><p>UI 布局相同，内部细节不同的，通过 <strong><em>Template Method 模式</em></strong>实现代码复用，但对外提供的 UI 组件是独立的(简化业务层的使用)；</p><blockquote><p>Template Method: Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.<br>此例中 UI 布局就是 Template Method 中的算法结构，而布局的细节则可以通过子类去控制。</p></blockquote></li><li><p>横向展示数量可扩展、纵向固定不变，如三书、六书是同一个 UI 组件，四书、八书是同一个，因为它们可以通过传入的数量控制展示。</p></li></ul><h2 id="隔离变化"><a href="#隔离变化" class="headerlink" title="隔离变化"></a>隔离变化</h2><p>我们经常吐槽 QQ 阅读 UI 的多样性在业界能排 Top1。<br><img src="/img/singlebook.jpeg" alt=""><br>如上图单书组件，其中红框框住的部分就有15、16种变<strong><em>幻</em></strong>。<br>为此，我们将这部分抽取出来，作为单书组件的一个子组件由使用方负责构造该子组件并传给单书组件去展示。</p><p>好了，下面进入本节的正题，如何构造出复用性高的 UI 组件。</p><h2 id="以-View-ViewModel-形式构建-UI-组件"><a href="#以-View-ViewModel-形式构建-UI-组件" class="headerlink" title="以 View-ViewModel 形式构建 UI 组件"></a>以 View-ViewModel 形式构建 UI 组件</h2><p>高可复用的 UI 组件，至少要满足以下两点：</p><ul><li>UI 组件不能与具体业务数据相绑定；</li><li>UI 组件内部不能处理业务逻辑——其本职工作仅是 UI 布局。</li></ul><p>总之，UI 组件要与业务解耦。<br>此时，MVVM 模式进入我们的视线，在该模式中 ViewModel 的存在是不是很好的解决了上面的问题。<br>在 MVVM 模式中，ViewModel 向上为 View 提供展示数据（该数据已经在 ViewModel 中处理好了，View 无需任何处理，只要展示即可），向下接收来自业务层的数据，处理相关的业务展示逻辑。</p><p>可以看出，ViewModel 作为中间层很好地将业务与 UI 隔离开。<br>说到 MVVM，很多同学并不喜欢，觉得其中的 Data-Binding 很麻烦，但我们构建 UI 组件时用到的是 View-ViewModel 结构，并不要求一定是 MVVM，在 MVC 等模式下也可使用。</p><p>同时，我们采用的是面向接口的模式，View 对外依赖的是接口（protocol），而不是某个具体的 ViewModel。每个 UI 组件其结构如下：<br><img src="/img/ViewViewModel.png" alt=""><br>如上图所示，若某个 UI 组件被多个业务所复用，可以根据需求定义多个 ViewModel 以处理不同的业务逻辑，每个 ViewModel 都实现<code>ViewModelProtocol</code>协议为 View 提供数据。</p><p>如上文提到的单书 UI，我们抽取为一个组件<code>QRLeftPictureRightTextView</code>：<br><img src="/img/QRLeftPictureRightTextView.png" alt=""><img src="/img/QRLeftPictureRightTextViewModel.png" alt=""><br>该组件在信息流以及书城都有用到，为此定义了两个 ViewModel，以处理各自的业务逻辑：<br><img src="/img/QRLeftPictureRightText.jpg" alt=""></p><p>至此，UI 组件化部分的内容基本结束。<br>在 QQ 阅读7.0版本中，实现了『同一 UI 样式，只有一份实现』，个人看来是一件很有意义的事情：</p><ul><li>提高开发效率，不必重复造轮子，工程代码得到很好的规范；</li><li>减轻了设计师的工作，对于复用的组件，设计师只需在设计稿中标出组件编号即可；</li><li>降低了开发与设计师的沟通成本；</li><li>为下次大改版奠定了很好的基础。</li></ul><blockquote><p>Module 与 UI 组件在两个不同的层面实现复用。</p></blockquote><h1 id="基于响应链的事件处理"><a href="#基于响应链的事件处理" class="headerlink" title="基于响应链的事件处理"></a>基于响应链的事件处理</h1><hr><p>现有的事件处理方案有两大痛点，于是提出了基于响应链『Chain of Responsibility』的事件处理方案。</p><ul><li><p>痛点1<br><img src="/img/ViewHierarchy.png" alt=""><br>大多数场景下 View 的层级结构如上图所示。我们知道，View 一般不处理用户事件，需要逐级向上传递给 Controller，因此需要沿着上图的层级结构逐级传递处理事件的 delegate。这种单调、重复、琐碎的代码非常令人不悦：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell.delegate <span class="built_in">=</span> controller;</span><br><span class="line">view.delegate <span class="built_in">=</span> cell;</span><br><span class="line">…</span><br></pre></td></tr></table></figure></li><li><p>痛点2<br>随着版本的迭代，不同类型的 cell/view 极有可能出现不同的事件处理接口，如下图所示：<br><img src="/img/celldelegate.jpeg" alt=""><br>这严重违反了面向对象设计的开闭原则『OCP』——每增加一种 cell 类型此处都需要修改。</p></li></ul><p>尤其是第一点一直困扰着我。直到前不久在《Design Patterns》一书中看到在介绍『Chain of Responsibility』模式时的一句话：『Using existing links works well when the links support the chain you need. It saves you from defining links explicitly, and it saves space』。<br><code>UIResponder</code> 中的 <code>nextResponder</code>不正是这个『existing links』吗！<br>最上层 View 的事件通过<code>nextResponder</code>链就可以顺利传到 ViewController 中，从而也就省去了 delegate 的逐级传递了，痛点1、2随之化解。<br>为此，我们为 <code>UIResponder</code>添加了传递、处理事件的分类：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZSCEvent</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) __kindof <span class="built_in">UIResponder</span> *sender;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *indexPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *userInfo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIResponder</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIResponder</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.nextResponder respondEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>UIResponder</code>的实现只是简单地将事件传递给<code>nextResponder</code>。<br>由于 View 不包含业务数据，所以事件传递的过程中需要不断添加一些信息。</p><blockquote><p>因此，我们将<code>ZSCEvent#userInfo</code>定义为 mutable。正常情况下外露接口一般都是 immutable。</p></blockquote><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableViewCell</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.nextResponder respondEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>如，在<code>UITableViewCell</code>的<code>respondEvent:</code>中需要将<code>sender</code>设置为<code>self</code>，以便在<code>UIViewController</code>中可以通过<code>cell</code>找到对应的 Module。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([event.sender isKindOfClass:<span class="built_in">UITableViewCell</span>.class], <span class="string">@"event sender must be UITableViewCell"</span>);</span><br><span class="line">    <span class="keyword">if</span> (![event.sender isKindOfClass:<span class="built_in">UITableViewCell</span>.class]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = [_tableView indexPathForCell:event.sender];</span><br><span class="line">    <span class="keyword">id</span>&lt;ZSModule&gt; module = [<span class="keyword">self</span>.manager moduleAtIndex:indexPath.section];</span><br><span class="line">    </span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    event.indexPath = indexPath;</span><br><span class="line">    [event.userInfo setObject:_tableView</span><br><span class="line">                       forKey:ZSCEventUserInfoKeys.tableView];</span><br><span class="line">    </span><br><span class="line">    [module handleEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 View 中的事件处理代码可以这样：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_clickedButton:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    ZSCEvent *event = [[ZSCEvent alloc] init];</span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    [event.userInfo setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"clickedButton"</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> respondEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果一个 cell 中有多个事件需要处理，就需要在<code>userInfo</code>中加以区分，如上面代码第<code>5</code>行。</p></blockquote><p>总之，通过<code>UIResponder</code>的<code>nextResponder</code>响应链，不必再在 view 的层级间传递 delegate，减少了琐碎的代码，提高了开发效率。同时也统一规范了事件处理方案。</p><h1 id="业务模板化"><a href="#业务模板化" class="headerlink" title="业务模板化"></a>业务模板化</h1><hr><p><a href="https://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/">列表类应用场景模板化</a>一文对此有详细的描述，在此就不赘述了。<br>其效果还是不错的。<br>很多二级页，由于 Module 是完全复用的，通过模板化脚本<strong><em>半小时</em></strong>就能做好一个二级页✌️。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>简单、高效一直是软件开发、工程管理追求的目标，本文从实际项目经验出发，从架构、解耦、复用等角度总结出一套开发解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文作为 QQ 阅读 7.0 改版总结，从架构、页面元素模块化、UI 组件化、基于 iOS 系统响应链的事件处理、业务模板化等方面阐述了一套高效的列表类应用开发解决方案。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="UI 组件" scheme="http://zxfcumtcs.github.io/tags/UI-%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计原则『SOLID』在开发中的应用</title>
    <link href="http://zxfcumtcs.github.io/2018/10/04/solid/"/>
    <id>http://zxfcumtcs.github.io/2018/10/04/solid/</id>
    <published>2018-10-04T10:07:41.000Z</published>
    <updated>2018-12-31T07:17:39.281Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细分析了面向对象设计五大原则 S(单一职责原则『SRP』)、O(开放-封闭原则 『OCP』)、L(Liskov 替换原则『LSP』)、I(接口隔离原则『ISP』)、D(依赖倒置原则『DIP』)，并假以实例辅之。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>软件设计五大原则『SOLID』以及23种经典设计模式自成型以来已有些年头，目前在实际开发中对待它们有两种较为极端的态度：敬而远之、嗤之以鼻。<br>显然，笔者用了『极端』二字表明并不赞同这样的观点。<br>SOLID 以及经典设计模式是前人在长期的软件开发中总结出来的宝贵实践经验，值得我们学习和借鉴。当然，这并不意味着我们要时刻把它们挂在嘴边，以彰显我们的『内力』，也并不意味着就要把它们作为『最高律令』、『不可逾越的红线』早早地就套用在软件开发的过程中(这无疑将增加开发的复杂性)。<br><strong><em>应将其作为解决问题的方案。</em></strong><br>此时，有必要再谈谈『敏捷开发』：<br>在移动互联网时代大家都是以『小步快跑、快速迭代、快速试错』的节奏与时间赛跑、抢占流量。『敏捷开发』因而被时常提及，遗憾的是其大多数时候也仅是停留在嘴边。<br>在移动互联网时代，笔者认为敏捷开发的核心有两点：</p><ul><li>不做过度设计，始终尽力保持代码简洁、易理解、好维护(不用一开始就套用各种原则、设计模式，徒增复杂)；</li><li>拥抱变化，无论是因需求还是其他原因引起变化导致现有代码结构不能满足需要时，要积极地对代码进行重构，始终保持良好的代码结构，对代码的腐朽保持零容忍(出现问题后可借鉴 SOLID、设计模式等去解决问题)。</li></ul><p>从上述两点可以看出：<strong>敏捷开发是一个持续的过程，而非一个心血来潮的事件。</strong></p><blockquote><p>ps：重构不一定是翻天覆地的大改，重命名变量、分解复杂方法等等都是重构。</p></blockquote><p>本文将以 SOLID 五大设计原则为主线，辅以设计模式为解决方案，谈谈 QQ 阅读、iOS 系统 API 在代码设计上的得失(失主要是对 QQ 阅读个别代码的反思)。</p><h1 id="单一职责原则『SRP』"><a href="#单一职责原则『SRP』" class="headerlink" title="单一职责原则『SRP』"></a>单一职责原则『SRP』</h1><hr><p>SRP 非常好理解，与『内聚性』表达的是同样的关注点。<br>SRP 在 SOLID 五大原则中可以说是最简单、最基础的原则。然而在实际开发中，对 SRP 的把握又是最难的。单一职责，到底什么是职责？单一的粒度如何？总之不好把握，就像生活中的各种适量『煮饭时适量加点水、做菜时适量放点盐』(经常让人抓狂 v_v)。<br>Bob 大叔在《敏捷软件开发》一书中将职责定义为：<strong><em>变化的原因</em></strong>，单一职责即为：<strong><em>仅有一个引起实体(模块、类、方法等)变化的原因</em></strong>。在把握单一职责时，这不失为一个很好的抓手，通过观察、思考设计的实体是否有一个以上的变化原因来判断其职责是否单一。</p><blockquote><p>后文为叙述方便，如无特别说明，实体指模块、类、方法等功能代码块。</p></blockquote><p>笔者认为 SRP 作为最基础的设计原则，主要有两点收益：</p><ul><li>降低实体的复杂度，提升可维护性；</li><li>提高实体的可复用性，当一个实体中耦合了多个职责时，其可复用性必然受到影响。即使多处复用了，其中一个职责的变化对复用其他职责的实体也会造成意想不到的影响，这不是我们想看到的。这也是 Bob 大叔将职责定义为『变化』的原因。</li></ul><h2 id="例1-UIView-与-CALayer"><a href="#例1-UIView-与-CALayer" class="headerlink" title="例1 UIView 与 CALayer"></a>例1 UIView 与 CALayer</h2><p>在 UIView 的层级结构中，我们知道每个 View 背后都有一个 CALayer 与之对应。<br>其中，UIView 的主要职责是处理用户交互，CALayer 则是布局、渲染以及动画等。<br>Apple 之所以要设计 UIView 与 CALayer 两套体系，就是为了使它们的职责更加单一，能更好的复用。<br>在 iOS 与 Mac OS 上，用户交互处理方式有本质的区别，然而在布局、渲染、动画等方面又是一致的。因此，通过将上述职责分离，CALayer 可以很好地在 iOS 与 Mac OS 间复用，而用户交互的处理则各自独立，于是有了 UIKit、AppKit。</p><h2 id="例2-View-与-ViewModel"><a href="#例2-View-与-ViewModel" class="headerlink" title="例2 View 与 ViewModel"></a>例2 View 与 ViewModel</h2><p>例1中的 View 与 Layer 属于系统实现层面，在应用层面 UIView 的职责是明确的、单一的：<strong>UI 布局</strong>。然而在实际开发中有大量展示相关的业务逻辑写到了 View 里面，严重影响了 View 的可复用性。究其原因，在非 MVVM 模式下，展示逻辑只能放在 Controller 中，势必造成 Controller 过于臃肿。于是，在 QQ 阅读中我们提出以 View-ViewModel 模式构建 UI 组件，将展示逻辑放到 ViewModel 中，View 仅处理布局逻辑。目前看效果良好，View 的逻辑更加清晰、可复用性得到很大提高。详细信息请参看<a href="https://zxfcumtcs.github.io/2017/03/04/CustomUIControls/">『自定义 UI 组件库』</a>一文。</p><h1 id="开放-封闭原则-『OCP』"><a href="#开放-封闭原则-『OCP』" class="headerlink" title="开放-封闭原则 『OCP』"></a>开放-封闭原则 『OCP』</h1><hr><p>『唯有变化才是永恒』，对于软件开发来说更是如此，一个模块、类、方法等实体几乎不可能在第一个版本开发出来后就一直保持不变。因此，变化是开发人员必须要面对的问题(可谓爱之恨之)。<br>OCP 就是用于指导我们如何应对变化。<br>OCP 的含义是：『对扩展开放，对修改封闭』。<br>具体说，实体的功能可以不断扩展(变化)，但实体的源码不允许修改。<br>看似十分矛盾！就像『东西可以随便买，但钱不允许花』。<br>仔细分析，OCP 的重点是<strong>扩展新功能</strong>，也就是扩展新功能时可以添加新代码，但不能修改已有代码。因为对已有代码的修改带来的影响是难于预料的，如果修改导致链锁反应，后果更是灾难性的。<br>如何做到？<br><strong>关键在抽象</strong>。<br>『面向接口编程，而非实现编程』这是我们经常挂在嘴边的话。<br>面向接口编程，也就是说依赖的是抽象接口，为的就是可以灵活的替换接口背后的实现。这不正是 OCP 需要的吗！</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>在23种经典设计模式中『Template Method 模式』以及『Strategy 模式』都可以很好地实现 OCP，其中 Template Method 模式的实现依赖于继承，Strategy 模式使用的委托(接口)。</p><h3 id="Template-Method-模式"><a href="#Template-Method-模式" class="headerlink" title="Template Method 模式"></a>Template Method 模式</h3><p><img src="/img/TemplateMethod.png" alt=""><br>Template Method 模式类图如上图所示(来自 GoF 的《Design patterns》)。<br>Template Method 模式在抽象基类中定义 <code>TemplateMethod</code>方法，但该方法并不做实际工作，只是调用其它方法(<code>PrimitiveOperation...</code>，C++中须是虚函数)来完成具体的工作。<br>可见，<code>TemplateMethod</code>方法只是定义了一个任务或算法的骨架、执行步骤。<br>因此，可以通过派生新的子类，并实现<code>PrimitiveOperation...</code>方法来扩展功能。</p><h3 id="Strategy-模式"><a href="#Strategy-模式" class="headerlink" title="Strategy 模式"></a>Strategy 模式</h3><p><img src="/img/Strategy.png" alt=""><br>Strategy 模式类图如上图所示(来自 GoF 的《Design patterns》)。<br>Strategy 模式是典型的面向接口编程，通过接口使得业务层(使用方)与实现细节完全解耦，从而可以很方便地通过扩展实现来扩展新功能，而无须对业务层进行修改。<br>纵观 Template Method 与 Strategy 模式，前者通过继承并重写方法(C++中的虚函数)来扩展新功能，后者通过新增实现了特定接口的类开添加新功能。<br>两者无谓优劣，不同的场景使用不同的方案。但是，继承会增加复杂度，这是共识，在使用 Template Method 模式时需要考虑到这点。</p><h2 id="例1-QQ-阅读登录模块"><a href="#例1-QQ-阅读登录模块" class="headerlink" title="例1 QQ 阅读登录模块"></a>例1 QQ 阅读登录模块</h2><p>QQ 阅读起初只有 QQ 一种登录方式，突然有一天 Apple 爸爸说不得强制用户必须登录才能使用 App。无奈之下，我们添加了游客登录模式。<br><img src="/img/OldLoginClassDiagram.png" alt=""><br>上图就是增加游客登录后的结构简图。QQ 登录、游客登录看似相安无事。<br>但，<strong>众多业务模块</strong>直接与两种登录方式交互，严重破坏了 OCP。<br>后果如何？<br>后果是严重的！后面如果要增加其他登录方式，所有与登录态有关的模块全都要改一遍！</p><blockquote><p>问题出在哪里？笔者认为最初业务层直接与 QQ 登录交互并无大碍，关键是在添加游客登录时需要察觉到其中的问题，并立即做出重构，而不是在现有代码基础上糊乱堆叠代码。</p></blockquote><p>果不其然，没多久产品要求添加微信登录。于是趁机对登录做了一次彻底的重构。<br><img src="/img/NewLoginClassDiagram.png" alt=""><br>重构过程中，我们添加了『鉴权中心』模块<code>QRAuthenticatonCenter</code>统一处理登录相关的问题，同时使用了 Strategy 模式将各种登录方式的实现细节与<code>QRAuthenticatonCenter</code>以及业务层隔离开来。<br>不久之后，我们又添加了起点登录、QQ 登录也由原来腾讯内部的 Wlogin 登录方式切换到统一互联登录。<br>针对这两个变动，业务层无任何修改，<code>QRAuthenticatonCenter</code>也只是添加了初始化<code>QRYWAuthenticator</code>、<code>QROpenQQAuthenticator</code>的代码。变动的主要工作就是按照<code>QRAuthenticatorDelegate</code>接口分别去实现<code>QRYWAuthenticator</code>以及<code>QROpenQQAuthenticator</code>。</p><blockquote><p>通过 Abstract Factory 模式，可以使得在添加新登录方式时<code>QRAuthenticatonCenter</code>也无需修改，但笔者认为在该场景下其带来的收益不足以弥补其复杂性，即弊大于利，故弃之。</p></blockquote><p>上述可见，通过 Strategy 模式重构后的登录模块实现了 OCP，也在后续迭代变更过程中充分享受了其带来的收益。</p><h2 id="例2-QQ-阅读引擎模块"><a href="#例2-QQ-阅读引擎模块" class="headerlink" title="例2 QQ 阅读引擎模块"></a>例2 QQ 阅读引擎模块</h2><p>QQ 阅读的 txt 引擎是整个工程里面最核心，也是最古老的一个模块。<br>起初，引擎里面有两种类型的段落：文字、空段落，并通过一个<code>int</code>型变量<code>type</code>加以表示。<br>随着迭代，越来越多非内容本身的交互性元素加入阅读页，如：作者的话、大神说等等。目前<code>type</code>的值已扩展到十五、六类之多，每添加一种新类型都要在最核心的引擎里面修改一、二十处，可谓如覆薄冰。<br>这就是一个严重违反 OCP，并产生严重后果的例子。<br>找到了问题所在，重构方案也就变得明了：通过 Strategy 模式，将每种类型段落的逻辑抽取成一个类，并遵守相同的接口，txt 引擎依赖抽象接口，使之遵守 OCP。</p><h1 id="Liskov-替换原则『LSP』"><a href="#Liskov-替换原则『LSP』" class="headerlink" title="Liskov 替换原则『LSP』"></a>Liskov 替换原则『LSP』</h1><hr><p>LSP：子类型必须能够替换其基类型。<br>直白点，就是任何使用基类类型的地方(如调用方法时的入参)都能替换成其子类类型，而不会出现意想不到的错误。<br>看完 LSP 的定义，不禁要问：其有何用？<br>为了回答这个问题，不防从反面思考一下：若不遵守 LSP 如何？<br>以方法参数为例：若方法 <code>M</code> 有一个类型为类 <code>B</code> 的参数，如果类 <code>B</code> 的子类没有遵守 LSP，在调用方法 <code>M</code> 时传入了一个类 <code>B</code> 的子类，<code>M</code> 会出错。此时，为了不出错，方法 <code>M</code> 势必要对 <code>B</code> 的子类作特殊处理(<code>if...else...</code>)。<br>熟悉的味道！这是不是违反了 OCP！</p><blockquote><p>引自《敏捷软件开发》：对于 LSP 的违反往往会导致以明显违反 OCP 的方式使用运行时类型识别『RTTI』。</p></blockquote><h2 id="例1-正方形与长方形"><a href="#例1-正方形与长方形" class="headerlink" title="例1 正方形与长方形"></a>例1 正方形与长方形</h2><p>Bob 大叔在《敏捷软件开发》中有一个关于正方形和长方形的例子。<br>『正方形是一种特殊的长方形』，这可谓是常识。因此，让正方形类<code>Square</code>继承自长方形类<code>Rectangle</code>再合理不过。<br>然而在对待长度、宽度上，正方形与长方形似乎不那么一致：<br>正方形的长、宽必须相等，因此<code>Square</code>类必须重写其基类<code>Rectangle</code>的<code>setWidth</code>、<code>setHeight</code>方法来保证每次调用这两个方法后正方形的长宽依然相等。这看上去似乎也并无不妥，然而在下面这个方法中就有问题了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Rectangle &amp;r)</span> </span>&#123;</span><br><span class="line">    r.setWidth(<span class="number">5</span>);</span><br><span class="line">    r.setHeight(<span class="number">4</span>);</span><br><span class="line">    assert(r.area() == <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数<code>g</code>对于长方形的认知完全正确，然而若调用函数<code>g</code>时传入的是个<code>Square</code>类型的引用，就出错了！<br>很明显，<code>Square</code>与<code>Rectangle</code>间的继承关系违反了 LSP。</p><blockquote><p>引自《敏捷软件开发》：LSP 让我们得出一个非常重要的结论：一个模型，如果孤立地看，并不具有真正意义上的有效性。<strong>模型的有效性只能通过它的客户程序来表现。</strong>在考虑一个特定设计是否恰当时，不能完全孤立地来看这个解决方案。必须要根据该设计的使用者所做出的合理假设来审视它。<br><strong><em>因此，是否违反 LSP，在很大程度上取决于客户程序。</em></strong></p></blockquote><p><code>Square</code>与<code>Rectangle</code>间的继承之所以会违反 LSP，是因为在设置长、宽的行为上它们间不具备”IS-A”关系。</p><blockquote><p>引自《敏捷软件开发》：从行为方式的角度来看，<code>Square</code>不是<code>Rectangle</code>，对象的行为方式才是软件真正所关注的问题。LSP 清楚地指出，OOD 中 IS-A 关系是就行为方式而言的，行为方式是可以进行合理假设的，是客户程序所依赖的。</p></blockquote><h2 id="LSP-与多态"><a href="#LSP-与多态" class="headerlink" title="LSP 与多态"></a>LSP 与多态</h2><p>讨论 LSP 的前提就是多态，否则无从谈起。<br>然而，多态本质上就是子类的方法覆盖基类的虚函数。这与 LSP 要求的子类可以替换基类是否矛盾？因为通过基类指针最终调用的是子类的方法。<br>答案自是不矛盾，相反 LSP 能够更好地指导我们如何使用继承。<br>为了满足 LSP，子类只能对基类的功能进行扩展，而不能『篡改』。<br>这不正是『继承』的本质内涵吗！</p><p>因此，LSP至少有三点作用：</p><ul><li>实现 OCP 的重要保障之一；</li><li>降低继承带来的复杂度，继承只能扩展基类的功能，而非『篡改』(可以无差别的对待基类及其所有子类)；</li><li>在决定使用继承前，可以更好地判别两者是否真具有”IS-A”的关系。</li></ul><h2 id="启发式判断规则与改进方案"><a href="#启发式判断规则与改进方案" class="headerlink" title="启发式判断规则与改进方案"></a>启发式判断规则与改进方案</h2><p>LSP 有时是很微妙的，在开发过程中往往难于察觉。<br>Bob 大叔提出两个启发式规则供大家参考：</p><ul><li><p>派生类存在退化函数，如下述代码基类<code>Base</code>中的方法<code>f</code>是有功能的，但到其子类<code>Derived</code>中<code>f</code>退化为空方法，这往往预示违反了 LSP，值得警惕：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/*some code*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> calss Derived : Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从派生类中抛出异常，即从派生类的方法中抛出了基类不会抛出的异常，这往往是调用方不曾预料的。</p></li></ul><p>违反 LSP 说明继承已经不适合了，此时可以将这对『父子』中公共的代码提取出来。<br>之后要么让他们成为『兄弟』，都从提取的代码派生、要么以组合的方式集成提取的代码。</p><h1 id="接口隔离原则『ISP』"><a href="#接口隔离原则『ISP』" class="headerlink" title="接口隔离原则『ISP』"></a>接口隔离原则『ISP』</h1><hr><p> ISP：不应迫使客户程序依赖于它们不需要的接口。即，客户程序依赖的类中不应该含有其不需要的方法，从而降低系统的复杂度，减少类之间的耦合。<br>相反，若某客户程序依赖的类含有大量其不需要的方法，而这些方法又是其他客户程序所需的，当这些方法因需求需要变化时或需要添加新方法时，势必会殃及不需要这些方法的客户程序，从而增加系统的耦合度。<br>怎么解决？<br>当然是『隔离、拆分』接口了！<br>在支持接口/协议的语言(如Objective-C)中，很好处理，将类的公共方法分解到多个接口中；<br>而在像 C++ 这样不支持接口的语言中，可通过多继承、委托等方式分解接口。</p><h2 id="例1-UITableView-之-DataSource、Delegate"><a href="#例1-UITableView-之-DataSource、Delegate" class="headerlink" title="例1 UITableView 之 DataSource、Delegate"></a>例1 UITableView 之 DataSource、Delegate</h2><p>iOS 开发对 UITableView 恐是再熟悉不过了，其提供了两套接口：<code>UITableViewDataSource</code>、<code>UITableViewDelegate</code>。<br>从场景上说，这两套接口都是为 UITableView 提供服务的。<br>之所以要把它们分开，就是为了可以将为 UITableView 提供数据、处理用户交互的职责拆分到不同的类中。</p><h2 id="例2-QQ-阅读登录接口"><a href="#例2-QQ-阅读登录接口" class="headerlink" title="例2 QQ 阅读登录接口"></a>例2 QQ 阅读登录接口</h2><p>在『OCP』一节，简要介绍了 QQ 阅读的登录模块，我们知道具体的登录细节由<code>QRQQAuthenticator</code>、<code>QRWechatAuthenticator</code>以及<code>QRGuestAuthenticator</code>等处理。这些<code>Authenticator</code>都实现了<code>QRAuthenticatorDelegate</code>接口：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">QRAuthenticatorDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主动登录</span></span><br><span class="line">- (<span class="keyword">void</span>)authenticateWithCompletion:(QRAuthenticateCompletion)completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 续期</span></span><br><span class="line">- (<span class="keyword">void</span>)refreshTokenWithCompletion:(QRAuthenticateCompletion)completion;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>然而，对于 QQ 登录，在没有安装 QQ 时，需要<code>QRQQAuthenticator</code>作特殊处理。<br>由于这样的特殊处理只是 QQ 登录需要，因此把对应的接口放到<code>QRAuthenticatorDelegate</code>中是不合适的。<br>最终，我们将其定义为独立的接口<code>QRQQManuallyAuthenticationDelegate</code>：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">QRQQManuallyAuthenticationDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)manuallyAuthenticateWithAccount:(Account *)account;</span><br><span class="line">- (<span class="keyword">void</span>)checkVerifyCode:(<span class="built_in">NSString</span> *)verifyCode account:(Account *)account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>并让<code>QRQQAuthenticator</code>实现这两个接口：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QRQQAuthenticator</span> : <span class="title">NSObject</span>&lt;<span class="title">QRAuthenticatorDelegate</span>, <span class="title">QRQQManuallyAuthenticationDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>而<code>QRWechatAuthenticator</code>、<code>QRGuestAuthenticator</code>等只需实现<code>QRAuthenticatorDelegate</code>即可。</p><blockquote><p>对于 ISP 大家可能会有疑问：根据 SRP，类的职责应该是单一的，为何需要实现多个接口？<br>在现实中，确实存在从接口层面内聚性较低的类。如，例2中的<code>QRQQAuthenticator</code>类，正常的登录、续期需要处理，手动登录同样需要处理，在接口上就不具备高内聚的特征。<br>ISP 就是用于在此情况下指导如何拆分接口。</p></blockquote><h1 id="依赖倒置原则『DIP』"><a href="#依赖倒置原则『DIP』" class="headerlink" title="依赖倒置原则『DIP』"></a>依赖倒置原则『DIP』</h1><hr><p>在开发中，较大的模块一般会由几位同学协同开发，分工一般会按分层的方式进行。<br>此时，经常会听到负责低层模块的同学向负责高层模块的同学说：『我给你提供了这这几个方法，代码已提交，你看一下。』<br>从 DIP 的角度看，犯了两个错误！<br>其一，在制定双方接口上低层模块起了主导作用；其二，两者间缺少抽象。<br>DIP：</p><ul><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；</li><li>抽象不应该依赖于细节，细节应该依赖于抽象。</li></ul><p>依赖倒置原则其中的『倒置』强调的就是高层模块与低层模块间的关系：<strong>高层模块作为需求方提出需求(提出接口)，低层模块去实现高层模块提出的需求(接口)。</strong><br>为何？</p><ul><li>高层模块不应知道低层模块的细节；</li><li>若是由低层模块制定接口，很可能不由自主地将实现细节曝露在接口中，这是我们不希望看到的。</li></ul><h2 id="例1-分页加载"><a href="#例1-分页加载" class="headerlink" title="例1 分页加载"></a>例1 分页加载</h2><p>在<a href="https://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/">列表类应用场景模板化</a>一文中，我们提到『大多数 App 的大多数应用场景都是列表类的』，分页加载是列表类应用场景的标配。<br>那么在制定接口时，若由低层模块(Model)负责，很可能会将分页的细节曝露在接口中：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestMoreDataWithPageStamp:(<span class="built_in">NSInteger</span>)pageStamp completion:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *, <span class="keyword">id</span>))completion;</span><br></pre></td></tr></table></figure></p><p>很明显，<code>pageStamp</code>是 Model 与服务端交互的细节，是高层模块不关心，也不应关心的问题。<br>若是由高层模块(Controller)提出需求(接口），接口可能会是这样：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestMoreDataWithCompletion:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *, <span class="keyword">id</span>))completion;</span><br></pre></td></tr></table></figure></p><p>当然，这个例子较简单，稍有经验的开发人员也不会在接口中曝露pageStamp信息。<br>但，由低层模块制定接口会曝露细节的问题值得关注。</p><h2 id="例2-通过抽象解耦高、低层模块"><a href="#例2-通过抽象解耦高、低层模块" class="headerlink" title="例2 通过抽象解耦高、低层模块"></a>例2 通过抽象解耦高、低层模块</h2><p>同时，DIP 提出高层模块与低层模块不能直接有依赖关系，它们都应依赖于抽象(接口)。<br>如此可使得高层模块与低层模块解耦，促使高层模块具有更好的可复用性。<br><img src="/img/ListSceneClassDiagram.png" alt=""><br>上图是在<a href="https://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/">『列表类应用场景模板化』</a>一文中介绍的列表类模块的类图。<br>其中，Controller 与 Manager 、Controller 与 Module 间都是面向接口编程(依赖于抽象)。<br>在 QQ 阅读中，书籍分为 txt 和精排两种格式，它们都支持批量下载。在展示、用户交互上两者并无太大区别，但背后的业务逻辑却大不相同。<br>因此，批量下载的 Controller 可以复用，但 Manager 不可。<br>通过 DIP 可以很方便的隔离 Controller 与 Manager，使批量下载的 Controller 在两种格式间复用。</p><p>DIP 可以说是 SOLID 中实现成本最小的原则，但其带来的收益却十分可观，因此，DIP 应该是我们自始至终都应遵守的原则。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>综观 S、O、L、I、D 五大原则，本质上它们都是帮助我们降低软件系统的复杂度。只不过，各自关注的维度不同：</p><ul><li>SRP：要求软件实体(模块、类、方法)只有单一的职责，降低实体的复杂度，提高实体的内聚性；</li><li>OCP：要求软件实体对扩展开放、对修改封闭，使得软件系统在扩展功能时，减少对系统已有部分的影响；</li><li>LSP：对继承关系提出要求，子类须可替换基类，降低继承带来的复杂度以及减少误用继承的可能；</li><li>ISP：将复杂接口拆分开来，避免强迫高层模块依赖于其不需要的接口，减少不必要的耦合；</li><li>DIP：避免由低层模块制定接口时无意曝露低层细节，通过抽象解耦高层与低层模块。</li></ul><p>对于 SOLID 以及其他的各种设计原则、模式，无须天天挂在嘴边，而是在遇到问题时，能通过它们解决问题。</p><p>参考资料：<br><a href="https://book.douban.com/subject/1140457/" target="_blank" rel="noopener">《敏捷软件开发——原则、模式与实践》</a><br><a href="https://book.douban.com/subject/1436745/" target="_blank" rel="noopener">《Design Patterns: Elements of Reusable Object-Oriented Software》</a><br><a href="https://book.douban.com/subject/1229923/" target="_blank" rel="noopener">《重构——改善既有代码的设计》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细分析了面向对象设计五大原则 S(单一职责原则『SRP』)、O(开放-封闭原则 『OCP』)、L(Liskov 替换原则『LSP』)、I(接口隔离原则『ISP』)、D(依赖倒置原则『DIP』)，并假以实例辅之。&lt;br&gt;
    
    </summary>
    
    
      <category term="OOD" scheme="http://zxfcumtcs.github.io/tags/OOD/"/>
    
      <category term="设计模式" scheme="http://zxfcumtcs.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="敏捷开发" scheme="http://zxfcumtcs.github.io/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
      <category term="SOLID" scheme="http://zxfcumtcs.github.io/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>列表类应用场景模板化</title>
    <link href="http://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/"/>
    <id>http://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/</id>
    <published>2018-09-17T15:05:02.000Z</published>
    <updated>2018-12-15T10:16:34.640Z</updated>
    
    <content type="html"><![CDATA[<p>由于列表类应用场景具有固定的流程和模式，本文首先简要介绍了 QQ 阅读中列表类应用场景的架构，然后提出对这一场景进行模板化，以便提高开发效率、减少沟通理解成本。<br>同时，提出一套基于 『Chain of Responsibility』 的事件处理方案，也在一定程度上提高了开发效率，减少了琐碎代码量。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>2009年作为移动互联网开发元年至今已过去十年，移动客户端开发技术也已从拓荒时代进化到成熟稳定阶段。十年间，数以万计的 App 被创造出来。然而，细观市面上的 App 会发现大多数及至绝大多数 App 的大多数及至绝大多数应用场景都是列表类的。<br>所谓列表类应用场景主要有以下几个特征：</p><ul><li>以 UITableView 展示多条数据；</li><li>数据不变，仅用于展示，或只有很少的状态变化；</li><li>没有复杂的用户交互(如：UGC)。</li></ul><p>从上述特征可知，所有列表类应用场景都具有『相同的代码结构』，也就意味着我们经常在做一些重复性的工作。<br>同时，『相同的代码结构』也意味着可以将其模板化。通过模板化列表类应用场景至少有以下两点收益：</p><ul><li>提高工作效率，减少重复性劳动；</li><li>统一代码结构，减少项目组内理解沟通成本。</li></ul><h1 id="QQ-阅读列表类应用场景架构简述"><a href="#QQ-阅读列表类应用场景架构简述" class="headerlink" title="QQ 阅读列表类应用场景架构简述"></a>QQ 阅读列表类应用场景架构简述</h1><hr><p>列表类应用场景其流程无外乎：从网络或本地磁盘获取数据，再将数据以列表(tableview)的形式展示出来，其中最主要的交互就是点击进入次级页面。<br>每个项目团队可能都有一套用于列表类场景的架构，在 QQ 阅读不断迭代的过程中我们也演化出了一套相关的架构。本文会以这套架构为例讲述模板化的思路。</p><blockquote><p>使用什么样的架构不是重点，重点是将使用的架构模板化的思路。</p></blockquote><p><img src="/img/ListSceneClassDiagram.png" alt=""><br><img src="/img/ListSceneTimingDiagram.png" alt=""><br>上图分别是我们这套架构的关键类图和时序图。整体上是由经典 MVC 模式演化而来：</p><ul><li>Manager(Interface)：对应 MVC 中的 Model 『层』，主要负责数据的获取、管理等；</li><li>Controller：各个模块的协调枢纽；</li><li>Cell/View：对应 MVC 中的 View，仅仅负责 UI 布局逻辑；</li><li>ViewModel：处理 UI 展示相关的业务逻辑(详细信息请参看之前的文章<a href="https://zxfcumtcs.github.io/2017/03/04/CustomUIControls/">『自定义 UI 组件库』</a>)；</li><li>Module(Interface)： 将其称之为『业务模块』，一个页面由多个不同或相同类型的模块组成。如 QQ 阅读精选页的『今日必读』、『今日秒杀』等都是模块。</li></ul><p><img src="/img/RecommendedToday.jpeg" alt=""><br><img src="/img/TodaySecondKill.jpeg" alt=""><br>当然 Module 也可以是一个简单的样式：<br><img src="/img/SimpleStyle.jpeg" alt=""><br>在 TableView 中一个 Module 对应一个 section。Module 的职责主要有：网络数据的解析、 为 TableView datasource 提供数据(如：创建 cell 等)、处理用户事件——即负责『模块』的所有业务逻辑(与 React Component 类似)。</p><blockquote><p>Module 的存在主要是减轻 Controller 的负担。</p></blockquote><p>通常情况下，Manager(Model)存储的是纯粹的业务数据(从网络拉取的数据)，这样就需要在业务数据与 Module『模块』 间建立映射关系。为了省去这层映射，直接由 Module 解析、存储业务数据。<br>这种做法也存在弊端，由于将网络数据的解析、控制 UI 展示的逻辑(创建 cell 等)都放在了 Module 中。使得 Module 违反了『单一职责原则』。</p><blockquote><p>『单一职责原则』(SRP)作为面向对象设计的五大原则『SOLID』之一，很容易理解，也很难把握！『就好像生活中的各种”适量”，适量放点盐、适量加点水…』<br> Bob大叔在《敏捷软件开发》中，将类的单一职责原则描述为『应该仅有一个引起它变化的原因』。</p></blockquote><p>在 Module 中，网络数据解析、UI 展示就是两个可变的原因——『同样的 UI 用于展示不同的网络协议返回的数据、同一协议返回的数据展示为不用的 UI』。<br>在 QQ 阅读中，书籍列表页就属于『同样的 UI 展示不同协议返回的数据』：<br><img src="/img/BookList.jpeg" alt=""><br>针对这种情况，无非就是将其中一个变化因子抽取出来，可以将网络数据解析抽取为一个单独的类。<br>由于Module 中这两个变化因子变动的概率并不大，为了降低复杂度，在模板中并没有将这两者分离开。</p><blockquote><p>『敏捷开发』的原则之一就是尽量保持代码简单、并在必要时进行重构，防止代码变坏。</p></blockquote><h1 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h1><hr><p>通过上述介绍可知，Controller、Manager、API 的代码基本是固定的——可以模板化，另外 View-ViewModel 是可以高度复用的。所以模板化后新增一个列表类应用场景的主要工作集中在 Module 上。</p><blockquote><p>所谓模板化就是提供一套代码模板，在实例化时将模板中的『Template』关键字替换成业务名。</p></blockquote><p>我们这套模板中有：Manager、Module、View 以及 API 四个目录，ZSTemplateManager.m(.h)、ZSTemplateViewController.m(.h) 以及 ZSTemplateAPI.m(.h)六个文件，其中可以模板化的代码主要有：</p><ul><li>Controller：设置 tableview(含下拉、上拉、datasource、delegate)、设置导航栏、错误\空数据处理、向 manager 发送请求数据的调用、事件处理等；</li><li>Manager：管理 module、向 API 发送网络请求、缓存处理等；</li><li>API：发送网络请求。</li></ul><p>也就是模板化后上述功能可以通过转换脚本一键生成，不用重复地写这些代码。尤其是 Controller 基本可以直接使用。</p><blockquote><p>转换脚本、demo 已提交到 github 上<a href="https://github.com/zxfcumtcs/ZSTemplatedListScene" target="_blank" rel="noopener">『ZSTemplatedListScene』</a>。转换脚本的功能就是将模板中的『Template』关键字替换为业务名(包括代码和文件名中的)。如，demo 中的通信录业务：<img src="/img/transformsh.jpeg" alt="">注：demo 中的模板仅是个『demo』，其中的网络请求、缓存等功能可替换为项目中统一的模块。</p></blockquote><p>总之，通过转换脚本可以一键生成部分代码，提高了开发效率。同时，通过模板也规范了代码结构，减少了项目组沟通理解成本。</p><h1 id="基于-Chain-of-Responsibility-事件处理方案"><a href="#基于-Chain-of-Responsibility-事件处理方案" class="headerlink" title="基于 Chain of Responsibility 事件处理方案"></a>基于 Chain of Responsibility 事件处理方案</h1><hr><p>目前的事件处理有2个痛点，于是才有了基于 Chain of Responsibility 的事件处理方案。</p><ul><li><p>痛点1<br><img src="/img/ViewHierarchy.png" alt=""><br>大多数场景下 View 的层级结构如上图所示。我们知道，View 一般不处理用户事件，需要逐级传递给 Controller，因此需要沿着上图的层级结构逐级传递处理事件的 delegate。这种单调重复琐碎的代码有种令人不悦的感觉：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell.delegate <span class="built_in">=</span> controller;</span><br><span class="line">view.delegate <span class="built_in">=</span> cell;</span><br><span class="line">…</span><br></pre></td></tr></table></figure></li><li><p>痛点2<br>随着版本的迭代，不同类型的 cell/view 极有可能出现不同的事件处理接口，如下图所示：<br><img src="/img/celldelegate.jpeg" alt=""><br>这严重违反了面向对象设计的开闭原则(Open-Closed)——每增加一种 cell 类型此处都需要修改。</p></li></ul><p>尤其是第一点一直困扰着我。直到前不久在《Design Patterns》一书中看到在介绍『Chain of Responsibility』模式时的一句话：『Using existing links works well when the links support the chain you need. It saves you from defining links explicitly, and it saves space』。<br><code>UIResponder</code> 中的 <code>nextResponder</code>不正是这个『existing links』吗！<br>最上层 View 的事件通过<code>nextResponder</code>链就可以顺利传到 ViewController 中，从而也就省去了 delegate 的逐级传递了，痛点1、2随之化解。<br>为此，我们为 <code>UIResponder</code>添加了传递、处理事件的分类：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZSCEvent</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) __kindof <span class="built_in">UIResponder</span> *sender;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *indexPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *userInfo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIResponder</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIResponder</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.nextResponder respondEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>UIResponder</code>的实现只是简单地将事件传递给<code>nextResponder</code>。<br>由于 View 不包含业务数据，所以事件传递的过程中需要不断添加一些信息。</p><blockquote><p>因此，我们将<code>ZSCEvent#userInfo</code>定义为 mutable。正常情况下外露接口一般都是 immutable。</p></blockquote><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableViewCell</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.nextResponder respondEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>如，在<code>UITableViewCell</code>的<code>respondEvent:</code>中需要将<code>sender</code>设置为<code>self</code>，以便在<code>UIViewController</code>中可以通过<code>cell</code>找到对应的 module。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([event.sender isKindOfClass:<span class="built_in">UITableViewCell</span>.class], <span class="string">@"event sender must be UITableViewCell"</span>);</span><br><span class="line">    <span class="keyword">if</span> (![event.sender isKindOfClass:<span class="built_in">UITableViewCell</span>.class]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = [_tableView indexPathForCell:event.sender];</span><br><span class="line">    <span class="keyword">id</span>&lt;ZSModule&gt; module = [<span class="keyword">self</span>.manager moduleAtIndex:indexPath.section];</span><br><span class="line">    </span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    event.indexPath = indexPath;</span><br><span class="line">    [event.userInfo setObject:_tableView</span><br><span class="line">                       forKey:ZSCEventUserInfoKeys.tableView];</span><br><span class="line">    </span><br><span class="line">    [module handleEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 View 中的事件处理代码可以这样：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_clickedButton:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    ZSCEvent *event = [[ZSCEvent alloc] init];</span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    [event.userInfo setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"clickedButton"</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> respondEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果一个 cell 中有多个事件需要处理，就需要在<code>userInfo</code>中加以区分，如上面代第<code>5</code>行。</p></blockquote><p>总之，通过<code>UIResponder</code>的<code>nextResponder</code>响应链，不必再在 view 的层级间传递 delegate，减少了琐碎的代码，提高了开发效率。同时也统一规范了事件处理方案。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>提升开发效率、规范代码结构一直是我们追求的目标。文本通过对列表类应用场景模板化以及通过『Chain of  Responsibility』机制处理用户事件，在一定程度上提高了开发效率并规范了代码结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于列表类应用场景具有固定的流程和模式，本文首先简要介绍了 QQ 阅读中列表类应用场景的架构，然后提出对这一场景进行模板化，以便提高开发效率、减少沟通理解成本。&lt;br&gt;同时，提出一套基于 『Chain of Responsibility』 的事件处理方案，也在一定程度上提高了开发效率，减少了琐碎代码量。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>简述 ReactNative Bundle</title>
    <link href="http://zxfcumtcs.github.io/2018/05/11/RNBundle/"/>
    <id>http://zxfcumtcs.github.io/2018/05/11/RNBundle/</id>
    <published>2018-05-11T15:04:48.000Z</published>
    <updated>2018-12-08T08:41:32.860Z</updated>
    
    <content type="html"><![CDATA[<p>本文因项目实际问题而起，简要分析了 RN Bundle 的结构。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="引"><a href="#引" class="headerlink" title="引"></a>引</h1><hr><p>原本计划在完成『<a href="https://zxfcumtcs.github.io/2018/02/03/RNRendering/">ReactNative源码解析——渲染机制详解</a>』一文后，暂停 RN 相关的总结分享，谁料项目中通过RN分包同时加载两个业务 bundle 时出错了！索性对 RN Bundle 研究一番，遂总结出此文。</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>使用 ReactNative 开发的业务，无论是通过内置还是动态下发的方式发布，都需要将业务 JavaScript 代码打包成 bundle。<br>JavaScript 作为一门静态脚本语言，为何需要打包这个过程？<br>打包主要有以下几个用途：</p><ul><li>开发 RN 业务时，一般会使用 JSX 语法『糖』描述 UI 视图，然而标准的 JS 引擎显然不支持 JSX，所以需要将 JSX 语法转换成标准的 JS 语法；</li><li>开发 RN 业务时，通常使用的是 ES 6，目前 iOS、Android 上的 JS 引擎还不支持 ES 6，因此需要转换；</li><li>JS 业务代码会依赖多个不同的模块(JS 文件)，RN 在打包时将所有依赖的模块打包到一个 bundle 文件中，较好地解决了这种复杂的依赖关系；</li><li>JS 代码的混淆。</li></ul><blockquote><p>RN 打包过程中的转码主要依赖 <a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 实现。</p></blockquote><h1 id="ReactNative-Bundle"><a href="#ReactNative-Bundle" class="headerlink" title="ReactNative Bundle"></a>ReactNative Bundle</h1><hr><p>RN Bundle 从本质上讲是一个 JS 文件，其主要由三部分组成：polyfills、module 定义、require 调用。<br><img src="/img/RNBundle.png" alt=""></p><h2 id="Polyfills"><a href="#Polyfills" class="headerlink" title="Polyfills"></a>Polyfills</h2><p>polyfills 部分主要是在 JS context 中做一些准备工作，如：声明 ES 6 语法中新增接口、定义模块方法(如：模块声明方法<code>__d</code>、模块引用方法<code>require</code>等)、设置<code>global.__DEV__</code>变量等。<br><img src="/img/Polyfills.jpeg" alt=""><br>如上图，polyfills 都闭包方法，定义的同时被调用。<br>polyfill具体规则定义在node_modules/metro-bundler/src/defaults.js中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">exports.polyfills = [</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Object.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/console.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/error-guard.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Number.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/String.prototype.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Array.prototype.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Array.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Object.es7.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/babelHelpers.js'</span>)];</span><br></pre></td></tr></table></figure></p><blockquote><p>defaults.js中还有其他有意思的信息^_^</p></blockquote><h2 id="module-definitions"><a href="#module-definitions" class="headerlink" title="module definitions"></a>module definitions</h2><p>为了更直观的了解 RN Bundle 中模块的定义，我们先来看一个例子：<br><img src="/img/RNDemo.jpeg" alt=""><br>如上图一个非常简单的 RN Demo，在打包生成的 bundle 中变成如下的格式：<br><img src="/img/RNMoudleBundle.jpeg" alt=""><br>很明显，为了看懂上图所示的打包结果，必须先了解一下<code>__d</code>为何物，细心的同学，可能已经在 polyfills 小节中发现了<code>__d</code>的定义(第<code>12</code>行)，即<code>__d</code>就是<code>define</code>方法，其完整的源码定义在：<code>node_modules/metro-bundler/src/Resolver/polyfills/require.js</code>中(代码略有删减)：<br><figure class="highlight js"><figcaption><span>node_modules/metro-bundler/src/Resolver/polyfills/require.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">global.require = <span class="built_in">require</span>;</span><br><span class="line">global.__d = define;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> modules = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">factory, moduleId, dependencyMap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (moduleId <span class="keyword">in</span> modules) &#123;</span><br><span class="line">        <span class="comment">// that are already loaded</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    modules[moduleId] = &#123;</span><br><span class="line">        dependencyMap,</span><br><span class="line">        exports: <span class="literal">undefined</span>,</span><br><span class="line">        factory,</span><br><span class="line">        hasError: <span class="literal">false</span>,</span><br><span class="line">        isInitialized: <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到<code>define</code>方法前三个参数分别为：<code>factory</code> 方法、module ID以及dependencyMap。<br><strong>调用<code>define</code>方法定义模块，实质就是以 moduleID 为 key 向模块注册表(<code>modules</code>)中注册模块相关的信息(<code>exports</code>、模块<code>factory</code>方法、<code>isInitialized</code>等)。</strong><br>好了，下面我们再次回到 RN Bundle 中 module definition。</p><h3 id="module-ID"><a href="#module-ID" class="headerlink" title="module ID"></a>module ID</h3><p>在 RN 中，为了唯一标识每个模块，解决模块间的依赖问题，在打包生成 bundle 时，为每个 module 生成一个唯一的 moduleID，moudleID 为从0开始递增的数字。<br>另外，RN 在打包 bundle 时，按模块间依赖关系深度遍历(弦外之音就是，根组件的 moduleID 为0)。</p><h3 id="module-factory"><a href="#module-factory" class="headerlink" title="module factory"></a>module factory</h3><p>从上图可知，module factory 方法主要做了以下几件事：</p><ul><li><strong>所有 <code>import</code> 转换为<code>require</code>方法调用(<code>import</code>是 ES 6新增语法，需要转换)(第<code>58</code>、<code>60</code>行)；</strong></li><li><strong>创建组件类(第<code>62~83</code>行)，其中最关键的方法就是<code>render</code>；</strong></li><li><strong>导出(exports)组件类(第<code>85</code>行)；</strong></li><li><strong>注册根组件(第<code>87~89</code>行)，详细信息请参看<a href="https://zxfcumtcs.github.io/2018/02/03/RNRendering/">ReactNative源码解析——渲染机制详解</a>一文。</strong></li></ul><blockquote><p>通过 module factory 中的 <code>render</code>方法，再次看到 JSX 标签被转换成了<code>createElement</code>方法调用。</p></blockquote><h2 id="require-calls"><a href="#require-calls" class="headerlink" title="require calls"></a>require calls</h2><p>RN Bundle 最后部分是 require calls：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;<span class="built_in">require</span>(<span class="number">50</span>);  <span class="comment">// InitializeCore.js</span></span><br><span class="line">;<span class="built_in">require</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p><code>require</code>方法参数为 moduleID，RN Bundle 最后这两个<code>require</code>调用分别加载了<code>InitializeCore</code>以及<code>RNDemo</code>(根组件)模块。<br>下面我们来看看，<code>require</code>具体做了哪些事(与模块定义方法<code>define</code>定义在同一文件中)：<br><figure class="highlight js"><figcaption><span>node_modules/metro-bundler/src/Resolver/polyfills/require.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = modules[moduleId];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.isInitialized ?</span><br><span class="line">    <span class="built_in">module</span>.exports :</span><br><span class="line">    guardedLoadModule(moduleIdReallyIsNumber, <span class="built_in">module</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">guardedLoadModule</span>(<span class="params">moduleId, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadModuleImplementation(moduleId, <span class="built_in">module</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadModuleImplementation</span>(<span class="params">moduleId, module</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">module</span>.isInitialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> exports = <span class="built_in">module</span>.exports = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> _module = <span class="built_in">module</span>;</span><br><span class="line">    <span class="keyword">const</span> factory = _module.factory, dependencyMap = _module.dependencyMap;</span><br><span class="line">    <span class="keyword">const</span> moduleObject = &#123; exports &#125;;</span><br><span class="line">    factory(global, <span class="built_in">require</span>, moduleObject, exports, dependencyMap);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports = moduleObject.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上代码所示，<code>require</code>方法首先判断所要加载的模块是否已经存在并初始化完成。若是，则直接返回模块的<code>exports</code>，否则调用<code>guardedLoadModule</code>方法(最终调用的是<code>loadModuleImplementation</code>方法)。<br><code>loadModuleImplementation</code>方法获得模块的<code>factory</code>方法并调用，最终返回模块的<code>exports</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从上文的分析可知，加载一个 RN Bundle，主要完成三件事：</p><ul><li>准备 JS 执行环境(polyfills)；</li><li>定义所有需要的模块(module define)；</li><li>加载<code>InitializeCore</code>以及根组件模块(require)。</li></ul><p>通过上文分析，应该能清楚的区分模块定义与加载的关系：</p><ul><li>模块定义(define)：将模块相关的信息(其中最重要的就是<code>factory</code>方法)添加到模块注册表中，仅此而已；</li><li>模块加载(require)：在 JS context 中调用模块<code>factory</code>方法，创建模块类并在组件注册表中注册根组件。</li></ul><p>以盖房子作比喻：</p><ul><li>模块定义：将盖房子需要的材料运入场地；</li><li>模块加载：真正地将房子盖起来。</li></ul><p>ps：上文所示的 RN Bundle 都是开发环境下打出来的(打包命令中<code>--dev</code>为 true)，这样的 Bundle 是没有经过混淆的，其可读性较好。经过混淆的 Bundle，大概长这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;e.__DEV__=!<span class="number">1</span>,e.__BUNDLE_START_TIME__=e.nativePerformanceNow?e.nativePerformanceNow():<span class="built_in">Date</span>.now()&#125;(<span class="string">"undefined"</span>!=<span class="keyword">typeof</span> global?global:<span class="string">"undefined"</span>!=<span class="keyword">typeof</span> self?self:<span class="keyword">this</span>);</span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;<span class="string">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">r,e,t</span>)</span>&#123;e <span class="keyword">in</span> u||(u[e]=&#123;<span class="attr">dependencyMap</span>:t,<span class="attr">exports</span>:<span class="keyword">void</span> <span class="number">0</span>,<span class="attr">factory</span>:r,<span class="attr">hasError</span>:!<span class="number">1</span>,<span class="attr">isInitialized</span>:!<span class="number">1</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">r</span>)</span>&#123;<span class="keyword">var</span> e=r,t=u[e];<span class="keyword">return</span> t&amp;&amp;t.isInitialized?t.exports:i(e,t)&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">if</span>(!c&amp;&amp;r.ErrorUtils)&#123;c=!<span class="number">0</span>;<span class="keyword">var</span> i=<span class="keyword">void</span> <span class="number">0</span>;<span class="keyword">try</span>&#123;i=n(e,t)&#125;<span class="keyword">catch</span>(e)&#123;r.ErrorUtils.reportFatalError(e)&#125;<span class="keyword">return</span> c=!<span class="number">1</span>,i&#125;<span class="keyword">return</span> n(e,t)&#125;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">e,i</span>)</span>&#123;<span class="keyword">var</span> n=r.nativeRequire;<span class="keyword">if</span>(!i&amp;&amp;n&amp;&amp;(n(e),i=u[e]),!i)<span class="keyword">throw</span> o(e);<span class="keyword">if</span>(i.hasError)<span class="keyword">throw</span> a(e,i.error);i.isInitialized=!<span class="number">0</span>;<span class="keyword">var</span> c=i.exports=&#123;&#125;,d=i,s=d.factory,f=d.dependencyMap;<span class="keyword">try</span>&#123;<span class="keyword">var</span> l=&#123;<span class="attr">exports</span>:c&#125;;<span class="keyword">return</span> s(r,t,l,c,f),i.factory=<span class="keyword">void</span> <span class="number">0</span>,i.dependencyMap=<span class="keyword">void</span> <span class="number">0</span>,i.exports=l.exports&#125;<span class="keyword">catch</span>(r)&#123;<span class="keyword">throw</span> i.hasError=!<span class="number">0</span>,i.error=r,i.isInitialized=!<span class="number">1</span>,i.exports=<span class="keyword">void</span> <span class="number">0</span>,r&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">r</span>)</span>&#123;<span class="keyword">var</span> e=<span class="string">'Requiring unknown module "'</span>+r+<span class="string">'".'</span>;<span class="keyword">return</span> <span class="built_in">Error</span>(e)&#125;<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">r,e</span>)</span>&#123;<span class="keyword">var</span> t=r;<span class="keyword">return</span> <span class="built_in">Error</span>(<span class="string">'Requiring module "'</span>+t+<span class="string">'", which threw an exception: '</span>+e)&#125;r.require=t,r.__d=e;<span class="keyword">var</span> u=<span class="built_in">Object</span>.create(<span class="literal">null</span>),c=!<span class="number">1</span>&#125;(<span class="string">"undefined"</span>!=<span class="keyword">typeof</span> global?global:<span class="string">"undefined"</span>!=<span class="keyword">typeof</span> self?self:<span class="keyword">this</span>);</span><br><span class="line">__d(<span class="function"><span class="keyword">function</span>(<span class="params">e,t,r,l</span>)</span>&#123;<span class="built_in">Object</span>.defineProperty(l,<span class="string">"__esModule"</span>,&#123;<span class="attr">value</span>:!<span class="number">0</span>&#125;);<span class="keyword">var</span> n=t(<span class="number">12</span>),s=babelHelpers.interopRequireDefault(n),a=t(<span class="number">24</span>),o=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> babelHelpers.classCallCheck(<span class="keyword">this</span>,t),babelHelpers.possibleConstructorReturn(<span class="keyword">this</span>,(t.__proto__||<span class="built_in">Object</span>.getPrototypeOf(t)).apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>))&#125;<span class="keyword">return</span> babelHelpers.inherits(t,e),babelHelpers.createClass(t,[&#123;<span class="attr">key</span>:<span class="string">"render"</span>,<span class="attr">value</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> s.default.createElement(a.View,&#123;<span class="attr">style</span>:styles.container&#125;,s.default.createElement(a.Text,<span class="literal">null</span>,<span class="string">"This is a demo"</span>))&#125;&#125;]),t&#125;(s.default.Component);l.default=o,a.AppRegistry.registerComponent(<span class="string">"RNDemo"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> o&#125;)&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><hr><p>好了，本文既然是因问题而起，最后简要介绍一下遇到的问题：<br><img src="/img/RNDemoError.jpeg" alt=""><br>问题的描述很清楚是根组件没有注册，由于刚刚分析完 RN 的渲染机制，知道这个错误描述的出处(来自<code>AppRegistry</code>模块的<code>runApplication</code>方法)：<br><img src="/img/runApplicationError.jpeg" alt=""><br>问题也很明显是在组件注册表<code>runnables</code>中找不到要运行的根组件。<br>起初我们怀疑是因为两个业务 bundle 有冲突在加载时出错了。<br>但 debug 下来并没有出错提示。<br>最终请教相关人士，得知是两个业务 bundle ID 一样，导致第二个 bundle 没有被正确定义(<code>define</code>方法首先通过要定义的模块 ID 判断该 ID 是否已注册，若已注册直接返回)。</p><blockquote><p>两个业务 bundle ID 会一样与我们使用的拆包方案有关。</p></blockquote><p>问题清楚了，修改就简单了，在此不细述了。</p><blockquote><p>通过这个问题，也说明了对底层实现方案了解的必要性。了解的越深，在遇到问题时思考的视角就会越广。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文因项目实际问题而起，简要分析了 RN Bundle 的结构。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="框架" scheme="http://zxfcumtcs.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ReactNative" scheme="http://zxfcumtcs.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative源码解析——渲染机制详解</title>
    <link href="http://zxfcumtcs.github.io/2018/02/03/RNRendering/"/>
    <id>http://zxfcumtcs.github.io/2018/02/03/RNRendering/</id>
    <published>2018-02-03T03:09:19.000Z</published>
    <updated>2018-12-08T08:41:32.862Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过解读 ReactNative 源码，简要分析了 ReactNative 通过 JS 创建、控制 Native 界面的过程。同时，为了完整性，我们也简单介绍了 JSX、 React Element 以及 React Component 等基本概念。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>目前移动端开发模式主要有：Native、Web、Hybrid 三种。其中，由 Web、Hybrid 开发的页面与 Native 有本质的区别，其最终呈现给用户的是 html 页面。<br>React Native 作为近几年新兴的开发模式，由于具有跨平台、动态更新等特性，备受关注。</p><blockquote><p>Build native mobile apps using JavaScript and React</p></blockquote><p>React Native 官方给出的定义，高度概括了其特征：</p><ul><li>RN 开发的 App 是以 React 为框架，通过 JS 实现业务逻辑；</li><li>最终开发出来的页面是纯 Native 的(即呈现给用户的是货真价实的 Native 页面)。</li></ul><p>RN 如何通过 JS 构造 Natvie 页面，正是本文分析的主题。</p><h1 id="JSX-amp-React-Element-amp-React-Component"><a href="#JSX-amp-React-Element-amp-React-Component" class="headerlink" title="JSX &amp; React Element &amp; React Component"></a>JSX &amp; React Element &amp; React Component</h1><hr><p>在开始前，有必要先简要介绍一下 JSX 、React Element 以及 React Component，三者都是来自 React 框架。</p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>JSX 可以简单理解为 JavaScript + XML 的语法糖，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;</span><br><span class="line">          Welcome to React Native!</span><br><span class="line">        &lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于 JSX 仅是一种语法糖，将 JSX 打包生成 bundle 时，通过 Babel JSX 会被转换成标准的 JavaScript 语法。上述 JSX 代码转换后如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(</span><br><span class="line">      View,</span><br><span class="line">      &#123; <span class="attr">style</span>: styles.container &#125;,</span><br><span class="line">      React.createElement(</span><br><span class="line">        Text,</span><br><span class="line">        &#123; <span class="attr">style</span>: styles.welcome &#125;,</span><br><span class="line">        <span class="string">'Welcome to React Native!'</span></span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p> 通过 <a href="https://babeljs.io/repl/#?presets=react&amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA" target="_blank" rel="noopener">『online Babel compiler』</a>可在线实时演示 JSX to JavaScript 的转换。</p></blockquote><p><strong>通过上述转换前后对比可知，JSX 中每个标签都会转换成 <code>React.createElement</code> 调用。</strong></p><blockquote><p>JSX 并不是必须的，可直接调用<code>React.createElement</code>。当然，更加推荐使用 JSX，因其可以更好、更清晰地表达视图层次结构。另外，JSX 是在打包过程中被转换成标准 JavaScript，因此不会有性能问题。</p></blockquote><h2 id="React-Element"><a href="#React-Element" class="headerlink" title="React Element"></a>React Element</h2><blockquote><p>Elements are the smallest building blocks of React apps.</p></blockquote><p>Element(元素)，是 React 中最小的构建单元，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br></pre></td></tr></table></figure></p><h2 id="React-Component"><a href="#React-Component" class="headerlink" title="React Component"></a>React Component</h2><p>组件 (Component) 在 React 中是一个非常重要的概念，就像在 OOP 世界里一切皆对象，在 React 中一切皆 Component。</p><blockquote><p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. ——<a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">『React.Component』</a><br>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display. Instead of artificially separating technologies by putting markup and logic in separate files, React separates concerns with loosely coupled units called “components” that contain both.——<a href="https://reactjs.org/docs/introducing-jsx.html#why-jsx" target="_blank" rel="noopener">『Why JSX?』</a></p></blockquote><p>从 React 官方的这两个描述可以总结一下 React Component 的特征：</p><ul><li>独立的、可复用的 UI 单元；</li><li>除了 UI 渲染，根据<a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">『Separation of Concerns (SoC)』</a>设计原则，Component 还需要处理其他业务逻辑，如：用户事件、状态变化、数据展示预处理等。</li></ul><blockquote><p>与此相反，在 Native 开发中，为了提高可复用性，强调将 UI 渲染 (View) 与业务逻辑 (ViewModel) 分离，同时用户事件处理需要在 Controller 中完成。而 React Component 其实更强调的是<strong>独立</strong>与<strong>分离</strong>。</p></blockquote><p>我们在自定义 Component 时，一般继承自抽象基类<code>React.Component</code>，同时需要实现<code>render()</code>方法。通过<code>render()</code>方法可知，React Component 是由 React Element 构成的。</p><blockquote><p>关于 Component 定义、使用相关的细节问题，在此不再赘述，详情可参考<a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">React.Component</a>、<a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">Components and Props</a></p></blockquote><p>在 RN 中，根组件(root components)需要通过<code>AppRegistry#registerComponent</code>方法进行注册。所谓根组件，可以简单理解为 Native to RN 的入口，Native 在加载 RN bundle 之后可通过<code>AppRegistry#runApplication</code>方法运行指定的根组件，从而进入 RN 的世界。</p><h1 id="Native-UI-Components"><a href="#Native-UI-Components" class="headerlink" title="Native UI Components"></a>Native UI Components</h1><hr><p>我们知道，通过 RN 实现的功能最终呈现给用户的是纯 Native 页面，这些 Native 页面实质是通过预定义的 Native UI Component 组装而成的。<br>因此，更进一步，分析 RN 的渲染机制，就是分析<strong>如何通过 JS 组装、控制  Native UI Component 生成 Native 界面</strong>。<br>没错，继续之前，先简要说说 Native UI Components。</p><h2 id="iOS-MapView-example"><a href="#iOS-MapView-example" class="headerlink" title="iOS MapView example"></a>iOS MapView example</h2><p>了解新事物，最简单的方式莫过于从例子入手(来自RN 官方：<a href="https://facebook.github.io/react-native/docs/native-components-ios.html" target="_blank" rel="noopener">Native UI Components</a>)：<br>该例子封装一个 iOS MapView 组件给 RN 使用。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code 1</span></span><br><span class="line"><span class="comment">// RNTMapManager.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;MapKit/MapKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;React/RCTViewManager.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RNTMapManager</span> : <span class="title">RCTViewManager</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RNTMapManager</span></span></span><br><span class="line"></span><br><span class="line">RCT_EXPORT_MODULE()</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">MKMapView</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, <span class="built_in">BOOL</span>)</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code 2</span></span><br><span class="line"><span class="comment">// MapView.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; requireNativeComponent &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// requireNativeComponent automatically resolves 'RNTMap' to 'RNTMapManager'</span></span><br><span class="line"><span class="built_in">module</span>.exports = requireNativeComponent(<span class="string">'RNTMap'</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyApp.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MapView <span class="keyword">from</span> <span class="string">'./MapView.js'</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;MapView zoomEnabled=&#123;false&#125; style=&#123;&#123;flex: 1&#125;&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例所示：</p><ul><li><code>MapView</code>(Native UI Component) 需要通过<code>RNTMapManager</code>(<code>RCTViewManager</code>子类)进行管理；</li><li><code>RNTMapManager</code>作为曝露给 RN 的 Native Module，需要添加<code>RCT_EXPORT_MODULE</code>宏；</li><li><code>RNTMapManager</code>需要实现<code>- (UIView *)view</code>方法，用于导出其管理的<code>MapView</code>(UI Component)；</li><li><code>RNTMapManager</code>可以通过<code>RCT_EXPORT_VIEW_PROPERTY</code>宏导出其管理的<code>MapView</code>的属性。</li></ul><p>RN 侧，通过<code>requireNativeComponent</code>方法引入 Native UI Component，实际引入的是 Native UI Component Manager。上例中即是<code>RNTMapManager</code>(Code 2 第<code>7</code>行)。</p><blockquote><p>Native UI Component Manager 在命名上必须以<code>Manager</code>为后缀，在 RN 中引用时省略此后缀(如 Code 2 中第7行所示)。<br>为了描述方便，后文将 Native UI Component Manager 简称为<code>RCTComponentManager</code>，是<code>RCTViewManager</code>的子类。<br>Code 2中第16行使用的<code>zoomEnabled</code>即是 Code 1中第19行导出的属性。</p></blockquote><h2 id="RCTUIManager"><a href="#RCTUIManager" class="headerlink" title="RCTUIManager"></a>RCTUIManager</h2><p>在前一小节示例中，引入了<code>RCTViewManager</code>，此时有必要介绍一下<code>RCTUIManager</code>。<br><img src="/img/RCTUIManager.png" alt=""><br>可以看到，<code>RCTViewManager</code>、<code>RCTUIManager</code>都实现了<code>RCTBridgeModule</code>协议，即都是曝露给 JS 的 Native Module。在<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">『ReactNative源码解析——通信机制详解(1/2)』</a>一文中，详细介绍了 <code>RCTBridge</code> 是如何管理  Native Module 的，在此不再赘述。<br>在 JS to Native 的渲染流程中，<code>RCTUIManager</code>起到重要作用：包括 Native View 的创建、布局、移除等操作都是通过<code>RCTUIManager</code>完成的。<br><img src="/img/RCTUIManager_setBridge.jpg" alt=""><br>通过上述<code>RCTUIManager#setBridge:</code>方法可知：所有的<code>RCTComponentManager</code>都会以<code>RCTComponentData</code>格式储存在<code>RCTUIManager-&gt;_componentDataByName</code>中。</p><blockquote><p><code>RCTUIManager</code>通过<code>RCTComponentData</code>操作<code>RCTComponentManager</code>，包括创建 component、为 component 设置属性等，具体内容后文会详细介绍。</p></blockquote><h2 id="RCT-View"><a href="#RCT-View" class="headerlink" title="RCT***View"></a>RCT***View</h2><p>在阅读 RN 源码过程中，会发现几个名称相似的 『view』：<code>RCTRootView</code>、<code>RCTRootContentView</code>、<code>RCTView</code>、<code>RCTShadowView</code>以及<code>RCTRootShadowView</code>，它们间的关系如下类图所示：<br><img src="/img/RCT*View.png" alt=""></p><ul><li><code>RCTView</code>——在 RN 中一个较基础的类，主要处理了 view 的 clipe、border等基础功能，UI 组件根据需要可继承自它(如：<code>RCTScrollView</code>)，也可不继承(如：<code>RCTText</code>)；</li><li><p><code>RCTRootView</code>——RN 的入口，也是这几个『view』中唯一曝露给外界的接口。下述引用来自 RN 源码中对<code>RCTRootView</code>的注解。很明显，<code>RCTRootView</code>是『React-managed』view 的载体(root)；此外，在屏幕上可以同时有多个<code>RCTRootViews</code>。</p><blockquote><p>Native view used to host React-managed views within the app.<br>Can be used just like any ordinary UIView.<br>You can have multiple RCTRootViews on screen at once, all controlled by the same JavaScript application.</p></blockquote></li><li><p><code>RCTRootContentView</code>——从其名称即可知其特点『root+content view』，其是所有 RN UI 元素的载体，其本身作为 subview 添加到<code>RCTRootView</code>上；</p></li><li><p><code>RCTShadowView</code>——在 RN 中，每个 UI 组件(view)实例都对应一个<code>RCTShadowView</code>(或其派生类)实例(类似于 <code>UIView</code> 与 <code>CALayer</code> 的关系)，从上面类图可知，虽然其命名以<code>View</code>结尾，但实质并非 View(继承自<code>NSObject</code>)。其主要功能是通过 <a href="https://github.com/facebook/yoga" target="_blank" rel="noopener">facebook-Yoga</a>在子线程(<code>shadow thread</code>)进行布局相关的计算。</p><blockquote><p>在实践中，我们发现同一功能，RN 实现的帧率往往比 Native 实现的更好(也就是更流畅)，与 RN 通过<code>RCTShadowView</code>在子线程进行布局计算密不可分。</p></blockquote></li><li><p><code>RCTRootShadowView</code>——继承自<code>RCTShadowView</code>，与<code>RCTRootContentView</code>一一对应。</p></li></ul><h1 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h1><hr><h2 id="RCTRootView"><a href="#RCTRootView" class="headerlink" title="RCTRootView"></a>RCTRootView</h2><p><code>RCTRootView</code>是 RN 应用(或者说 RN 模块)的入口，分析就从<code>RCTRootView</code>开始。<br><img src="/img/RCTRootView_initializer.jpeg" alt=""><br>如上图所示，<code>RCTRootView</code>提供了两个 initializer 方法，分别接受 <code>RCTBridge</code>(Designated initializer)以及 JSBundleURL(Convenience initializer)。<br>在初始化过程中，<code>RCTBridge</code>(<code>RCTCxxBridge</code>)异步加 JS Bundle，加载完成后会以通知(RCTJavaScriptDidLoadNotification)的形式告知<code>RCTRootView</code>：<br><img src="/img/RCTRootView_bundleFinishedLoading.jpeg" alt=""><br>在<code>RCTRootView#bundleFinishedLoading:</code>方法中，创建了<code>RCTRootContentView</code>并作为 subview 添加到<code>RCTRootView</code>上，同时调用了<code>runApplication</code>方法：<br><img src="/img/RCTRootView_runApplication.jpeg" alt=""><br><code>RCTRootView#runApplication:</code> 方法以 <code>_moduleName</code>、<code>_contentView.reactTag</code> 以及 <code>_appProperties</code>为参数调用 JS 模块<code>AppRegistry</code>的<code>runApplication</code>方法。<br>对<code>AppRegistry</code>不陌生吧^_^，『前文讲过，RN root components 都需要通过<code>AppRegistry</code>模块的<code>registerComponent</code>方法进行注册』。</p><h2 id="AppRegistry"><a href="#AppRegistry" class="headerlink" title="AppRegistry"></a>AppRegistry</h2><p>我们先从 component 注册说起：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code 3</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">Props</span>&gt; </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;</span><br><span class="line">          Welcome to React Native!</span><br><span class="line">        &lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">AppRegistry.registerComponent(<span class="string">'RNDemo'</span>, () =&gt; App);</span><br></pre></td></tr></table></figure></p><p>上述 Code 3定义了一个组件<code>App</code>，并通过<code>AppRegistry.registerComponent</code>方法进行了注册，使其成为根组件 (即可以在 Native 中直接调用)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code 4 (代码有删减，下同)</span></span><br><span class="line">registerComponent(</span><br><span class="line">  appKey: string,</span><br><span class="line">  componentProvider: ComponentProvider,</span><br><span class="line">): string &#123;</span><br><span class="line">  runnables[appKey] = &#123;</span><br><span class="line">    componentProvider,</span><br><span class="line">    run: <span class="function">(<span class="params">appParameters</span>) =&gt;</span></span><br><span class="line">      renderApplication(</span><br><span class="line">        componentProviderInstrumentationHook(componentProvider),</span><br><span class="line">        appParameters.initialProps,</span><br><span class="line">        appParameters.rootTag,</span><br><span class="line">        wrapperComponentProvider &amp;&amp; wrapperComponentProvider(appParameters),</span><br><span class="line">      )</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> appKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 通过 Code 4可知，组件最终存放在了组件注册表<code>runnables</code>中，其中最关键的信息是以<code>run</code>为 key 存储的箭头方法(第<code>8~14</code>行)，即最终对<code>renderApplication</code>方法的调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code 5</span></span><br><span class="line">runApplication(appKey: string, <span class="attr">appParameters</span>: any): <span class="keyword">void</span> &#123;</span><br><span class="line">  runnables[appKey].run(appParameters);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>在<code>RCTRootView#runApplication:</code> 方法中调用的<code>AppRegistry#runApplication</code>方法更加简单了，直接从组件注册表中取出相应的方法执行(最终调用<code>renderApplication</code>方法)。</p><blockquote><p>定义根组件时调用<code>AppRegistry.registerComponent</code>方法的 key 与在<code>RCTRootView#runApplication:</code>中调用<code>AppRegistry#runApplication</code>时的 key 需要一致(在例子中都是<code>RNDemo</code>)。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code 6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderApplication</span>&lt;<span class="title">Props</span>: <span class="title">Object</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  RootComponent: ReactClass&lt;Props&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  initialProps: Props,</span></span></span><br><span class="line"><span class="function"><span class="params">  rootTag: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  WrapperComponent?: ?ReactClass&lt;*&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactNative.render(</span><br><span class="line">    &lt;AppContainer rootTag=&#123;rootTag&#125; WrapperComponent=&#123;WrapperComponent&#125;&gt;</span><br><span class="line">      &lt;RootComponent &#123;...initialProps&#125; rootTag=&#123;rootTag&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/AppContainer&gt;,</span></span><br><span class="line"><span class="regexp">    rootTag,</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>renderApplication</code>最终调用了<code>ReactNative.render</code>，注意其参数：并不是直接使用我们传入的<code>RootComponent</code>，而是在其外面包了一层——<code>AppContainer</code>。</p><blockquote><p><code>AppContainer</code>是一个 React Component，像 debug 工具 Inspector、YellowBox 以及我们最不愿看到的出错时的红色界面都是在该组件中加载的。</p></blockquote><p>还记得，前文讲过，JSX 语法中的标签在打包生成 bundle 时会被转换成对<code>React.createElement</code>方法的调用吗？<br><img src="/img/ReactNative_render_createElement.jpeg" alt=""><br>通过上图的 debug 堆栈再次证明了这一点，<code>ReactNative#render</code>方法的第<code>35</code>行，原本是通过 JSX 语法形式对<code>RootComponent</code>的引用，但如右侧堆栈所示，实际是对<code>React.createElement</code>方法的调用。</p><h2 id="createView"><a href="#createView" class="headerlink" title="createView"></a>createView</h2><p><img src="/img/runapplication.jpeg" alt=""><br>通过上图所示长长…的调用堆栈后，来到了<code>UIManager.createView</code>，其调用的就是 Native module：<code>RCTUIManager</code>的<code>createView:viewName:rootTag:props:</code>方法(Native view 当然要在 Native 环境下创建了^_^)：<br><img src="/img/RCTUIManager_createView.jpeg" alt=""></p><blockquote><p>对<code>RCTComponentData</code>不陌生吧，前文讲过在<code>RCTUIManager#setBridge:</code>方法可知：所有的<code>RCTComponentManager</code>都会以<code>RCTComponentData</code>格式储存在<code>RCTUIManager-&gt;_componentDataByName</code>中。</p></blockquote><p>如上代码所示，首先会创建与 view 对应的 shadowView(第<code>902</code>行)，并存入 shadowView 注册表<code>_shadowViewRegistry</code>中。</p><blockquote><p>shadowView 的主要功能是通过<a href="https://github.com/facebook/yoga" target="_blank" rel="noopener">facebook-Yoga</a>进行布局相关的计算，一般情况下直接使用<code>RCTShadowView</code>类即可，若有特殊需求可从<code>RCTShadowView</code>类派生子类。RN提供的众多 UI 组件中，从<code>RCTShadowView</code>类派生的有(感兴趣的可以去看看这些派生类具体实现了哪些功能)：<br><img src="/img/RCTShadowViewSubClass.jpeg" alt=""></p></blockquote><p>第<code>912~920</code>行，在主线程创建了目标 view，并添加到 view 注册表<code>_viewRegistry</code>中(注意此时并没有添加视图层级树中，即调用<code>addSubview:</code>)。</p><h2 id="View-Property"><a href="#View-Property" class="headerlink" title="View Property"></a>View Property</h2><p>通过<code>RCT_EXPORT_VIEW_PROPERTY</code>宏，可以将 Native UI Component 的属性曝露给 RN，如在<code>RCTViewManager</code>中曝露的<code>backgroundColor</code>属性：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCT_EXPORT_VIEW_PROPERTY(backgroundColor, <span class="built_in">UIColor</span>)</span><br></pre></td></tr></table></figure></p><p><code>RCT_EXPORT_VIEW_PROPERTY</code>宏接受两个参数分别是要曝露的属性名以及属性类型，将其展开如下(是不是有种熟悉的味道，Native module 曝露给 RN 的方法也是通过类似的手法实现的)：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)propConfig_backgroundColor  &#123; </span><br><span class="line"><span class="keyword">return</span> @[<span class="string">@"UIColor"</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>除了<code>RCT_EXPORT_VIEW_PROPERTY</code>，还有另外两个宏<code>RCT_REMAP_VIEW_PROPERTY</code>、<code>RCT_CUSTOM_VIEW_PROPERTY</code>，其核心思想是一样的，在此就不赘述了。</p></blockquote><p>之后在 JSX 的标签中就可以使用 view 曝露的属性：<br><img src="/img/AppComponent.jpeg" alt=""><br><img src="/img/UIManagerCreate.jpeg" alt=""><br><img src="/img/updatePayload.jpeg" alt=""><br><img src="/img/createView_props.jpeg" alt=""><br>如图所示，在 JSX 中给 view 设置的属性被转换为<code>UIManager.createView</code>的第四个参数，最终也就传到了 Native module：<code>RCTUIManager</code>的<code>createView:viewName:rootTag:props:</code>方法中。<br>在前一小节(createView)中展示了<code>RCTUIManager</code>的<code>createView:viewName:rootTag:props:</code>方法，其第<code>918</code>行调用了<code>RCTComponentData</code>的<code>setProps:forView:</code>方法，即为 view 的属性赋值。由于篇幅关系，具体赋值过程在此不细述，核心是通过<code>RCT_EXPORT_VIEW_PROPERTY</code>宏生成的<code>propConfig_*</code>方法获取属性的类型，再将 JS 传过来的值进行相应的类型转换后赋给目标 view。</p><blockquote><p>在<code>RCTUIManager#createView:viewName:rootTag:props:</code>的第<code>904</code>行，调用了<code>RCTComponentData#setProps:forShadowView:</code>方法，即为 shadowView 的属性赋值。我们知道，shadowView 的主要作用是布局计算，通过<code>RCT_EXPORT_SHADOW_PROPERTY</code>宏曝露相关属性：<br><img src="/img/RCT_EXPORT_SHADOW_PROPERTY.jpeg" alt=""><br>可以看到，其曝露的属性也都是与布局相关的。</p></blockquote><p>是时候出个序列图，回顾一下整体流程了：<br><img src="/img/RNRender.png" alt=""><br>前文已提到，<code>RCTUIManager#createView:viewName:rootTag:props:</code>只是创建了目标 view 并添加到<code>_viewRegistry</code>中(仅此而以)。<br>从上图可以看到，JS 中的<code>ReactNativeBaseComponent</code>模块在调用<code>RCTUIManager</code>的<code>createView:viewName:rootTag:props:</code>方法创建目标 view 之后，还会调用<code>RCTUIManager</code>的<code>setChildren:reactTags:</code>方法：<br><img src="/img/setChildren.jpeg" alt=""><br>如上图源码所示，<code>setChildren:reactTags:</code>分别针对<code>_shadowViewRegistry</code>以及<code>_viewRegistry</code>(在 UIBlock 中完成调用)调用了静态方法：<code>RCTSetChildren</code>。<br>其中，shadowview 最终会调用到<code>RCTShadowView#insertReactSubview:atIndex:</code>方法：<br><img src="/img/RCTShadowViewinsertReactSubview.jpeg" alt=""><br>在该方法中，做的最核心的事情莫过于在YGNode树中插入相应的子节点(第<code>421</code>行)。<br>对于 view，最终会调用到<code>UIView+Rect</code>的<code>insertReactSubview:atIndex:</code>方法：<br><img src="/img/UIViewinsertReactSubview.jpeg" alt=""><br>在该方法中，按照层级顺序(index)将subView 添加到AssociatedObject <code>reactSubviews</code>中，还是没有真正添加到视图层级树中！</p><h2 id="Pending-UI-Block"><a href="#Pending-UI-Block" class="headerlink" title="Pending UI Block"></a>Pending UI Block</h2><p>阅读<code>RCTUIManager</code>的源码会发现，所有 JS to Native 的 UI 操作都不会立即执行，而是先添加到<code>UIManager-&gt;_pendingUIBlocks</code>中，<br>那么，<code>_pendingUIBlocks</code>中的 block 什么时候会执行呢？<br>在<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">『ReactNative源码解析——通信机制详解(1/2)』</a>一文中，我们介绍过为了提高效率，在 RN 中使用了批处理的方式：<br><img src="/img/didUpdateReactSubviews.jpeg" alt=""><br>如上图，JS 在完成一批操作后，会通知 Native，此时会调用<code>RCTUIManager#flushUIBlocks</code>方法。<br>同时，可以看到<code>RCTUIManager#flushUIBlocks</code>最终会调用<code>UIView+Rect</code>的<code>didUpdateReactSubviews</code>方法，如其源码所示，在该方法中完成了 view 添加到视图层级树的操作：<br><img src="/img/UIViewdidUpdateReactSubviews.jpeg" alt=""><br>如<code>flushUIBlocks</code>方法源码所示，最终会在主线程执行 UI block：<br><img src="/img/flushUIBlocks.jpeg" alt=""><br>至此，RN 中整个渲染流程基本完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过解读 ReactNative 源码，简要分析了 ReactNative 通过 JS 创建、控制 Native 界面的过程。同时，为了完整性，我们也简单介绍了 JSX、 React Element 以及 React Component 等基本概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="框架" scheme="http://zxfcumtcs.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ReactNative" scheme="http://zxfcumtcs.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative源码解析——通信机制详解(补充条款)</title>
    <link href="http://zxfcumtcs.github.io/2017/11/22/RNCommunicationMechanism-AdditionalTerms/"/>
    <id>http://zxfcumtcs.github.io/2017/11/22/RNCommunicationMechanism-AdditionalTerms/</id>
    <published>2017-11-22T15:13:53.000Z</published>
    <updated>2018-12-08T08:41:32.860Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过分析 RN 源码，简要介绍了 JS to Native 的 callback 实现原理以及 RN 中的三个重要线程。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h1><hr><p>前两篇文章<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a>、<a href="https://zxfcumtcs.github.io/2017/10/12/ReactNativeCommunicationMechanism2/">ReactNative源码解析——通信机制详解(2/2)</a>分别介绍了 RN 通信机制中的 JS to Native、Native to JS 的执行流程。为了集中注意力抓住主要流程，当时没有分析调用过程中的 callback 问题，下面简要分析一下 JS to Native callback 的实现原理。</p><blockquote><p>文中所列代码均做了简化处理。</p></blockquote><p>首先，来看一个具体的例子：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RCT_EXPORT_METHOD(showShareActionSheetWithOptions:(<span class="built_in">NSDictionary</span> *)options</span><br><span class="line">                  failureCallback:(RCTResponseErrorBlock)failureCallback</span><br><span class="line">                  successCallback:(RCTResponseSenderBlock)successCallback)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIActivityViewController</span> *shareController =</span><br><span class="line">    [[<span class="built_in">UIActivityViewController</span> alloc] initWithActivityItems:items applicationActivities:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    shareController.completionWithItemsHandler = </span><br><span class="line">    ^(<span class="built_in">NSString</span> *activityType, </span><br><span class="line">       <span class="built_in">BOOL</span> completed, </span><br><span class="line">       __unused <span class="built_in">NSArray</span> *returnedItems, </span><br><span class="line">       <span class="built_in">NSError</span> *activityError) &#123;</span><br><span class="line">           <span class="keyword">if</span> (activityError) &#123;</span><br><span class="line">               failureCallback(activityError);</span><br><span class="line">           &#125; </span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               successCallback(@[@(completed), RCTNullIfNil(activityType)]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>showShareActionSheetWithOptions:failureCallback:successCallback:</code>是<code>RCTActionSheetManager</code>曝露给 JS 的方法之一，其包含两个 callback：<code>failureCallback</code>、<code>successCallback</code>。<br>其中，<code>RCTResponseErrorBlock</code>、<code>RCTResponseSenderBlock</code>的定义如下：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type of a block that is capable of sending a response to a bridged</span></span><br><span class="line"><span class="comment"> * operation. Use this for returning callback methods to JS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^RCTResponseSenderBlock)(<span class="built_in">NSArray</span> *response);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type of a block that is capable of sending an error response to a</span></span><br><span class="line"><span class="comment"> * bridged operation. Use this for returning error information to JS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^RCTResponseErrorBlock)(<span class="built_in">NSError</span> *error);</span><br></pre></td></tr></table></figure></p><p>JS 中的调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ActionSheetIOS.showShareActionSheetWithOptions(&#123;</span><br><span class="line">        url: uri,</span><br><span class="line">        excludedActivityTypes: [</span><br><span class="line">          <span class="string">'com.apple.UIKit.activity.PostToTwitter'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      (error) =&gt; alert(error),</span><br><span class="line">      (completed, method) =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> text;</span><br><span class="line">        <span class="keyword">if</span> (completed) &#123;</span><br><span class="line">          text = <span class="string">`Shared via <span class="subst">$&#123;method&#125;</span>`</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          text = <span class="string">'You didn\'t share'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;text&#125;);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></p><p>上述代码的第<code>7</code>行、<code>8~16</code>行，分别设置了两个 fail、success callback。</p><p><img src="/img/RCTModuleMethodinvokeWithBridge.jpg" alt=""><br>上图所示是 JS to Native 中最终在 Native 侧调用相应方法的调用栈，在<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a>中提到过，但限于篇幅没有展开讨论。</p><p>今天的分析就从<code>RCTModuleMethod#invokeWithBridge:module:arguments:</code>开始。</p><h2 id="RCTModuleMethod-invokeWithBridge"><a href="#RCTModuleMethod-invokeWithBridge" class="headerlink" title="RCTModuleMethod#invokeWithBridge:"></a>RCTModuleMethod#invokeWithBridge:</h2><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)invokeWithBridge:(RCTBridge *)bridge</span><br><span class="line">                module:(<span class="keyword">id</span>)module</span><br><span class="line">             arguments:(<span class="built_in">NSArray</span> *)arguments</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_argumentBlocks == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> processMethodSignature];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set arguments</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> json <span class="keyword">in</span> arguments) &#123;</span><br><span class="line">        RCTArgumentBlock block = _argumentBlocks[index];</span><br><span class="line">        <span class="keyword">if</span> (!block(bridge, index, RCTNilIfNull(json))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke method</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    [_invocation invokeWithTarget:module];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>invokeWithBridge:module:arguments:</code>内部(第<code>6</code>行)调用了<code>processMethodSignature</code>方法，从名称可知该方法是处理『方法签名』的(被处理的方法当然是被 JS 调用的 Native method 了)：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)processMethodSignature</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;RCTMethodArgument *&gt; *arguments;</span><br><span class="line">    _selector = RCTParseMethodSignature(_methodInfo-&gt;objcName, &amp;arguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create method invocation</span></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *methodSignature =  [_moduleClass instanceMethodSignatureForSelector:_selector];</span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:methodSignature];</span><br><span class="line">    invocation.selector = _selector;</span><br><span class="line">    _invocation = invocation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process arguments</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> numberOfArguments = methodSignature.numberOfArguments;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;RCTArgumentBlock&gt; *argumentBlocks =</span><br><span class="line">    [[<span class="built_in">NSMutableArray</span> alloc] initWithCapacity:numberOfArguments - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">2</span>; i &lt; numberOfArguments; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *objcType = [methodSignature getArgumentTypeAtIndex:i];</span><br><span class="line">        RCTMethodArgument *argument = arguments[i - <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *typeName = argument.type;</span><br><span class="line">        SEL selector = RCTConvertSelectorForType(typeName);</span><br><span class="line">        <span class="keyword">if</span> ([RCTConvert respondsToSelector:selector]) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (objcType[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">case</span> _C_CHR: &#123;</span><br><span class="line">                    <span class="keyword">char</span> (*convert)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>) = (<span class="keyword">typeof</span>(convert))objc_msgSend;</span><br><span class="line">                    [argumentBlocks addObject:^(__unused RCTBridge *bridge, <span class="built_in">NSUInteger</span> index, <span class="keyword">id</span> json) &#123;</span><br><span class="line">                        <span class="keyword">char</span> value = convert([RCTConvert <span class="keyword">class</span>], selector, json);</span><br><span class="line">                        [invocation setArgument:&amp;value atIndex:(index) + <span class="number">2</span>];</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">YES</span>;&#125;];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ([typeName isEqualToString:<span class="string">@"RCTResponseSenderBlock"</span>]) &#123;</span><br><span class="line">            [argumentBlocks addObject:^(__unused RCTBridge *bridge, <span class="built_in">NSUInteger</span> index, <span class="keyword">id</span> json) &#123;</span><br><span class="line">                <span class="keyword">void</span> (^block)(<span class="built_in">NSArray</span> *) = ^(<span class="built_in">NSArray</span> *args) &#123;</span><br><span class="line">                    [bridge enqueueCallback:json args:args];</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">id</span> value = json ? [block <span class="keyword">copy</span>] : (<span class="keyword">id</span>)^(__unused <span class="built_in">NSArray</span> *_)&#123;&#125;;</span><br><span class="line">                <span class="built_in">CFBridgingRetain</span>(value);</span><br><span class="line"></span><br><span class="line">                [invocation setArgument:&amp;value atIndex:(index) + <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    _argumentBlocks = argumentBlocks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>processMethodSignature</code>方法主要做的工作：</p><ul><li>从被调方法的名称(字符串)中解析出 selector 以及<code>RCTMethodArgument</code>格式的参数(第<code>4</code>行)；</li><li>根据第一步中解析出的 selector 生成methodSignature、invocation(第<code>7~10</code>行)；</li><li>为每个参数生成一个 block(<code>argumentBlock</code>)，并添加到<code>argumentBlocks</code>数组中：<br>  1. 若参数的类型在 JS 与 Native 间可以转换(如：基础类型、字符串、数组等)(第<code>23~34</code>行)，在<code>argumentBlock</code>中完成 JS 类型参数 to Native 类型参数的转换(第<code>28</code>行)，并将得到的结果设置到<code>invocation</code>上(第<code>29</code>行)；<br>  2. 若参数类型是 block(如：<code>RCTResponseSenderBlock</code>、<code>RCTResponseErrorBlock</code>等)(第<code>35~46</code>行)，则在<code>argumentBlock</code>中生成一个 bolck，用作调用方法时的实参(因为 block 类型无法从 JS 直接传给 Native)，在该 block 中调用了<code>bridge</code>的<code>enqueueCallback:args:</code>方法。</li></ul><p>再回到<code>RCTModuleMethod#invokeWithBridge:module:arguments:</code>方法，第<code>12~18</code>行，执行了<code>processMethodSignature</code>方法为每个参数生成的 block，最终的效果就是将 JS 侧传入的参数值转换成 Native 类型并设置到<code>invocation</code>上。</p><p>通过上述分析可知，对于 block 类型的参数(callback)最终会调用了<code>RCTCxxBridge#enqueueCallback:args:</code>方法。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSCExecutor::invokeCallback(<span class="keyword">const</span> <span class="keyword">double</span> callbackId, <span class="keyword">const</span> folly::dynamic&amp; arguments) &#123;</span><br><span class="line">    auto result = [&amp;] &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">return</span> m_invokeCallbackAndReturnFlushedQueueJS-&gt;callAsFunction(&#123;</span><br><span class="line">                Value::makeNumber(m_context, callbackId),</span><br><span class="line">                Value::fromDynamic(m_context, std::move(arguments))</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (...) &#123;&#125;</span><br><span class="line">    &#125;();</span><br><span class="line">    callNativeModules(std::move(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>沿调用链最终来到<code>JSCExecutor::invokeCallback</code>，第<code>4</code>行通过 hook，实际调用的是 JS 侧的<code>MessageQueue#invokeCallbackAndReturnFlushedQueue</code>方法。<br>下面我们来看看 JS 侧如何处理 callback。</p><h2 id="NativeModules-genMethod"><a href="#NativeModules-genMethod" class="headerlink" title="NativeModules#genMethod"></a>NativeModules#genMethod</h2><p>还记得<code>genMethod</code>方法吗？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genMethod</span>(<span class="params">moduleID: number, methodID: number, type: MethodType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="literal">null</span>;</span><br><span class="line">    fn = <span class="function"><span class="keyword">function</span>(<span class="params">...args: Array&lt;any&gt;</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> lastArg = args.length &gt; <span class="number">0</span> ? args[args.length - <span class="number">1</span>] : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> secondLastArg = args.length &gt; <span class="number">1</span> ? args[args.length - <span class="number">2</span>] : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> hasSuccessCallback = <span class="keyword">typeof</span> lastArg === <span class="string">'function'</span>;</span><br><span class="line">        <span class="keyword">const</span> hasErrorCallback = <span class="keyword">typeof</span> secondLastArg === <span class="string">'function'</span>;</span><br><span class="line">        <span class="keyword">const</span> onSuccess = hasSuccessCallback ? lastArg : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> onFail = hasErrorCallback ? secondLastArg : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> callbackCount = hasSuccessCallback + hasErrorCallback;</span><br><span class="line">        args = args.slice(<span class="number">0</span>, args.length - callbackCount);</span><br><span class="line">        BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess);</span><br><span class="line">    &#125;;</span><br><span class="line">    fn.type = type;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a>一文中介绍过，JS 在调用 Native 方法时，会在 JS 侧动态生成一个对应的 JS 方法。<br>在<code>genMethod</code>方法的第<code>4~9</code>行，处理了调用参数的最后2个，判断是否是 callback 类型(function 类型)。<br>从上述处理代码中可以得出：</p><ul><li>对于 callback 类型的参数，作了特殊处理，将其从参数列表中剥离出来；</li><li>一个方法最多只能有两个 callback 类型的参数；</li><li>callback 类型的参数只能位于参数列表的最后。</li></ul><p>下面再来看看<code>MessageQueue.enqueueNativeCall</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enqueueNativeCall(</span><br><span class="line">    moduleID: number,</span><br><span class="line">    methodID: number,</span><br><span class="line">    params: any[],</span><br><span class="line">    onFail: ?<span class="built_in">Function</span>,</span><br><span class="line">    onSucc: ?<span class="built_in">Function</span>,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (onFail || onSucc) &#123;</span><br><span class="line">        <span class="comment">// Encode callIDs into pairs of callback identifiers by shifting left and using the rightmost bit</span></span><br><span class="line">        <span class="comment">// to indicate fail (0) or success (1)</span></span><br><span class="line">        <span class="comment">// eslint-disable-next-line no-bitwise</span></span><br><span class="line">        onFail &amp;&amp; params.push(<span class="keyword">this</span>._callID &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// eslint-disable-next-line no-bitwise</span></span><br><span class="line">        onSucc &amp;&amp; params.push((<span class="keyword">this</span>._callID &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>._successCallbacks[<span class="keyword">this</span>._callID] = onSucc;</span><br><span class="line">        <span class="keyword">this</span>._failureCallbacks[<span class="keyword">this</span>._callID] = onFail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._callID++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到：</p><ul><li>对于 callback 类型的参数，在 JS 与 Native 间传递的是 callbackID(<code>_successCallbacks</code>、<code>_failureCallbacks</code>中的下标)；</li><li>JS 侧的 callback function 存储在<code>_successCallbacks</code>、<code>_failureCallbacks</code>中。</li></ul><p>我们再回到调用流程中的<code>MessageQueue#invokeCallbackAndReturnFlushedQueue</code>方法，在该方法中调用了<code>__invokeCallback</code>方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__invokeCallback(cbID: number, <span class="attr">args</span>: any[]) &#123;</span><br><span class="line">    <span class="comment">// The rightmost bit of cbID indicates fail (0) or success (1), the other bits are the callID shifted left.</span></span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-bitwise</span></span><br><span class="line">    <span class="keyword">const</span> callID = cbID &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-bitwise</span></span><br><span class="line">    <span class="keyword">const</span> isSuccess = cbID &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> callback = isSuccess</span><br><span class="line">      ? <span class="keyword">this</span>._successCallbacks[callID]</span><br><span class="line">      : <span class="keyword">this</span>._failureCallbacks[callID];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!callback) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._successCallbacks[callID] = <span class="keyword">this</span>._failureCallbacks[callID] = <span class="literal">null</span>;</span><br><span class="line">    callback(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>__invokeCallback</code>方法中，通过 cbID 在<code>_successCallbacks</code>、<code>_failureCallbacks</code>中找到相应的 callback function，并执行。至此，callback 的流程全部结束。</p><blockquote><p>RN 通过 callbackID 的最后一位是0还是1，确定callback 是 success 还是 fail。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>JS 与 Native 间传递的是 callbackID；</li><li>callback 参数只能位于方法参数列表的最后面并且最多只能有2个；</li><li>RN 通过 callbackID 二进制的最后一位是0还是1，确定是 success 还是 fail；</li><li>由于 JS callback function 无法直接传递给 Native，Native 侧会生成一个 block。</li></ul><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><hr><p>在 RN 中，有3类线程需要关注：</p><ul><li>JS Thread；</li><li>Native Module Thread；</li><li>UI Manager Thread(Shadow Thread)。</li></ul><h2 id="JS-Thread"><a href="#JS-Thread" class="headerlink" title="JS Thread"></a>JS Thread</h2><p>JS Thread 是 JS 执行以及 JS 与 Native 通信线程。<br>简单讲，Native 在此线程执行 JS 代码，JS 调用 Native 接口也发生在此线程上。<br>JS Thread 的初始化发生在<code>RCTCxxBridge#start</code>方法中：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_jsThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:[<span class="keyword">self</span> <span class="keyword">class</span>]</span><br><span class="line">                                                   selector:<span class="keyword">@selector</span>(runRunLoop)</span><br><span class="line">                                                     object:<span class="literal">nil</span>];</span><br><span class="line">_jsThread.name = RCTJSThreadName;</span><br><span class="line">_jsThread.qualityOfService = <span class="built_in">NSOperationQualityOfServiceUserInteractive</span>;</span><br><span class="line">[_jsThread start];</span><br></pre></td></tr></table></figure></p><p>在阅读 RN 源码时可能会发现<code>RCTMessageThread</code>类，它是对 JS Thread 的 C++封装。具体源码就不列了。<br>还会发现<code>RCTJSThread</code>变量：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> RCTJSThread;</span><br><span class="line">RCTJSThread = (<span class="keyword">id</span>)kCFNull;</span><br></pre></td></tr></table></figure></p><blockquote><p>NOTE: RCTJSThread is not a real libdispatch queue</p></blockquote><p><code>RCTJSThread</code>的作用只是用于标识，确保需要在 JSThread 上执行的操作能在该线程上执行：<br><img src="/img/RCTJSThread.png" alt=""> <img src="/img/dispatchJSThread.png" alt=""></p><h2 id="Native-module-Thread"><a href="#Native-module-Thread" class="headerlink" title="Native module Thread"></a>Native module Thread</h2><p>JS 在调用 Native 方法时，Native 方法在哪个线程上执行？<br>Native Module 可以实现<code>methodQueue</code>方法，指定执行队列：<code>- (dispatch_queue_t)methodQueue</code>。<br>那如果 Native Module 没有实现<code>methodQueue</code>方法，会如何？<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUpMethodQueue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> implementsMethodQueue = [_instance respondsToSelector:<span class="keyword">@selector</span>(methodQueue)];</span><br><span class="line">    <span class="keyword">if</span> (implementsMethodQueue &amp;&amp; _bridge.valid) &#123;</span><br><span class="line">        _methodQueue = _instance.methodQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_methodQueue &amp;&amp; _bridge.valid) &#123;</span><br><span class="line">        <span class="comment">// Create new queue (store queueName, as it isn't retained by dispatch_queue)</span></span><br><span class="line">        _queueName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"com.facebook.react.%@Queue"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">        _methodQueue = dispatch_queue_create(_queueName.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>RCTModuleData#setUpMethodQueue</code>方法中可以看到：若Native Module 没有实现<code>methodQueue</code>方法，则为该 Native Module 生成一个串行队列。<br>那么在实现 <code>Native module#methodQueue</code> 方法时需要注意什么？<br>来了解一下 RN 自带的 module 实现情况：</p><ul><li>main thread — 如 RCTActionSheetManager，在接口中有 UI 操作；</li><li>JSThread — 如 RCTTiming、RCTEventDispatcher，实时性要求较高的<br>(慎用，This can have serious implications for performance, so only use this if you’re sure it’s what you need)；</li><li>UI Manager thread — 如 RCTUIManager、RCTViewManager，UI 组件；</li><li>Custom thread — 如 RCTAsyncLocalStorage，耗时操作。</li></ul><h2 id="UI-Manager-Thread-Shadow-Thread"><a href="#UI-Manager-Thread-Shadow-Thread" class="headerlink" title="UI Manager Thread(Shadow Thread)"></a>UI Manager Thread(Shadow Thread)</h2><p>UI Manager Thread，UI 组件(UI module)接口执行线程。<br>UI 不应该在 main thread？<br>RN 为了提高效率(如: 帧率)，会先在UI Manager Thread做一些预处理操作(如计算 frame)，最终在渲染上屏时会切到 main thread。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> RCTGetUIManagerQueue(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> shadowQueue;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSOperation</span> instancesRespondToSelector:<span class="keyword">@selector</span>(qualityOfService)]) &#123;</span><br><span class="line">            dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INTERACTIVE, <span class="number">0</span>);</span><br><span class="line">            shadowQueue = dispatch_queue_create(RCTUIManagerQueueName, attr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            shadowQueue = dispatch_queue_create(RCTUIManagerQueueName, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">            dispatch_set_target_queue(shadowQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> shadowQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，UI Manager Thread 是一个高优先级的串行队列。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li>所有 JS 代码都会在独立线程 JSThread 上执行；</li><li>可通过 methodQueue 方法自定义 Native module 执行线程；</li><li>为了提高效率，所有 UI 组件都会在 UI Manager thread 上预处理，再在 main thread 上渲染上屏。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过分析 RN 源码，简要介绍了 JS to Native 的 callback 实现原理以及 RN 中的三个重要线程。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="框架" scheme="http://zxfcumtcs.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ReactNative" scheme="http://zxfcumtcs.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative源码解析——通信机制详解(2/2)</title>
    <link href="http://zxfcumtcs.github.io/2017/10/12/ReactNativeCommunicationMechanism2/"/>
    <id>http://zxfcumtcs.github.io/2017/10/12/ReactNativeCommunicationMechanism2/</id>
    <published>2017-10-12T15:04:38.000Z</published>
    <updated>2018-12-08T08:41:32.862Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过分析源码，逐步解析 ReactNative 中 Native to JS 的通信机制。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Native-to-JS"><a href="#Native-to-JS" class="headerlink" title="Native to JS"></a>Native to JS</h1><hr><p>在『<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a>』一文中通过 RN 源码逐步分析了 JS to Native 的通信机制，整个过程相当还是比较复杂。本文同样通过解析源码，逐步分析 Native to JS 的过程。<br>相比 JS to Native，Native to JS 简单不少。<br><img src="/img/RNClassDiagram.png" alt=""><br>这是我们在『<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a>』一文中给出的 RN 关键类类图。<br><img src="/img/NativeToJSTimingDiagram.png" alt=""><br>上图是 Native to JS 的时序图，<code>RCTBridge</code> 作为 RN 对外接口，Native 调用 JS 的方法自然也需要从此发出。上图中的方法调用链比较简单，不一一分析。<br>在『<a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a>』中，我们知道<code>NativeToJsBridge</code>是 Native to JS 的桥接，<code>NativeToJsBridge</code>做的最重要的一件事就是线程管理——使所有的 JS 调用都在指定的线程上执行。(RN中关于线程问题，后面会另开文章专门讨论。)<br><code>JSCExecutor</code>是 RN 中 JS 执行引擎，今天的分析就从此开始。<br>JS to Native 的流程进入<code>JSCExecutor::callFunction</code>。</p><h2 id="JSCExecutor-callFunction"><a href="#JSCExecutor-callFunction" class="headerlink" title="JSCExecutor::callFunction"></a>JSCExecutor::callFunction</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSCExecutor::callFunction(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; moduleId, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; methodId, <span class="keyword">const</span> folly::dynamic&amp; arguments) &#123;</span><br><span class="line">    <span class="keyword">auto</span> result = [&amp;] &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_callFunctionReturnResultAndFlushedQueueJS) &#123;</span><br><span class="line">            bindBridge();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_callFunctionReturnFlushedQueueJS-&gt;callAsFunction(&#123;</span><br><span class="line">            Value(m_context, String::createExpectingAscii(m_context, moduleId)),</span><br><span class="line">            Value(m_context, String::createExpectingAscii(m_context, methodId)),</span><br><span class="line">            Value::fromDynamic(m_context, <span class="built_in">std</span>::move(arguments))</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line">    callNativeModules(<span class="built_in">std</span>::move(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>callFunction</code>方法中，首先判断环境是否准备好(第<code>3</code>行)，若尚未准备好，则进入<code>bindBridge</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSCExecutor::bindBridge() <span class="keyword">throw</span>(JSException) &#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(m_bindFlag, [<span class="keyword">this</span>] &#123;</span><br><span class="line">        <span class="keyword">auto</span> global = Object::getGlobalObject(m_context);</span><br><span class="line">        <span class="keyword">auto</span> batchedBridgeValue = global.getProperty(<span class="string">"__fbBatchedBridge"</span>);</span><br><span class="line">        <span class="keyword">auto</span> batchedBridge = batchedBridgeValue.asObject();</span><br><span class="line">        m_callFunctionReturnFlushedQueueJS = batchedBridge.getProperty(<span class="string">"callFunctionReturnFlushedQueue"</span>).asObject();</span><br><span class="line">        m_callFunctionReturnResultAndFlushedQueueJS = batchedBridge.getProperty(<span class="string">"callFunctionReturnResultAndFlushedQueue"</span>).asObject();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>bindBridge</code>方法主要完成一些初始化准备工作：从 JS 则获取<code>batchedBridge</code> object 以及若干个方法(<code>m_callFunctionReturnFlushedQueueJS</code>等)。<br>在<code>BatchedBridge.js</code>中可以找到<code>__fbBatchedBridge</code>的定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BatchedBridge = <span class="keyword">new</span> MessageQueue();</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(global, <span class="string">'__fbBatchedBridge'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  value: BatchedBridge,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>可以看到，在 Native 里面拿到的<code>batchedBridge</code>是一个<code>MessageQueue</code>类型的 JS object。<br><code>m_callFunctionReturnFlushedQueueJS</code>则是 JS 类<code>MessageQueue</code>的<code>callFunctionReturnFlushedQueue</code>方法。<br>回到<code>JSCExecutor::callFunction</code>，在第<code>6</code>行执行了<code>callFunctionReturnFlushedQueue</code>方法。</p><h2 id="MessageQueue-callFunctionReturnFlushedQueue-JS"><a href="#MessageQueue-callFunctionReturnFlushedQueue-JS" class="headerlink" title="MessageQueue.callFunctionReturnFlushedQueue(JS)"></a>MessageQueue.callFunctionReturnFlushedQueue(JS)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">callFunctionReturnFlushedQueue(<span class="built_in">module</span>: string, <span class="attr">method</span>: string, <span class="attr">args</span>: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">this</span>.__guard(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.__callFunction(<span class="built_in">module</span>, method, args);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.flushedQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callFunctionReturnFlushedQueue</code>方法调用了内部的<code>__callFunction</code>方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__callFunction(<span class="built_in">module</span>: string, <span class="attr">method</span>: string, <span class="attr">args</span>: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">this</span>._lastFlush = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">this</span>._eventLoopStartTime = <span class="keyword">this</span>._lastFlush;</span><br><span class="line">    <span class="keyword">const</span> moduleMethods = <span class="keyword">this</span>._getCallableModule(<span class="built_in">module</span>);</span><br><span class="line">    <span class="keyword">const</span> result = moduleMethods[method].apply(moduleMethods, args);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><code>__callFunction</code>通过 <code>moduleName</code>在 JS Module 注册表中找到该 module，并调用相应的方法。</p><blockquote><p>PS: <code>JSCExecutor::callFunction</code>-&gt;<code>MessageQueue.callFunctionReturnFlushedQueue</code>这套接口不会将要调用的 JS 方法的返回值传给 Native 侧。<br>如需返回 JS 方法的返回值，可调用另外一套接口：<code>JSCExecutor::callFunctionSyncWithValue</code>-&gt;<code>MessageQueue.callFunctionReturnResultAndFlushedQueue</code>。<br>but，在<code>callFunctionSyncWithValue</code>方法的声明处有注释：<strong><em>『This method is experimental, and may be modified or removed』</em></strong></p></blockquote><h2 id="JS-Module-注册表"><a href="#JS-Module-注册表" class="headerlink" title="JS Module 注册表"></a>JS Module 注册表</h2><p>上一节，我们提到 JS Modulde 注册表(<code>_lazyCallableModules</code>)，所有曝露给 Native 的 JS Module都需要注册。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">registerCallableModule(name: string, <span class="attr">module</span>: <span class="built_in">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>._lazyCallableModules[name] = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">module</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">registerLazyCallableModule(name: string, <span class="attr">factory</span>: <span class="function"><span class="params">void</span> =&gt;</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span>: <span class="built_in">Object</span>;</span><br><span class="line">  <span class="keyword">let</span> getValue: ?(<span class="function"><span class="params">void</span> =&gt;</span> <span class="built_in">Object</span>) = factory;</span><br><span class="line">  <span class="keyword">this</span>._lazyCallableModules[name] = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getValue) &#123;</span><br><span class="line">      <span class="built_in">module</span> = getValue();</span><br><span class="line">      getValue = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_getCallableModule(name: string) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._lazyCallableModules[name]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>JS Module 注册表支持懒加载。</p></blockquote><p>可通过<code>registerCallableModule</code>或<code>registerLazyCallableModule</code>接口注册。<br>如在RCTEventEmitter.js中注册的消息模块<code>RCTEventEmitter</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BatchedBridge.registerCallableModule(<span class="string">'RCTEventEmitter'</span>, eventEmitter);</span><br></pre></td></tr></table></figure></p><p>在InitializeCore.js中注册的基础模块(懒加载)：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'Systrace'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'Systrace'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'JSTimers'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'JSTimers'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'HeapCapture'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'HeapCapture'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'SamplingProfiler'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'SamplingProfiler'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'RCTLog'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'RCTLog'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'RCTDeviceEventEmitter'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'RCTDeviceEventEmitter'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'RCTNativeAppEventEmitter'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'RCTNativeAppEventEmitter'</span>));</span><br><span class="line">BatchedBridge.registerLazyCallableModule(<span class="string">'PerformanceLogger'</span>, () =&gt; <span class="built_in">require</span>(<span class="string">'PerformanceLogger'</span>));</span><br></pre></td></tr></table></figure></p><p>至此，Native to JS 的流程基本结束。<br>but，事情并没有结束。<br>前面讲到，<code>callFunctionReturnFlushedQueue</code>不会返回所调 JS 方法的返回值，但它确有返回值(从 JS 传给 Native)：<br><figure class="highlight js"><figcaption><span>// callFunctionReturnFlushedQueue的 return 语句</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.flushedQueue();</span><br></pre></td></tr></table></figure></p><p>在分析 JS to Native 时介绍过，出于性能考虑所有从 JS to Native 的调用都会先入队，只有满足一定的条件(离上一次 flush queue 大于5ms)才会被执行。<br>所有 Native to JS的调用，在其结束时都会触发一次 flush queue 的操作，即 flush 所有入队的 JS to Native 的调用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Native to JS 的通信过程相对比较简单，总结主要有两点：</p><ul><li>所有曝露给 Native 的 JS Module 都需要提前注册；</li><li>在 Native to JS 调用结束时，会触发 flush JS to Native Queue 的操作。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>RN 中 Native 与 JS 的通信机制基本分析完成，总结主要有以下几点：</p><ul><li>RN 项目中涉及多种语言，但 Native 与 JS 的通信发生在<code>C++</code>与<code>JavaScript</code>间；</li><li>双方具体负责通信的分别是：Native 的<code>JSCExecutor</code>与 JS 的<code>MessageQueue</code>；</li><li>在 Native 侧维护了一份曝露给 JS 的 module 注册表，在 JS 侧维护了一份曝露给 Native 的 module 注册表；</li><li>RN 中 Native to JS 的通信没有使用<code>JavaScriptCore</code>提供的机制(<code>block</code>、<code>JSExport</code>)，而是自己实现了一套跨平台通信机制。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://facebook.github.io/react-native/docs/getting-started.html" target="_blank" rel="noopener">React Native Docs</a><br><a href="http://awhisper.github.io/2016/06/24/ReactNative%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">ReactNative iOS源码解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过分析源码，逐步解析 ReactNative 中 Native to JS 的通信机制。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="框架" scheme="http://zxfcumtcs.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ReactNative" scheme="http://zxfcumtcs.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative源码解析——通信机制详解(1/2)</title>
    <link href="http://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/"/>
    <id>http://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/</id>
    <published>2017-10-08T11:19:59.000Z</published>
    <updated>2018-12-08T08:41:32.862Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过分析源码，逐步解析 ReactNative 中 JS to Native 的通信机制。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>本文详细分析了 JS to Native 的调用过程，包括：ReactNative 的初始化、native module 注册、JS 获取 native module 信息、JS 调用 native module。</p><blockquote><p>本文分析的源码基于 ReactNative 0.47，为了叙述方便后文将 ReactNative 简称为 RN。<br>另外，为了精减篇幅聚焦重点，文中所列源码均做过简化，删除非关键代码。<br>由于本文具体分析的是 iOS 侧的实现，故后文所有内容都是针对 iOS 平台(其中有一大部分是共用的)。</p></blockquote><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><hr><blockquote><p>阅读源码大概有两类目的，一是想通过源码了解某个实现细节；二是想了解其实现的整体结构、原理。对于第一种情形可以直接深入源码，快速抓住关注点；而后者如果也一股脑扎入源码，很容易陷入各种实现细节而迷失方向(尤其是大型源码)。此时，应先了解代码整体结构，抓住关键路径，必要时辅以类图。</p></blockquote><p>本文讨论的 RN 通信机制是整个 RN 的核心，贯穿始末，涉及<code>Objective-C</code>/<code>Java</code>、<code>C++</code>、<code>JavaScript</code>间的交互。因此，在深入分析前有必要先了解一下 RN 整体结构以及关键类的类图。<br><img src="/img/RNLanguageComposition.jpeg" alt=""><br>RN 最大的优势在于<strong><em>跨平台、热更新</em></strong>。因此，RN 库本身也需要在多个平台(iOS、Android)上运行，从上图可知，在 RN 中 <code>C++</code>与<code>JS</code>部分的实现为多平台共用，在此基础上再分化为各平台实现。其中，iOS 平台特有的实现(<code>Objective-C</code>、<code>C++</code>)主要集中在 React 下，以<code>C++</code>语言实现的共有部分在 ReactCommon 下：<br><img src="/img/ReactReactCommon.png" alt=""><br>JS侧与本文关系紧密的内容主要集中在：<br><img src="/img/BatchedBridgePath.jpg" alt="">下的<code>BatchedBridge.js</code>、<code>MessageQueue.js</code>以及<code>NativeModules.js</code>中。</p><p>我们先大概了解几个关键类及其间的关系，对整体结构有个大致印象：<br><img src="/img/RNClassDiagram.png" alt=""><br>如上图：</p><ul><li><code>RCTBridge</code>与<code>RCTCxxBridge</code>属于 iOS 平台特有，前者是 RN 对业务层接口(图中其他类都属于内部类，业务层无感知)，具体工作在其子类<code>RCTCxxBridge</code>中完成；</li><li>整个 RN 的核心在跨平台的 C++层，其中很多类的功能从其名称即可略知一二，后文也会有详细的描述；</li><li>在 RN 中肯定少不了 JS 的支持，从上图可知，JS 与 Native 的通信发生在 <code>JavaScript</code> 与 <code>C++</code>间，这也是本文分析的重点。</li></ul><p>说到通信，无外乎 JS to Native、Native to JS，本篇我们重点分析JS to Native。</p><h1 id="JavaScript—-gt-Native"><a href="#JavaScript—-gt-Native" class="headerlink" title="JavaScript—&gt;Native"></a>JavaScript—&gt;Native</h1><hr><p>通过 Apple 推出的 <code>JavaScriptCore</code>，要实现 JS to Native 的通信并非难事，主要有两条途径：</p><ul><li><code>block</code>——在 RN 这样复杂的应用场景中<code>block</code>显得有些力不从心；</li><li><code>JSExport</code>协议——通过实现该协议可以向 JS 曝露 Native 接口(但不具备跨平台能力)。</li></ul><p>因此，RN 并没有使用 <code>JavaScriptCore</code>提供的这两种方式，而是自己实现了一套通信机制。<br>我们先从一个简单的例子入手：<code>CalendarManager</code>封装了 iOS 平台的日历控件，供 JS 调用。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CalendarManager.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;React/RCTBridgeModule.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CalendarManager</span> : <span class="title">NSObject</span> &lt;<span class="title">RCTBridgeModule</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CalendarManager.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CalendarManager</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To export a module named CalendarManager</span></span><br><span class="line">RCT_EXPORT_MODULE();</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(addEvent:(<span class="built_in">NSString</span> *)name location:(<span class="built_in">NSString</span> *)location) &#123;</span><br><span class="line">    RCTLogInfo(<span class="string">@"Pretending to create an event %@ at %@"</span>, name, location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们知道，要将 Native module(类、接口)曝露给 JS，module需要实现<code>RCTBridgeModule</code>协议，并且在实现中要插入<code>RCT_EXPORT_MODULE</code>宏。具体曝露的方法也需要通过<code>RCT_EXPORT_METHOD</code>宏定义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="keyword">import</span> &#123; NativeModules &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">var</span> CalendarManager = NativeModules.CalendarManager;</span><br><span class="line">CalendarManager.addEvent(<span class="string">'Birthday Party'</span>, <span class="string">'4 Privet Drive, Surrey'</span>);</span><br></pre></td></tr></table></figure></p><p>此时，在 JS 中就可以通过<code>NativeModules.CalendarManager.addEvent(...)</code>方式调用 Native 接口了。<br>下面将对这一过程逐一分析，先来了解上面提到的两个关键的宏：</p><h2 id="RCT-EXPORT-MODULE"><a href="#RCT-EXPORT-MODULE" class="headerlink" title="RCT_EXPORT_MODULE"></a>RCT_EXPORT_MODULE</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCT_EXPORT_MODULE(js_name) \</span></span><br><span class="line"><span class="function">RCT_EXTERN <span class="keyword">void</span> <span class="title">RCTRegisterModule</span><span class="params">(Class)</span></span>; \</span><br><span class="line">+ (NSString *)moduleName &#123; <span class="keyword">return</span> @#js_name; &#125; \</span><br><span class="line">+ (<span class="keyword">void</span>)load &#123; RCTRegisterModule(self); &#125;</span><br></pre></td></tr></table></figure><p>可以看到，添加<code>RCT_EXPORT_MODULE</code>宏，相当定义了<code>load</code>、<code>moduleName</code>方法。正是在<code>load</code>方法中调用了<code>RCTRegisterModule</code>方法注册 Module(会影响 App 启动速度^_^)。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RCTRegisterModule(Class moduleClass) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        RCTModuleClasses = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Register module</span></span><br><span class="line">    [RCTModuleClasses addObject:moduleClass];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>RCTRegisterModule</code>只是简单收集所有需要曝露给 JS 的类。</p></blockquote><h2 id="RCT-EXPORT-METHOD"><a href="#RCT-EXPORT-METHOD" class="headerlink" title="RCT_EXPORT_METHOD"></a>RCT_EXPORT_METHOD</h2><p>曝露给 JS 的接口需要通过<code>RCT_EXPORT_METHOD</code>宏来定义，上文中：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RCT_EXPORT_METHOD(addEvent:(<span class="built_in">NSString</span> *)name location:(<span class="built_in">NSString</span> *)location) &#123;</span><br><span class="line">    RCTLogInfo(<span class="string">@"Pretending to create an event %@ at %@"</span>, name, location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终展开后的样子(由于篇幅关系具体的展开过程不作描述)：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)__rct_export__531 &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@""</span>, <span class="string">@"addEvent:(NSString *)name location:(NSString *)location"</span>, @NO];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)addEvent:(<span class="built_in">NSString</span> *)name location:(<span class="built_in">NSString</span> *)location &#123;</span><br><span class="line">    RCTLogInfo(<span class="string">@"Pretending to create an event %@ at %@"</span>, name, location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到通过宏添加了一个新方法，其命名规则：<code>__rct_export__</code>+<code>__LINE__</code>+<code>__COUNTER__</code>。同时注意到，所有曝露给 JS 的方法返回值都是 <code>void</code>，要返回结果时，需通过 callback 方式实现。</p><blockquote><p>优雅、巧妙地使用宏充满技巧。</p></blockquote><p>上面介绍的<code>RCT_EXPORT_MODULE</code>以及<code>RCT_EXPORT_METHOD</code>宏属于编译阶段的处理，下面我们从执行角度一步一步进行分析。<br><img src="/img/RNTimingDiagram.png" alt=""><br>上图是RN 初始化过程的时序图，我们将沿着图中的步骤逐步分析。</p><h2 id="注册NativeModule"><a href="#注册NativeModule" class="headerlink" title="注册NativeModule"></a>注册NativeModule</h2><p><img src="/img/RCTCxxBrigdeInitModulesWithDispatchGroup.png" alt=""><br>通过上述坐标，最终定位到<code>RCTCxxBridge._initModulesWithDispatchGroup</code>：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_initModulesWithDispatchGroup:(dispatch_group_t)dispatchGroup</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;Class&gt; *moduleClassesByID = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;RCTModuleData *&gt; *moduleDataByID = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSString</span> *, RCTModuleData *&gt; *moduleDataByName = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up moduleData for automatically-exported modules</span></span><br><span class="line">    <span class="keyword">for</span> (Class moduleClass <span class="keyword">in</span> RCTGetModuleClasses()) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *moduleName = RCTBridgeModuleNameForClass(moduleClass);</span><br><span class="line">        moduleData = [[RCTModuleData alloc] initWithModuleClass:moduleClass bridge:<span class="keyword">self</span>];</span><br><span class="line">       </span><br><span class="line">        moduleDataByName[moduleName] = moduleData;</span><br><span class="line">        [moduleClassesByID addObject:moduleClass];</span><br><span class="line">        [moduleDataByID addObject:moduleData];       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store modules</span></span><br><span class="line">    _moduleDataByID = [moduleDataByID <span class="keyword">copy</span>];</span><br><span class="line">    _moduleDataByName = [moduleDataByName <span class="keyword">copy</span>];</span><br><span class="line">    _moduleClassesByID = [moduleClassesByID <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>上述代码第<code>8</code>行<code>RCTGetModuleClasses()</code>即是获取通过<code>RCTRegisterModule</code>注册的 module 类(即所有曝露给 JS 的类)；</li><li>通过<code>RCTRegisterModule</code>注册的 module 默认使用<code>init</code>方法进行初始化，若某个 module 的初始化需要参数，可通过<code>RCTBridgeDelegate</code>-&gt;<code>extraModulesForBridge</code>或<code>moduleProvider</code>提供已初始化的 module 实例。</li></ul><p>至此，所有需要曝露给 JS 的 module 都已注册完成，并以<code>RCTModuleData</code>格式存储在<code>RCTCxxBridge</code>中。</p><blockquote><p>大部分 module 都是懒加载，只有那些需要在主线程完成初始化以及有常量需要导出的 module才会在注册时实例化。</p></blockquote><h2 id="Instance"><a href="#Instance" class="headerlink" title="Instance"></a>Instance</h2><p><img src="/img/JSCExecutor.png" alt=""><br>坐标定位到<code>RCTCxxBridge._initializeBridge</code>方法中：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_initializeBridge:(std::shared_ptr&lt;JSExecutorFactory&gt;)executorFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_reactInstance) &#123;</span><br><span class="line">        _reactInstance-&gt;initializeBridge(</span><br><span class="line">          std::unique_ptr&lt;RCTInstanceCallback&gt;(new RCTInstanceCallback(<span class="keyword">self</span>)),</span><br><span class="line">          executorFactory,</span><br><span class="line">          _jsMessageThread,</span><br><span class="line">          [<span class="keyword">self</span> _buildModuleRegistry]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>_initializeBridge</code>方法做的最重要的事情就是初始化<code>Instance</code>实例<code>_reactInstance</code>，此过程将所有曝露给 JS 的 module 由<code>RCTModuleData</code>格式转化为<code>ModuleRegistry</code>格式传入<code>Instance</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ModuleRegistry&gt;)_buildModuleRegistry</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> registry = <span class="built_in">std</span>::make_shared&lt;ModuleRegistry&gt;(createNativeModules(_moduleDataByID, self, _reactInstance));</span><br><span class="line">    <span class="keyword">return</span> registry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时，有必要介绍与 NativeModule 有关的几个类：<br><img src="/img/NativeModuleClassDiagram.png" alt=""></p><ul><li><code>JSCNativeModules</code>——<code>C++</code>类，在<code>JSCExecutor</code>中使用；</li><li><code>ModuleRegistry</code>——<code>C++</code>类，是<code>NativeModule</code>的集合；</li><li><code>NativeModule</code>——<code>C++</code>抽象类，定义了与 NativeModule 有关的接口；</li><li><code>RCTNativeModule</code>——实现了<code>NativeModule</code>中定义的接口；</li><li><code>RCTModuleData</code>——<code>OC</code>类，是存储曝露的moudle 的数据结构；</li><li><code>RCTBridgeMethod</code>——<code>OC</code>类，是存储曝露给 JS 接口(方法)的数据结构。</li></ul><p><code>Instance</code>是一个中转类，没有做太多的事情，我们继续向前。</p><h2 id="NativeToJsBridge"><a href="#NativeToJsBridge" class="headerlink" title="NativeToJsBridge"></a>NativeToJsBridge</h2><p>此时，来到<code>Instance::initializeBridge</code>-&gt;<code>NativeToJsBridge::NativeToJsBridge</code>，很明显<code>NativeToJsBridge</code>是 Native to JS 的桥接。<br>所有从 Native 到 JS 的调用都是从<code>NativeToJsBridge</code>中的接口发出去的。<br>在其构造函数中会初始化两个成员变量：</p><ul><li><code>m_executor</code>—<code>JSExecutor</code>类型的指针，从上文可知<code>JSExecutor</code>是个 <code>C++</code>抽象类，<code>m_executor</code>实际指向<code>JSCExecutor</code>的实例，作为 JS 的引擎，无论是 Native to JS 还是 JS to Native 最终都需要该类来处理，后面我们会逐一分析；</li><li><code>m_delegate</code>—<code>JsToNativeBridge</code>类型的指针，顾名思义，JS to Native 的桥接，该成员变量仅用于初始化<code>JSCExecutor</code>实例。</li></ul><h2 id="JSCExecutor"><a href="#JSCExecutor" class="headerlink" title="JSCExecutor"></a>JSCExecutor</h2><p>坐标定位到<code>NativeToJsBridge::NativeToJsBridge</code>-&gt;<code>JSCExecutor::JSCExecutor</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JSCExecutor::JSCExecutor(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ExecutorDelegate&gt; delegate,</span><br><span class="line">                         <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MessageQueueThread&gt; messageQueueThread,</span><br><span class="line">                         <span class="keyword">const</span> folly::dynamic&amp; jscConfig) <span class="keyword">throw</span>(JSException) :</span><br><span class="line">                         m_delegate(delegate),</span><br><span class="line">                         m_messageQueueThread(messageQueueThread),</span><br><span class="line">                         m_nativeModules(delegate ? delegate-&gt;getModuleRegistry() : <span class="literal">nullptr</span>),</span><br><span class="line">                         m_jscConfig(jscConfig) &#123;</span><br><span class="line">    initOnJSVMThread();</span><br><span class="line">    installGlobalProxy(m_context, <span class="string">"nativeModuleProxy"</span>,</span><br><span class="line">                       exceptionWrapMethod&lt;&amp;JSCExecutor::getNativeModule&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>JSCExecutor</code>的构造函数做了一条非常重要的事情：<strong><em>在 JS Context 中设置了一个全局代理<code>nativeModuleProxy</code>，其最终指向<code>JSCExecutor</code>类的<code>getNativeModule</code>方法</em></strong>。<br>至于说<code>nativeModuleProxy</code>为什么非常重要，留个悬念，后文再解，我们先看看<code>installGlobalProxy</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">installGlobalProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    JSGlobalContextRef ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">    JSObjectGetPropertyCallback callback)</span> </span>&#123;</span><br><span class="line">  JSClassDefinition proxyClassDefintion = kJSClassDefinitionEmpty;</span><br><span class="line">  proxyClassDefintion.attributes |= kJSClassAttributeNoAutomaticPrototype;</span><br><span class="line">  proxyClassDefintion.getProperty = callback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> isCustomJSC = isCustomJSCPtr(ctx);</span><br><span class="line">  JSClassRef proxyClass = JSC_JSClassCreate(isCustomJSC, &amp;proxyClassDefintion);</span><br><span class="line">  JSObjectRef proxyObj = JSC_JSObjectMake(ctx, proxyClass, <span class="literal">nullptr</span>);</span><br><span class="line">  JSC_JSClassRelease(isCustomJSC, proxyClass);</span><br><span class="line"></span><br><span class="line">  Object::getGlobalObject(ctx).setProperty(name, Value(ctx, proxyObj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结合上面两段代码总结一下：</p><ul><li><code>nativeModuleProxy</code>在JS Context 中是一个具有<code>JSObjectGetPropertyCallback</code>属性的对象(object)；</li><li><code>JSObjectGetPropertyCallback</code>非常神奇，其特点是在 JS 中访问对象属性(object.propertyName)时会触发 callback；</li><li><code>nativeModuleProxy</code>对应的 callback 最终会调用<code>JSCExecutor::getNativeModule</code>。</li></ul><p>在<code>JSCExecutor</code>构造函数中还调用了<code>initOnJSVMThread</code>方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSCExecutor::initOnJSVMThread()  &#123;</span><br><span class="line">    installNativeHook&lt;&amp;JSCExecutor::nativeFlushQueueImmediate&gt;(<span class="string">"nativeFlushQueueImmediate"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>initOnJSVMThread</code>方法中有个值得关注的点：在 JS Context 中 hook 了<code>JSCExecutor::nativeFlushQueueImmediate</code>。<br>简单讲，hook 后，在 JS 中调用<code>global.nativeFlushQueueImmediate(...)</code>，实际调用 Native 的<code>JSCExecutor::nativeFlushQueueImmediate</code>方法。<br>另外，在构造函数中也将native module 注册信息转换为<code>JSCNativeModules</code>格式存储了下来。</p><h2 id="JsToNativeBridge"><a href="#JsToNativeBridge" class="headerlink" title="JsToNativeBridge"></a>JsToNativeBridge</h2><p>坐标定位到<code>NativeToJsBridge::NativeToJsBridge</code>-&gt;<code>JsToNativeBridge::JsToNativeBridge</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JsToNativeBridge(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ModuleRegistry&gt; registry,</span><br><span class="line">                 <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;InstanceCallback&gt; callback)</span><br><span class="line">  : m_registry(registry)</span><br><span class="line">  , m_callback(callback) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>沿着调用链一路下来，最终 module 注册信息传入<code>JsToNativeBridge</code>，随后 JS to Native 的调用将用到这份信息。<br>至此，RN 初始化过程中与本文讨论的通信机制相关的内容基本结束。总结下来大概有几点：</p><ul><li>收集了所有曝露给 JS 的 module(也可称之为生成了一份 native module 注册表)；</li><li>在 JS Context 中设置了<code>nativeModuleProxy</code>以及<code>nativeFlushQueueImmediate</code>；</li><li>初始化了相关的类，如：<code>NativeToJsBridge</code>、<code>JsToNativeBridge</code>以及<code>JSCExecutor</code>等。</li></ul><p>现在可以说是『万事具备，只欠东风』——由 JS 发起对 Native 的调用了。<br>下面我们沿着调用路径继续往下分析。</p><h2 id="JS-NativeModules"><a href="#JS-NativeModules" class="headerlink" title="JS NativeModules"></a>JS NativeModules</h2><blockquote><p>这小节我们在 JS 中^-^</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="keyword">import</span> &#123; NativeModules &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">var</span> CalendarManager = NativeModules.CalendarManager;</span><br><span class="line">CalendarManager.addEvent(<span class="string">'Birthday Party'</span>, <span class="string">'4 Privet Drive, Surrey'</span>);</span><br></pre></td></tr></table></figure><p>回到之前那个例子，其调用的是<code>CalendarManager</code>module 的<code>addEvent:location:</code>方法。<br>展开上面的调用，最终的形式是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NativeModules.CalendarManager.addEvent(<span class="string">'Birthday Party'</span>, <span class="string">'4 Privet Drive, Surrey'</span>)</span><br></pre></td></tr></table></figure></p><p><code>NativeModules</code>定义在node_modules-&gt;react-native-&gt;Libraries-&gt;BatchedBridge-&gt;NativeModules.js。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> NativeModules : &#123;[moduleName: string]: <span class="built_in">Object</span>&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (global.nativeModuleProxy) &#123;</span><br><span class="line">  NativeModules = global.nativeModuleProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>nativeModuleProxy</code>正是上文提到的，由 Native 注入 JS 的具有<code>JSObjectGetPropertyCallback</code>属性的 object。<br>因此，JS 中的<code>NativeModules.CalendarManager</code>(取属性值)等价于调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSCExecutor::getNativeModule(NativeModules, `CalendarManager`)</span><br></pre></td></tr></table></figure></p><p>格式化：<br>JS中<code>NativeModules.moduleName</code> 等价于 Native 的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSCExecutor::getNativeModule(NativeModules, `moduleName`)</span><br></pre></td></tr></table></figure></p><p>也这是为什么说<code>nativeModuleProxy</code>非常重要的原因，所有从 JS to Native 的调用都需要其作为中间代理。<br>此时，又要切入 Native 环境了。</p><h2 id="ModuleRegistry-getConfig"><a href="#ModuleRegistry-getConfig" class="headerlink" title="ModuleRegistry::getConfig"></a>ModuleRegistry::getConfig</h2><p>由于接下来马上要用到 nativemodule 的信息，在此先提前准备好。<br>定位到<code>ModuleRegistry::getConfig</code>，通过上文可知在<code>ModuleRegistry</code>中存储了 nativemodule 的信息，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">folly::Optional&lt;ModuleConfig&gt; ModuleRegistry::getConfig(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) &#123;</span><br><span class="line">    <span class="keyword">auto</span> it = modulesByName_.find(name);</span><br><span class="line">    NativeModule* <span class="keyword">module</span> = modules_[it-&gt;second].get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string name, object constants, array methodNames (methodId is index), [array promiseMethodIds], [array syncMethodIds]</span></span><br><span class="line">    folly::dynamic config = folly::dynamic::<span class="built_in">array</span>(name);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MethodDescriptor&gt; methods = <span class="keyword">module</span>-&gt;getMethods();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; descriptor : methods) &#123;</span><br><span class="line">        methodNames.push_back(<span class="built_in">std</span>::move(descriptor.name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!methodNames.empty()) &#123;</span><br><span class="line">        config.push_back(<span class="built_in">std</span>::move(methodNames));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ModuleConfig(&#123;it-&gt;second, config&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>getConfig</code>方法最终将 native module 信息组装成一个数组，其格式：<br>[modulename, module 导出的 constants, [methodNames], [promiseMethodIds], [syncMethodIds]]<br>下面是<code>RCTWebSocketModule</code>导出的信息：<br><img src="/img/NativeModuleConfig.jpg" alt=""></p><p>在这过程中<code>RCTModuleData.methods</code>起到关键作用：<br>ModuleRegistry::getConfig-&gt;RCTNativeModule::getMethods-&gt;RCTModuleData.methods<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RCTModuleData.m</span></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;RCTBridgeMethod&gt;&gt; *)methods</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_methods) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&lt;RCTBridgeMethod&gt;&gt; *moduleMethods = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount;</span><br><span class="line">        Class cls = _moduleClass;</span><br><span class="line">        <span class="keyword">while</span> (cls &amp;&amp; cls != [<span class="built_in">NSObject</span> <span class="keyword">class</span>] &amp;&amp; cls != [<span class="built_in">NSProxy</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">            Method *methods = class_copyMethodList(object_getClass(cls), &amp;methodCount);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">                Method method = methods[i];</span><br><span class="line">                SEL selector = method_getName(method);</span><br><span class="line">                <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(selector) hasPrefix:<span class="string">@"__rct_export__"</span>]) &#123;</span><br><span class="line">                    IMP imp = method_getImplementation(method);</span><br><span class="line">                    <span class="built_in">NSArray</span> *entries = ((<span class="built_in">NSArray</span> *(*)(<span class="keyword">id</span>, SEL))imp)(_moduleClass, selector);</span><br><span class="line">                    <span class="keyword">id</span>&lt;RCTBridgeMethod&gt; moduleMethod =</span><br><span class="line">                    [[RCTModuleMethod alloc] initWithMethodSignature:entries[<span class="number">1</span>]</span><br><span class="line">                                                JSMethodName:entries[<span class="number">0</span>]</span><br><span class="line">                                                      isSync:((<span class="built_in">NSNumber</span> *)entries[<span class="number">2</span>]).boolValue</span><br><span class="line">                                                 moduleClass:_moduleClass];</span><br><span class="line"></span><br><span class="line">                    [moduleMethods addObject:moduleMethod];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _methods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>__rct_export__</code>是不是很熟悉，<code>RCTModuleData.methods</code>会遍历所有以<code>__rct_export__</code>为前缀的方法并执行以导出曝露给 JS 的接口。</p><h2 id="JSCNativeModules-createModule"><a href="#JSCNativeModules-createModule" class="headerlink" title="JSCNativeModules::createModule"></a>JSCNativeModules::createModule</h2><p>书接前文，JS to Native<br>NativeModules.moduleName(JS)-&gt;JSCExecutor::getNativeModule-&gt;JSCNativeModules::getModule-&gt;JSCNativeModules::createModule<br>沿调用链来到<code>JSCNativeModules::createModule</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">folly::Optional&lt;Object&gt; JSCNativeModules::createModule(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, JSContextRef context) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!m_genNativeModuleJS) &#123;</span><br><span class="line">    <span class="keyword">auto</span> global = Object::getGlobalObject(context);</span><br><span class="line">    m_genNativeModuleJS = global.getProperty(<span class="string">"__fbGenNativeModule"</span>).asObject();</span><br><span class="line">    m_genNativeModuleJS-&gt;makeProtected();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> result = m_moduleRegistry-&gt;getConfig(name);</span><br><span class="line">  Value moduleInfo = m_genNativeModuleJS-&gt;callAsFunction(&#123;</span><br><span class="line">    Value::fromDynamic(context, result-&gt;config),</span><br><span class="line">    Value::makeNumber(context, result-&gt;index)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  folly::Optional&lt;Object&gt; <span class="keyword">module</span>(moduleInfo.asObject().getProperty(<span class="string">"module"</span>).asObject());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">module</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 在<code>createModule</code>方法中，通过<code>ModuleRegistry::getConfig</code>(第<code>8</code>行)拿到了要调用的 native module 的信息(包括导出的常量、曝露的接口等)。<br>同时获取了 JS Context 中名为<code>__fbGenNativeModule</code>的属性(第<code>4</code>行)，从名称可知其作用是生成 JS 端的 Native Module 信息。<br><code>__fbGenNativeModule</code>定义在<code>NativeModules.js</code>中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export this method as a global so we can call it from native</span></span><br><span class="line">global.__fbGenNativeModule = genModule;</span><br></pre></td></tr></table></figure></p><h2 id="NativeModules-genModule"><a href="#NativeModules-genModule" class="headerlink" title="NativeModules.genModule"></a>NativeModules.genModule</h2><p>NativeModules.moduleName(JS)-&gt;JSCExecutor::getNativeModule-&gt;JSCNativeModules::getModule-&gt;JSCNativeModules::createModule-&gt;NativeModules. genModule(JS)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genModule</span>(<span class="params">config: ?ModuleConfig, moduleID: number</span>): ?</span>&#123;name: string, <span class="built_in">module</span>?: <span class="built_in">Object</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">const</span> [moduleName, constants, methods, promiseMethods, syncMethods] = config;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = &#123;&#125;;</span><br><span class="line">    methods &amp;&amp; methods.forEach(<span class="function">(<span class="params">methodName, methodID</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> methodType = isPromise ? <span class="string">'promise'</span> : isSync ? <span class="string">'sync'</span> : <span class="string">'async'</span>;</span><br><span class="line">        <span class="built_in">module</span>[methodName] = genMethod(moduleID, methodID, methodType);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="built_in">module</span>, constants);</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: moduleName, <span class="built_in">module</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>genModule</code>会遍历传入的<code>methods</code>数组，分别调用<code>genMethod</code>生成 JS 侧的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genMethod</span>(<span class="params">moduleID: number, methodID: number, type: MethodType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="literal">null</span>;</span><br><span class="line">    fn = <span class="function"><span class="keyword">function</span>(<span class="params">...args: Array&lt;any&gt;</span>) </span>&#123;</span><br><span class="line">        args = args.slice(<span class="number">0</span>, args.length - callbackCount);</span><br><span class="line">        BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess);</span><br><span class="line">    &#125;;</span><br><span class="line">    fn.type = type;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>genMethod</code>生成的函数非常简单，只是将对 native 的调用信息入队。<br>至此，由<code>NativeModules.moduleName</code>发起的调用链终于结束，最终返回结果：以 <code>methodName</code> 为 key，<code>genMethod</code> 生成的 function 为 value 的 JS object。即<code>NativeModules.moduleName</code>等价于<code>{methodName: fn}</code>。</p><blockquote><p>JS 中的 moduleID、methodID 对应 native moudle注册表中的数组下标。</p></blockquote><p>当然，事情并没有结束，继续扩展<code>NativeModules.moduleName.methodName(args)</code>。<br>通过上述分析，可知：<br><code>NativeModules.moduleName.methodName(args)</code>等价于：<br><code>BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess)</code></p><h2 id="MessageQueue-enqueueNativeCall"><a href="#MessageQueue-enqueueNativeCall" class="headerlink" title="MessageQueue.enqueueNativeCall"></a>MessageQueue.enqueueNativeCall</h2><p><code>NativeModules.moduleName.methodName</code>-&gt;<code>BatchedBridge.enqueueNativeCall</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MessageQueue = <span class="built_in">require</span>(<span class="string">'MessageQueue'</span>);</span><br><span class="line"><span class="keyword">const</span> BatchedBridge = <span class="keyword">new</span> MessageQueue();</span><br></pre></td></tr></table></figure></p><p>可以看到<code>BatchedBridge</code>就是<code>MessageQueue</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  enqueueNativeCall(moduleID: number, <span class="attr">methodID</span>: number, <span class="attr">params</span>: <span class="built_in">Array</span>&lt;any&gt;, <span class="attr">onFail</span>: ?<span class="built_in">Function</span>, <span class="attr">onSucc</span>: ?<span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._queue[MODULE_IDS].push(moduleID);</span><br><span class="line">    <span class="keyword">this</span>._queue[METHOD_IDS].push(methodID);</span><br><span class="line">    <span class="keyword">this</span>._queue[PARAMS].push(params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">if</span> (global.nativeFlushQueueImmediate &amp;&amp;</span><br><span class="line">        (now - <span class="keyword">this</span>._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS ||</span><br><span class="line">         <span class="keyword">this</span>._inCall === <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> queue = <span class="keyword">this</span>._queue;</span><br><span class="line">        <span class="keyword">this</span>._queue = [[], [], [], <span class="keyword">this</span>._callID];</span><br><span class="line">        <span class="keyword">this</span>._lastFlush = now;</span><br><span class="line">        global.nativeFlushQueueImmediate(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>enqueueNativeCall</code>方法中将调用信息(moduleID、methodID、params等入队)，若离上一次 flush queue 的时间超过5ms(<code>MIN_TIME_BETWEEN_FLUSHES_MS</code>)则立即 flush queue(出于性能考虑)。<br>对<code>nativeFlushQueueImmediate</code>是否还有影像？(在<code>JSCExecutor</code>构造函数中讲过了^_^)<br><code>global.nativeFlushQueueImmediate(queue)</code>等价于<code>JSCExecutor::nativeFlushQueueImmediate(queue)</code></p><h2 id="JsToNativeBridge-callNativeModules"><a href="#JsToNativeBridge-callNativeModules" class="headerlink" title="JsToNativeBridge::callNativeModules"></a>JsToNativeBridge::callNativeModules</h2><p><code>JSCExecutor::nativeFlushQueueImmediate</code>-&gt;<code>JSCExecutor::flushQueueImmediate</code>-&gt;<code>JsToNativeBridge::callNativeModules</code><br>沿着调用链，定位到<code>JsToNativeBridge::callNativeModules</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callNativeModules</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    JSExecutor&amp; executor, folly::dynamic&amp;&amp; calls, <span class="keyword">bool</span> isEndOfBatch)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; call : parseMethodCalls(<span class="built_in">std</span>::move(calls))) &#123;</span><br><span class="line">        m_registry-&gt;callNativeMethod(call.moduleId, call.methodId, <span class="built_in">std</span>::move(call.arguments), call.callId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`callNativeModules`会逐个解析从 JS 传过来的 call <span class="built_in">queue</span> 中的每个调用。</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">void</span> ModuleRegistry::callNativeMethod(<span class="keyword">unsigned</span> <span class="keyword">int</span> moduleId, <span class="keyword">unsigned</span> <span class="keyword">int</span> methodId, folly::dynamic&amp;&amp; params, <span class="keyword">int</span> callId) &#123;</span><br><span class="line">    modules_[moduleId]-&gt;invoke(methodId, <span class="built_in">std</span>::move(params), callId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>沿着调用链后面还有一些细节问题，由于篇幅关系，不再展开，主要如下：<br><img src="/img/RCTNativeModuleinvoke.jpg" alt=""><br><img src="/img/RCTModuleMethodinvokeWithBridge.jpg" alt=""><br>最终在<code>RCTModuleMethod.invokeWithBridge</code>中执行了调用<code>[_invocation invokeWithTarget:module];</code><br>至此，从 JS to Native 的调用结束！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JS to Native 的调用时序图：<br><img src="/img/JSToNativeCallTimingDiagram.png" alt=""><br>整个过程大概分为两个阶段：</p><ul><li>NativeModules.moduleName — 该过程主要是获取 native module 的信息(moduleID、methodID)，最终封装为 JS object ({methodName: fn})；</li><li>NativeModules.moduleName.methodName(params) — 执行调用。</li></ul><p>今天就到这了，下篇我们将分析 Native to JS。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过分析源码，逐步解析 ReactNative 中 JS to Native 的通信机制。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="框架" scheme="http://zxfcumtcs.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ReactNative" scheme="http://zxfcumtcs.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>Multithreading Traps</title>
    <link href="http://zxfcumtcs.github.io/2017/05/07/Multithreading-Traps/"/>
    <id>http://zxfcumtcs.github.io/2017/05/07/Multithreading-Traps/</id>
    <published>2017-05-07T10:02:11.000Z</published>
    <updated>2018-12-08T08:41:32.858Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先介绍了多线程的一些基本概念，如：atomicity、Out-of-order execution、Memory barrier等。然后结合 iOS 实际开发，分析了Property、dealloc、target-action、block、mutable containers等在多线程下的问题。最后，分享了几个小技巧。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>多线程使 CPU 的计算能力得到更加充分的利用，尤其在多核时代，程序因此变得更加流畅、高效。在 iOS 开发中，通过 GCD 更是能够零成本实现多线程，动不动就将某些耗时操作通过 GCD 分发到子线程执行，正是由于其廉价性，使得我们通常会忽略其引起的多线程问题。</p><p>多线程其实是把双刃剑，在带来流畅、高效的同时，也带来了很多问题，大大增加了程序复杂性。在开发中不难发现，很多bug、crash 都是多线程引发的。<br>多线程及其相关的问题，大致有以下特点：</p><ul><li>难重现(能重现的问题都不是问题)，多线程问题一般与特定的执行时序有关，重现难度大，一般在测试阶段很难发现，而发布之后通过大量用户才会曝露出来；</li><li>难理解，很多多线程问题除了看上去很奇怪、百思不得其解，找不到其他毛病，没有足够的经验很难发现是多线程引起的；</li><li>难意识，当我们在很嗨地写着多线程代码时，很难察觉正在挖坑！</li></ul><p>本文重点不是介绍多线程编程，而是多线程可能引发的问题，在继续之前有必要介绍几个重要概念：原子性(atomicity)、Out-of-order execution 以及 compiler reordering。</p><h1 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h1><hr><p>说到多线程，不得不提原子性(atomicity)，我们知道原子(atom)是化学中的概念，表示不可再分的基本粒子。在计算机领域，原子操作(原子性)是指在一次执行中不能被中断的操作。由于中断只发现在指令之间，因此在单处理器(UniProcessor)系统中，能通过一条指令完成的操作都具有原子性，然而在对称多处理器(Symmetrical Multi-Processing, SMP)系统中，由于同时存在多个处理器独立运行，单条指令操作也可能会受到干扰。因此，原子性通过软件是无法实现的，需要硬件层面的支持(架构相关的)。简单讲，CPU 通过缓存锁、总线锁在硬件层面可以实现原子性。</p><p>在目前大多数的 CPU 构架(如：x86、PowerPC、ARM)上，读写对齐的一个字长数据，能保证是原子的。如，在64位的系统中，读写对齐的 <code>int</code> 型数据的操作是原子操作。</p><p>原子性在多线程中是一个非常重要的概念，是实现线程同步(锁)的前提。</p><h1 id="Data-Races"><a href="#Data-Races" class="headerlink" title="Data Races"></a>Data Races</h1><hr><p>我们平时所说的多线程问题，其实绝大多数时候就是在讲 Data Races，出现 Data Races 有两个条件：</p><ul><li>在没有同步的情况下，多线程访问同一块内存；</li><li>至少有一个是写操作。</li></ul><p>其带来的后果可能是 crash、非预期的运行结果，当然也有可能是『无害』的。<br>如上文所说，在目前大多数 CPU 上，读写对齐的字长数据是原子操作，即有多个线程同时操作这一内存时不需要任何同步，也有人将其称之为『Benign Race』。但苹果工程师并不认同这种说法，主要有两点理由<a href="http://devstreaming.apple.com/videos/wwdc/2016/412jzguxz4h8hykgjlm/412/412_thread_sanitizer_and_static_analysis.pdf" target="_blank" rel="noopener">WWDC2016_412</a>：</p><ul><li>在 C 语言标准中，Benign Race 属于 undefined behavior；</li><li>在新的编译器或处理器上可能会引起问题(毕竟这不是一个公认标准)。</li></ul><p>因此，对于任何可能会出现 data races 的地方都要做好同步。</p><h1 id="Out-of-order-execution、compiler-reordering"><a href="#Out-of-order-execution、compiler-reordering" class="headerlink" title="Out-of-order execution、compiler reordering"></a>Out-of-order execution、compiler reordering</h1><hr><p>Out-of-order execution、compiler reordering，其实两者从代码执行的角度看，本质上是一样的，都是改变了代码原有的执行顺序。<br>只不过两者的“幕后黑手”以及发生时期不同：</p><ul><li>Out-of-order execution——由硬件(CPU)实现，也即在指令执行时(运行期)CPU改变了指令原有的顺序；</li><li>compiler reordering——由编译器实现，在编译过程中(编译期)改变了代码顺序。</li></ul><p>为什么会这样？此时大家可能更关心的是这个问题。很简单，两个字：『优化』，使得处理器能够更加高效的运行，具体细节已超出本文范围，不深入讨论。<br>那么问题又来了，这么“任性”地改变代码顺序不会出问题吗？<br>当然，它们(CPU、Compiler)是在『深入』分析的基础上，认为『安全』的前提下，才做的优化。</p><p>比如有这样一段代码：<img src="/img/thread1.jpg" alt=""></p><p>出于优化的目的，<code>setData</code>方法最终执行顺序可能就变成了：<img src="/img/thread1_outofreorder.jpg" alt=""></p><p>即改变了两条赋值语句的执行顺序。由于两者之间没有依赖关系(正是CPU、Compiler优化的前提)，因此这种优先是无害的。<br>但是，这是有前提的：单线程程序。</p><p>如果此时还存在Thread 2：<img src="/img/thread2.jpg" alt=""></p><p>如果两个线程执行顺序如下，那么上面的优化就存在问题了：<br><img src="/img/Out-of-order.jpeg" alt=""><br>最终输出的结果显然不是期望值。</p><p>之所以会出问题，在于 CPU、Compiler 没有能力处理多线程问题，它们一直停留在单线程模式中。因此，这个锅只有程序猿来接了！</p><h1 id="Memory-barrier"><a href="#Memory-barrier" class="headerlink" title="Memory barrier"></a>Memory barrier</h1><hr><p>Memory barrier 正是解决由 Out-of-order execution、compiler reordering 引起问题的方案。<br>Memory barrier 从字面(内存栅栏)即可理解其用途：强制要求处于 barrier 前的读、写操作的执行先于其后的读、写操作。<br><img src="/img/Memorybarrier.jpg" alt=""></p><p>如上图，Memory operation1、Memory operation2 在没有 Memory barrier 『保护』的情况下，其执行顺序可能会发生变化，而若在其间添加 Memory barrier，则可以保证他们的执行顺序不会改变。</p><p>系统也为我们提供了设置 Memory barrier 的接口：<code>OSMemoryBarrier</code>。</p><p>因此，上面例子中，我们只需在 thread1 两条写操作间添加 Memory barrier 即可：<img src="/img/thread1_memorybarrier.png" alt=""></p><blockquote><p>通过各种锁实现的线程同步，基础都实现了 Memory barrier。</p></blockquote><p>得益于锁内部实现了 Memory barrier，说实话，在实际编程中，我们很少需要考虑 Out-of-order execution、compiler reordering、Memory barrier。但并不代表可以无视它，在遇到一些『匪夷所思』的问题时，或许能为你提供一些思路。其实，任何问题都是这样，研究深度决定在分析、解决问题时的思考深度、视野广度。</p><p>介绍完这些多线程的通用问题，我们来看看与 iOS 开发相关的问题。</p><h1 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h1><hr><p>在继续之前，有必要先复习几个概念：变量、指针、指针变量。</p><ul><li>变量——本质就是在内存上分配的一块区域，在代码中一般通过一个名称(变量名)操作它；</li><li>指针——本质就是一个整型数值，标识一块内存的起始地址；</li><li>指针变量——存储指针数值的变量。</li></ul><p>通过一个简单的例子看一下：<img src="/img/ipointer.png" alt=""><br><code>pi</code>是一个指向 <code>int</code> 型的指针变量，其指向了变量<code>i</code>，如下图，我们假设变量<code>i</code>的内存地址为<code>0x0ffab1234678</code>，则变量<code>pi</code>的值就等于<code>0x0ffab1234678</code>。当然，变量<code>pi</code>也有自己的内存地址(假设为：<code>0x0ffab1234660</code>)，也可以有一个指针来指向它，称之为指针的指针(<code>int **</code>)。</p><p><img src="/img/pointer.jpg" alt=""></p><p>对象的属性可分为两种类型：</p><ul><li>值类型——即非指针类型，如<code>int</code>、<code>bool</code>、<code>double</code>；</li><li>引用类型——所有声明为指针类型的属性(OC 中所有对象都是此类型)。</li></ul><p>说到Property线程安全问题，必然会想到在定义Property时可以选择<code>atomic</code>或<code>nonatomic</code>这两个attribute之一，默认为<code>atomic</code>。<br>若在定义 Property 时选择<code>atomic</code>，则系统在实现默认 getter、setter 方法时会加锁。那么<code>atomic</code>一定能实现我们想要的线程安全吗？<br>对于值类型的属性，<code>atomic</code>确实能保证对该属性的操作是 thread-safety。但对于引用类型的属性，则情况更加复杂，不一定能保证 thread-safety。</p><p>我们来看个例子：<br><img src="/img/array_objs.jpg" alt=""><img src="/img/array_objs_addobjects.jpg" alt=""><img src="/img/array-objs-result.jpg" alt=""><br>分别从主线程和子线程往具有<code>atomic</code>attribute 的属性<code>objs</code>中添加了200000个元素，但最终<code>objs</code>中元素的个数小于200000个，明显是由于多线程的 data race 引起的。<br>可以看到此处的<code>atomic</code>并没有解决多线程问题。原因也很简单，对于引用类型的属性，<code>atomic</code>『保护』的是属性本身(本质是一个指针变量)，而我们操作的是属性(指针)所指向的那块内存，其并不在<code>atomic</code>保护的范围之内。</p><p>由于<code>atomic</code>并没有想像中那么有用，并且会有一定的性能问题，因此，一般定义属性时并不会使用它，而是在需要同步时，手动实现。</p><blockquote><p>在使用<code>atomic</code>属性时，还有两个点需要注意：</p><ol><li>若自定义了 getter、setter 方法，则需要自己实现 atomic 语义；</li><li>若直接访问属性的存储变量，则失去了 atomic 语义。</li></ol></blockquote><h1 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h1><hr><p>我们知道，object 在哪个线程上被最终释放，其<code>dealloc</code>方法就会在哪个线程上执行。这里主要的问题在于有些类的<code>dealloc</code>方法在子线程上执行是不安全的，如 <code>UIKit object</code>。</p><p>当我们开启新的子线程时，子线程一般会 retain 其 target，如：</p><ul><li>通过<code>performSelectorInBackground:</code>、<code>performSelector:onThread:</code>方法开启子线程；</li><li>通过<code>NSThread</code>开启子线程；</li><li>通过 GCD 开启子线程，其block引用了 target。</li></ul><p>当子线程 retain 了 target 时，必须要保证该线程对 target 的释放先于主线程。否则，若子线程持有对 target 的最后一个引用，target 的<code>dealloc</code>方法必定会在子线程上执行，这对于 UI 来说是不允许的。</p><p>但有意思的是，我们发现从 iOS8 开始，即使是在子线程上释放 UI 对象，系统也会将其<code>dealloc</code>方法分发到主线程上执行。<br><img src="/img/vcrelease.jpg" alt=""><br>如上图代码，在子线程释放了一个<code>UIViewController</code>的object，按理该 object 的<code>dealloc</code>方法会在子线程中执行，我们在其<code>dealloc</code>方法添加了断点，结果如下：<br><img src="/img/uideallocmainthread.jpg" alt=""><br>可以看到，系统最终还是在主线程上执行了<code>UIViewController</code>的<code>dealloc</code>方法。<br>为了进一步验证，在<code>UIViewController</code>的<code>release</code>方法上添加断点：<br><img src="/img/releasebreakpoint.jpg" alt=""><img src="/img/controllerreleaseresult.png" alt=""><br>可以看到，系统在实现<code>UIViewController</code>的<code>release</code>方法时，做了一定的处理：</p><ul><li>在上图所示的1处，通过<code>pthread_main_np</code>方法判断当前是否是在主线程上执行；</li><li>2处，进行了判断，若不是在主线程上执行，则直接跳转到<code>0x117a18a1a</code>处(跳过了直接执行<code>dealloc</code>方法)；</li><li>3处(<code>0x117a18a1a</code>)，dispatch 到主线程上执行<code>dealloc</code>方法。</li></ul><blockquote><p>需要注意的是，到目前为止还没找到官方文档明确这件事。因此，我们最好不要做这样的假设，还是要从代码角度确保 UI 的 dealloc 方法永远在 main thread 上执行。</p></blockquote><h1 id="target-action"><a href="#target-action" class="headerlink" title="target-action"></a>target-action</h1><hr><p>在 Objective-C 中，实现回调(callback)，主要有两种方式：target-action(observer-selector)、block。<br>这一小节，我们来谈谈 target-action 模式在多线程下存在的问题。<br>target-action 模式通常情形如下：(有两个对象：<code>objA</code>、<code>objB</code>)</p><ul><li><code>objA</code>关心<code>objB</code>上某个特定事件EventA；</li><li><code>objB</code>包含<code>objA</code>的弱引用(weak/assign);</li><li>当<code>objB</code>上 EventA 事件发生时，其回调<code>objA</code>的某个方法；</li><li>通常 EventA 事件发生在子线程上。</li></ul><p>由于，objB 没有强引用 objA，使得 objA 在执行回调时，objA 可能在另外一个线程中被释放，从而出现野指针。<br><img src="/img/target-action.jpg" alt=""></p><p>细想一下，NSNotification、KVO 都属于 target-action(observer-selector) 模式，它们有两个共同点：</p><ul><li>在哪个线程触发，就在哪个线程调用 observer-selector，其引发的最常见问题就是在子线程修改 UI；</li><li>observer 的 selector 是同步执行的。</li></ul><p>进一步深入分析发现：</p><ul><li>从 iOS9 开始，NSNotificaionCenter 在抛通知时会强持有 observer，直到 observer 执行完其 action；<br><img src="/img/notification.png" alt=""><img src="/img/notificationdealloc.jpg" alt=""><br>如上代码，在子线程抛出通知，此后我们的代码就再也没有强引用消息的 observer，但从执行的结果可以看出，首先没有 crash(没有出现野指针)，其次 observer 的<code>dealloc</code>方法在<code>notificationHandler</code>后执行。<br><img src="/img/notificationdeallocstack.jpg" alt=""><br>通过在 observer 的<code>dealloc</code>方法添加断点可以看到，是在<code>postNotificationName:</code>方法中触发了其<code>dealloc</code>方法的执行。</li><li>KVO 在<code>NSKeyValueWillChange</code>方法调用了 observer 的<code>retain</code>方法，从而确保在 KVO 回调执行过程中，observer 不会被释放，出现野指针的问题：<br><img src="/img/KVORetain.jpg" alt=""></li></ul><blockquote><p>与 KVO 不同的是 NSNotificationCenter 并没有直接调用 observer 的<code>retain</code>方法，猜测是通过更加低层的方式对 observer 进行了 retain 操作。</p></blockquote><p>NSNotificationCenter、KVO 的这种处理方式给我们很大的启发：<br><strong><em>在执行回调前先对 target 进行 retain 操作，防止出现野指针问题，在回调完成后再 release。</em></strong></p><p>然而，事情远没这么简单，NSNotificationCenter、KVO 并非线程安全的。</p><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>上面讲到，KVO 在触发时会 retain observer，防止出现野指针，但线程安全问题依然存在。<br><img src="/img/KVOObserverDealloc.jpg" alt=""><br>如上图，observer 在 thread1 上执行 <code>dealloc</code> 时(在调用<code>removeObserver:</code>前) thread2 触发 KVO，此时会在 thread2 上执行 KVO 回调<code>observeValueForKeyPath:</code>，此刻 observer 已成野指针了(虽然 KVO 会调用 observer 的 <code>retain</code> 方法，但由于 observer 的<code>dealloc</code>方法已开始执行，<code>retain</code>也无力回天了！)。</p><p>怎么解决？</p><ul><li>不要使用 KVO，当时在 QQ 阅读项目开发红包模块时，在灰度中发现这类 crash，最终放弃了 KVO 这一方案；</li><li>不要跨线程使用 KVO；</li><li>apple 建议将 observer 设计成一个永不被释放的对象，facebook 著名 KVO 开源框架 <a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">FBKVOController</a> 就采用了这一方法，其内部有一个单例<code>_FBKVOSharedController</code>，专门用于接收所有的 KVO 回调。</li></ul><h2 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h2><p>说到 NSNotificationCenter，第一反应是需要在 observer 的<code>dealloc</code>方法中将其从 Notification Center 移除，否则会 crash。但从 iOS9 开始，并不需要手动在<code>dealloc</code>中移除，原因是在 Notification Center 中 observer 被存储为<code>weak</code>，其最大、最有用的特点就是在其所指 object 释放前会被置为 <code>nil</code>。因此，从 iOS9 开始，NSNotificationCenter 是线程安全的，不会出现像 KVO 那样在 <code>dealloc</code> 执行过程中触发回调的问题。</p><blockquote><p>总结 NSNotificationCenter 在 iOS8、9上的表现，以及 KVO 的表现，可以得出在实现 target-action(delegate) 模式时可借鉴的经验：</p><ul><li>target 一定要是 weak——防止在 target dealloc 过程中触发回调；</li><li>在触发回调前先对 target 进行 retain 操作——防止在回调执行过程中，target 被释放，出现野指针。</li></ul></blockquote><h1 id="block"><a href="#block" class="headerlink" title="block"></a>block</h1><hr><p>作为 callback 的实现方式之一，block 由于具有保存 context 的优势，其使用的广泛程度甚至高于 target-action 模式。说到 block，一定会想到其引发的 retain cycle 问题。<br>为了解决 retain cycle 问题，在 MRC 下一般使用<code>__block</code>，ARC 下使用<code>__weak</code>。<br>在 MRC 下使用<code>__block</code>非常危险(极容易出现野指针)，必须保证在 block 执行时，<code>__block</code>指向的 object 还存在。<br><img src="/img/MRCBlockCrash.jpg" alt=""><br>如上面这个例子，在 dispatch_async 执行过程中，self 被释放，出现野指针。<br>ps：当然这里仅是个例子，实际中 GCD api 一般是不需要考虑 retain cycle。</p><p>ARC 下，由于有 weak，一般不会出现野指针，但 block 在执行时，<code>self</code> 可能已是 <code>nil</code>，处理不好也有可能会 crash。比较好的做法是，将 block 体封装成方法，这时如果 <code>self</code> 为 <code>nil</code>，方法就不会被执行。<br><img src="/img/blocktomethod.jpg" alt=""></p><h1 id="mutable-containers"><a href="#mutable-containers" class="headerlink" title="mutable containers"></a>mutable containers</h1><hr><p>Objective-C 中可变容器是非线程安全的，其导致的多线程问题也是在实际开发中遇到最多的一类线程安全问题。而这其中，<code>*** was mutated while being enumerated.</code>最为常见，并且大多数都是由多线程引起的(一个线程遍历，另一个线程写)。<br>解决这类问题需要注意两点：</p><ul><li>一定不能对外提供接口能直接访问类内部的mutable containers；</li><li>对 containers 的读(包括整个遍历过程)、写都需要加锁做好同步。</li></ul><p>我们都知道 UI 操作需要在主线程执行，除了这点 <code>UITableView</code> 似乎与多线程没啥关系，实则不然。<br>在使用 UITableView 时，我们经常是将其数据(datasource)保存在数组中，而数据来源要么是磁盘、要么是网络，基本都是在子线程完成。<br><img src="/img/tableviewthreadsafe.jpg" alt=""><br>如上图所示，经常犯的一个错误是在子线程获得数据后，直接修改了 UITableView 的 dataSource，而此时可能主线程上 UITableView 的回调也正在读 dataSoure，从而出现 data race 问题。<br>一定要记住，UITableView datasource 的刷新必须要在主线程上完成(当然，请求数据的过程可以在，也应该在子线程上执行)。</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><hr><p>最后分享几个小技巧。</p><h2 id="Thread-Sanitizer-TSan"><a href="#Thread-Sanitizer-TSan" class="headerlink" title="Thread Sanitizer (TSan)"></a>Thread Sanitizer (TSan)</h2><p>针对多线程问题，Apple 在 Xcode8 中推出了扫描工具(目前只支持 64-bit 的模拟器)：Thread Sanitizer (TSan)，其具有以下功能：</p><ul><li>Use of uninitialized mutexes；</li><li>Thread leaks (missing pthread_join)；</li><li>Unsafe calls in signal handlers (ex: malloc)；</li><li>Unlock from wrong thread；</li><li>Data races。</li></ul><p>其中，对 Data races 的扫描功能非常棒！建议大家在每个版本都用 TSan 扫描一次。更多信息可以参看 <a href="https://developer.apple.com/videos/play/wwdc2016/412/" target="_blank" rel="noopener">WWDC2016-412 Thread Sanitizer and Static Analysis</a>。</p><h2 id="放大法定位问题"><a href="#放大法定位问题" class="headerlink" title="放大法定位问题"></a>放大法定位问题</h2><p>由于多线程问题，一般复现难度大，只有在特定的执行时序下才能重现，无疑增加了排查、分析、解决问题的难度。<br>此时，我们可以通过放大法把小概率事件变成大概率事件，如：通过循环反复执行某一操作、通过 sleep 增大不安全的窗口期等。</p><h2 id="提供接口让调用方指定callback-thread"><a href="#提供接口让调用方指定callback-thread" class="headerlink" title="提供接口让调用方指定callback thread"></a>提供接口让调用方指定callback thread</h2><p>callback 应该在哪个 thread 上执行，在开发过程中经常有这样的问题。通常的做法是：要么粗暴的 dispatch 到 main thread，要么直接在当前线程执行。<br>其实，更好的做法是提供接口让调用方指定在哪个 thread callback。<br>目前，有不少开源库都是这么处理的，如：facebook 著名的 websocket 开源库 <a href="https://github.com/facebook/SocketRocket" target="_blank" rel="noopener">SocketRocket</a>：<br><img src="/img/RocketSocket.jpg" alt=""><br>如上图，其在提供<code>delegate</code>接口的同时，提供了两个接口：<code>delegateDispatchQueue</code>、<code>delegateOperationQueue</code>。</p><h2 id="通过-queue-specific-判断当前是否在某个队列中执行任务"><a href="#通过-queue-specific-判断当前是否在某个队列中执行任务" class="headerlink" title="通过 queue specific 判断当前是否在某个队列中执行任务"></a>通过 queue specific 判断当前是否在某个队列中执行任务</h2><p>为了在某队列上同步执行任务，经常需要判断当前是否已在该队列上，否则容易出现 deadlock。通过<code>dispatch_queue_get_specific</code>、<code>dispatch_queue_set_specific</code>这两个 api 可以方便的实现：<br><img src="/img/queuespecific.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>多线程在带来流畅、高效的同时，也带来了无尽的问题。多线程问题本身非常复杂，本文也只是简单分析了几类常见的多线程问题。<br>总的来说，多线程问题并没有什么统一解决方案，因人因事而异，更多的需要依赖开发人员的经验和严谨的态度。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html" target="_blank" rel="noopener">Threading Programming Guide</a><br><a href="https://developer.apple.com/library/content/technotes/tn2109/_index.html" target="_blank" rel="noopener">Simple and Reliable Threading with NSOperation</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/412/" target="_blank" rel="noopener">WWDC2016-412 Thread Sanitizer and Static Analysis</a><br><a href="http://inessential.com/2013/12/20/observers_and_thread_safety" target="_blank" rel="noopener">Observers and Thread Safety</a><br><a href="https://en.wikipedia.org/wiki/Out-of-order_execution" target="_blank" rel="noopener">Out-of-order execution</a><br><a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">Memory barrier</a><br><a href="http://stackoverflow.com/questions/32006565/why-is-uiviewcontroller-deallocated-on-the-main-thread" target="_blank" rel="noopener">Why is UIViewController deallocated on the main thread?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先介绍了多线程的一些基本概念，如：atomicity、Out-of-order execution、Memory barrier等。然后结合 iOS 实际开发，分析了Property、dealloc、target-action、block、mutable containers等在多线程下的问题。最后，分享了几个小技巧。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="Multithreading" scheme="http://zxfcumtcs.github.io/tags/Multithreading/"/>
    
  </entry>
  
  <entry>
    <title>自定义 UI 组件库</title>
    <link href="http://zxfcumtcs.github.io/2017/03/04/CustomUIControls/"/>
    <id>http://zxfcumtcs.github.io/2017/03/04/CustomUIControls/</id>
    <published>2017-03-04T14:34:44.000Z</published>
    <updated>2019-11-23T10:24:45.057Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了通过 View-ViewModel 模式构建 UI 组件，以便提高 UI 组件的可复用性。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>『不要重复造轮子，要注意代码复用，提高开发效率』，这是在日常开发中经常挂在嘴边的话。对 copy code 的行为我们经常也报以鄙视的目光。<br>但是，copy 行为却又时常发生，经常是一言不合就 copy！</p><p>在继续之前，我们有必要思考两个问题：</p><ul><li>什么样的代码被复用的概率最高；</li><li>copy code 的行为为何如此普遍。</li></ul><h2 id="什么样的代码被复用的概率最高"><a href="#什么样的代码被复用的概率最高" class="headerlink" title="什么样的代码被复用的概率最高"></a>什么样的代码被复用的概率最高</h2><p>代码复用可分为二个层级：APP 间以及 APP 内部。<br>APP 间被复用的代码通常是些基础组件，如：网络、数据库、日志系统、磁盘存储系统等。<br>APP 内部复用概率最高的代码个人认为是 UI 组件（本文所说的 UI 组件为 APP 内部自定义的 UI）。</p><h2 id="copy-code-的行为为何经常发生"><a href="#copy-code-的行为为何经常发生" class="headerlink" title="copy code 的行为为何经常发生"></a>copy code 的行为为何经常发生</h2><p>既然大家都会鄙视 copy 行为，为何又时常发生呢？<br>你可能会说 copy 的同学觉悟、追求不高。<br>但，从另一角度是否也说明代码的可复用性、可扩展性比较差。<br>现在一般都是敏捷开发、快速迭代，时间紧、任务重，在遇到相似、相近的代码时，大家通常都是拷一份过来，改吧改吧，而不是在原有基础上费时费力地扩展。这其中的弊端就不用多说了！</p><p>UI 组件作为 APP 内部复用概率最高的代码，更是 copy 的重灾区。究其原因，在于在 UI 组件中包含了大量的业务逻辑，导致一个 UI 组件要复用到另外一个业务下非常困难。主要体现在：</p><ul><li>UI 组件与业务数据相绑定（与后台协议返回的数据结构相对应的 OC 对象，我们称之为 item）；</li><li>UI 组件内部处理了业务逻辑。</li></ul><p>举个例子，在 QQ 阅读的信息流中有一种常见的 UI 样式：左图右文(QRFeedFlowBookView)<br><img src="/img/FeedFLowLeftPictureRightText.jpg" alt=""><br>在当初实现该 UI 样式时，数据是通过 QRFeedFlowBookItem(业务数据结构) 传递给 QRFeedFlowBookView，即在 QRFeedFlowBookView 内部处理了具体的业务数据。这导致，QRFeedFlowBookView 在业务数据不是或不能通过 QRFeedFlowBookItem 表示时，无法复用。<br>还有，像一些角标要不要展现，具体逻辑也是在 QRFeedFlowBookView 中处理的，此时如各个业务对此的逻辑不同，QRFeedFlowBookView 也无法复用。</p><h1 id="以-View-ViewModel-形式构建-UI-组件"><a href="#以-View-ViewModel-形式构建-UI-组件" class="headerlink" title="以 View-ViewModel 形式构建 UI 组件"></a>以 View-ViewModel 形式构建 UI 组件</h1><hr><p>从上面分析出的 UI 组件难于复用的原因，可以看出要解决这一问题，就是要避免上文提到的2点：</p><ul><li>UI 组件不能与具体业务数据相绑定；</li><li>UI 组件内部不能处理业务逻辑（其本职工作仅是 UI 布局）。</li></ul><p>此时，MVVM 模式应该要进入我们的视线了，在该模式中 ViewModel 的存在是不是很好的解决了上面的问题。<br>我们知道在 MVVM 模式中，ViewModel 向上为 View 提供展示数据（该数据已经在 ViewModel 中处理好了，View 无需任何处理，只要展示即可），向下接收来自业务层的数据，处理相关的业务逻辑。</p><p>可以看出，ViewModel 作为中间层很好地将业务与 UI 隔离开。<br>说到 MVVM，很多同学并不喜欢，觉得其中的 Data-Binding 很麻烦，但我们构建 UI 组件时用到的是 View-ViewModel 结构，并不要求一定是 MVVM，在 MVC 等模式下也可使用。</p><p>同时，我们采用的是面向接口的模式，View 对外依赖的是接口（protocol），而不是某个具体的 ViewModel。每个 UI 组件其结构如下所示：<br><img src="/img/ViewViewModel.png" alt=""><br>如上图所示，若某个 UI 组件被多个业务所复用，可以根据需求定义多个 ViewModel 以处理不同的业务逻辑，每个 ViewModel 都实现 ViewModelProtocol 协议为 View 提供数据。</p><p>另外，UI 组件也可以包含(复用)其他 UI 组件。</p><p>如上文提到的左图右文 UI，我们抽取为一个组件 QRLeftPictureRightTextView：<br><img src="/img/QRLeftPictureRightTextView.png" alt=""><img src="/img/QRLeftPictureRightTextViewModel.png" alt=""><br>该控件在信息流以及老书城都有用到，为此我们也定义了两个 ViewModel，以处理各自的业务逻辑：<br><img src="/img/QRLeftPictureRightText.jpg" alt=""></p><p>在日常开发中，经常有同学问『某某样子的 UI 我们现在有吗，是哪个类？』<br>为此，我们在构建 UI 组件库的同时也维护了一份文档，将所有组件都『登记造册』：<br><img src="/img/QRLeftPictureRigthTextDoc.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>通过 ViewModel 这个中间层很好地隔离了 UI 与业务逻辑，使 UI 复用性更好，不仅提高了开发效率，也规范了代码结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍了通过 View-ViewModel 模式构建 UI 组件，以便提高 UI 组件的可复用性。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="组件" scheme="http://zxfcumtcs.github.io/tags/%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>简化 iOS Data Binding</title>
    <link href="http://zxfcumtcs.github.io/2016/11/05/iOSDataBinding/"/>
    <id>http://zxfcumtcs.github.io/2016/11/05/iOSDataBinding/</id>
    <published>2016-11-05T10:55:46.000Z</published>
    <updated>2019-11-23T10:25:19.448Z</updated>
    
    <content type="html"><![CDATA[<p>ZSKVOController 是一个基于 KVO 的 Data Binding 框架，本文简要介绍其实现原理。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>在<a href="https://zxfcumtcs.github.io/2016/07/20/MobileArchitecture/">《不谈框架，谈细节》</a>这篇文章中，简要分析了当前移动开发中几种常见的框架 ( MVC、MVP、MVVM 等)，其中数据绑定 ( Data Binding ) 是 MVVM 与其他 MV* 模式的一个显著区别。目前，iOS 中现实数据绑定主要有两种方式：</p><ul><li>KVO；</li><li>三方开源库 ReactiveCocoa。</li></ul><p>其中，ReactiveCocoa 学习成本比较高，使用并不十分广泛。<br>在<a href="https://zxfcumtcs.github.io/2015/09/18/KVO/">《KVO漫谈》</a>这篇文章中，我们分析了 KVO 实现的基本原理，也对 KVO 存在的问题作了简要的描述，其在使用中存在的问题主要有：</p><ul><li>KeyPath 需要逐个注册，并且是字符串形式的硬编码，无法通过编译器检查错误；</li><li>KVO 回调都集中在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中，通常使得该方法过于庞大；</li><li>observer 的注册与注销必须成对出现，否则极容易出现 crash。</li></ul><p>作为一个优秀的框架或工具至少需要具备两点：</p><ul><li>能提升开发效率；</li><li>不给使用者提供犯错误的机会。</li></ul><p>因此，我们希望简化后的 Data Binding ( 基于 KVO ) 也具备这些优点，具体讲：</p><ul><li>简化注册过程；</li><li>不同的 KeyPath 对应不同的回调方法；</li><li>不需要手动注销 ( 使用者没有犯错的机会 )。</li></ul><h1 id="ZSKVOController"><a href="#ZSKVOController" class="headerlink" title="ZSKVOController"></a>ZSKVOController</h1><hr><p>ZSKVOController 是我们实现的基于 KVO 的 Data Binding 框架。<br>首先，我们看看 ZSKVOController 框架达到的效果：<br>假如：<br>在 ViewModel 中有属性：<code>title</code>、<code>desc</code>，<br>View 需要绑定<code>title</code>、<code>desc</code>，则在 View 中只需做两件事：</p><ul><li>绑定：将 ViewModel 绑定到 View 上<code>[_viewModel zs_addKVOObserver:self];</code>；</li><li>实现方法：<code>zs_observeTitle:</code>、<code>zs_observeDesc:</code>。</li></ul><p>如<code>zs_observeDesc:</code>的实现如下：<br><img src="/img/zs_observeDesc.jpg" alt=""><br>是不是简单多了。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><hr><p>我们知道，对于属性，可以重写 setter 方法，其 setter 方法名是通过一定的规则生成的：’set’ + 属性名(大写首字母)<br>我们也可通过类似的方式生成 KeyPath 对应的 Data Binding 回调方法，如：’zs_observe’ + KeyPath(大写首字母)。</p><p>其余的事情全由 ZSKVOController 框架完成，其结构如下所示：<br><img src="/img/ZSKVOController.png" alt=""></p><p>核心思想：</p><ul><li>在将 observeder(ViewModel) 绑定到 observer(View) 上时 (即调用<code>zs_addKVOObserver:</code>方法)，动态遍历 observer 的实例方法，找到所有符合：”zs_observe*:” 命名规则的方法，从中解析出需要绑定的 KeyPath；</li><li>为了在 observer(View) dealloc 时不需要手动 remove，我们在 observer 上动态添加属性：ZSKVOController，由其注册对 observeder(ViewModel)的绑定，在其 <code>dealloc</code> 方法中 remove KVO；</li><li>为了在 observeder(ViewModel) dealloc 时不需要手动 remove KVO，我们为 observeder 动态添加了一个监视其 dealloc 的『哨兵』属性：ZSObservederDeallocGuard，在其 dealloc 方法中 remove 所有 KVO。</li></ul><p>具体实现细节，请参看源码：<a href="https://github.com/zxfcumtcs/ZSKVOController" target="_blank" rel="noopener">ZSKVOController</a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>ZSKVOController 内部通过 KVO 实现 Data Binding，是对 KVO 的一次封装，从注册到数据变化的处理都有较大的简化，同时，无需手动 remove KVO。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ZSKVOController 是一个基于 KVO 的 Data Binding 框架，本文简要介绍其实现原理。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://zxfcumtcs.github.io/tags/Objective-C/"/>
    
      <category term="Data Binding" scheme="http://zxfcumtcs.github.io/tags/Data-Binding/"/>
    
      <category term="KVO" scheme="http://zxfcumtcs.github.io/tags/KVO/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 问答</title>
    <link href="http://zxfcumtcs.github.io/2016/08/28/Https/"/>
    <id>http://zxfcumtcs.github.io/2016/08/28/Https/</id>
    <published>2016-08-28T09:19:48.000Z</published>
    <updated>2018-12-08T08:41:32.857Z</updated>
    
    <content type="html"><![CDATA[<p>本文从问题入手，简单分析了 HTTPS 中 TLS 握手过程以及简单介绍了数字签名、数字证书、对称加密、非对称加密等知识。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>为了加强网络安全，2015年，Apple 在 iOS9、OS X v10.11 上提出 ATS (App Transport Security) 的概念，旨在通过 HTTPS 建立安全连接。当时，ATS 还是个可选项，但 Apple 在 WWDC 2016 上表示，从2017年1月1日起所有 app 都必须使用 ATS (不清楚不使用的后果是什么，可能是拒绝提交 app store)。</p><blockquote><p>Apple 对 ATS 有如下要求：</p><ol><li>The server must support at least Transport Layer Security (TLS) protocol version 1.2.</li><li>Connection ciphers are limited to those that provide forward secrecy.</li><li>Certificates must be signed using a SHA256 or better signature hash algorithm, with either a 2048 bit or greater RSA key or a 256 bit or greater Elliptic-Curve (ECC) key.</li></ol></blockquote><p>由于系统网络 API，如：<code>NSURLConnection</code>、<code>NSURLSession</code> 已经支持 HTTPS，因此，客户端从 HTTP 切换到 HTTPS 几乎没有什么工作量 (前提是后台使用了可靠的证书)。</p><p>但作为开发人员，对于 HTTPS 的基本概念、流程还是需要了解，以便在出现问题时能快速定位问题、解决问题 (所谓知彼知己)。<br>下面我们将通过问答的形式讨论分析 HTTPS 的基本原理。</p><h1 id="HTTPS-的使命是什么？"><a href="#HTTPS-的使命是什么？" class="headerlink" title="HTTPS 的使命是什么？"></a>HTTPS 的使命是什么？</h1><hr><p><strong>『建立安全的网络连接』</strong><br>没错，但反过来要问了， HTTP 为什么不安全？<br>『HTTP (Hypertext Transfer Protocol，超文本传输协议)』 通过明文传输通信内容，导致信息很容易被窃听、篡改，同时无法验证通信双方的身份。</p><p>因此，HTTPS 要解决这些问题：</p><ul><li>信息加密——防止信息被窃听；</li><li>信息完整性校验——防止信息被篡改；</li><li>身份认证——防止信息劫持。</li></ul><h1 id="HTTPS-与-HTTP-什么关系？"><a href="#HTTPS-与-HTTP-什么关系？" class="headerlink" title="HTTPS 与 HTTP 什么关系？"></a>HTTPS 与 HTTP 什么关系？</h1><hr><p>我们知道，网络协议都是处在 OSI 七层网络模型之中，得益于良好的分层模型，HTTPS 就是在 HTTP 协议栈的基础之上添加了一个安全层 TLS/SSL (Transport Layer Security/Secure Sockets Layer)。<img src="/img/HTTPHTTPS.png" alt="">在 HTTPS 协议栈中，HTTP、TCP 协议无须任何改动，加解密、认证等工作由 TLS 层完成。</p><h1 id="HTTPS-工作原理是什么？"><a href="#HTTPS-工作原理是什么？" class="headerlink" title="HTTPS 工作原理是什么？"></a>HTTPS 工作原理是什么？</h1><hr><p>这是一个很大的问题，细分的话就是 HTTPS 如何完成它的3个使命：加密、完整性校验以及身份认证。<br>这一切都要从 TLS/SSL 协议说起，但在开始之前有必要先了解一些相关的基础知识：</p><h2 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h2><ul><li>对称加密 (Symmetric cryptography)，发送方与接收方使用相同的密钥加密与解密，这也是其最大的弱点，意味着双方在能加密通信前需要传送密钥；</li><li>非对称加密 (也称为公钥加密，Asymmetric cryptography/Public-key cryptography)，旨在解决对称加密必须传送密钥的缺陷。1976年， Whitfield Diffie 与 Martin Hellman 提出在不交换密钥的情况下完成加解密的构想，即 Diffie–Hellman key exchange。1977年，数学家 Rivest、Shamir 以及 Adleman 受 Diffie–Hellman key exchange 的启发，设计出一种非对称加密算法，称之为 RSA 算法，其思想是通信中的一方生成一对密钥：公钥、私钥，公钥分开发布，任何人都可以获取，私钥则是密保的。公钥加密的信息只有私钥能解密，私钥加密的信息也只有其对应的公钥可以解密。</li></ul><p>其中，<a href="https://commons.wikimedia.org/wiki/File:Diffie-Hellman_Key_Exchange_" target="_blank" rel="noopener">Diffie-Hellman Key Exchange在原理大致如下</a>：<img src="/img/Diffie-Hellman_Key_Exchange.png" alt="">更多信息可以参考<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="noopener">Diffie–Hellman key exchange</a>。</p><h2 id="数字签名-Digital-Signature"><a href="#数字签名-Digital-Signature" class="headerlink" title="数字签名 (Digital Signature)"></a>数字签名 (Digital Signature)</h2><p>顾名思义，签名主要就是防伪，数字签名主要用于认证消息的发送者 (发送者无法抵赖)、消息完整性校验。</p><blockquote><p>A digital signature is a mathematical scheme for demonstrating the authenticity of a digital message or documents. A valid digital signature gives a recipient reason to believe that the message was created by a known sender, that the sender cannot deny having sent the message (authentication and non-repudiation), and that the message was not altered in transit (integrity).</p></blockquote><p><img src="/img/DigitalSignature.png" alt=""><br>从<a href="https://upload.wikimedia.org/wikipedia/commons/2/2b/Digital_Signature_diagram.svg" target="_blank" rel="noopener">上图</a>可以看出，数字签名就是将要发送的数据通过 hash 函数计算消息摘要，再通过发送者私钥对摘要加密，最后附加在数据后面一起发送。<br>接收者，在收到消息后通过发送者公钥解密其中的签名，并同样通过 hash 函数计算消息摘要，若两者一致说明消息没有被篡改(完整性)，同时也能证明消息的确来自发送者。其中的关键有两点：</p><ul><li>计算消息摘要的 hash 函数：对输入敏感且不可逆；</li><li>非对称加密：一个公钥解一个私钥，通过发送者发布的公钥能解开的加密信息一定是通过发送者配对的私钥加密的。</li></ul><h2 id="数字证书-Digital-Certificate"><a href="#数字证书-Digital-Certificate" class="headerlink" title="数字证书 (Digital Certificate)"></a>数字证书 (Digital Certificate)</h2><p>仅仅通过非对称加密能实现身份认证吗？<br>我们知道，在非对称加密中，接收方仅仅掌握了所谓来自发送方的公钥，而公钥是不包含任何身份信息的。<br><img src="/img/MiddlemanAttack.jpg" alt=""><br>如上图所示中间人攻击，攻击者可以劫持发送者公钥，将自己的公钥发送给接收者，此时其完全可以冒充发送者与接收者通信，而接收者毫无察觉。<br>此时，数字证书应运而生：<img src="/img/digitalcertificatestructure.jpg" alt=""><br>上图是 X.509 定义的 v3 版数字证书结构，证书本身包含的重要信息有：证书持有者以及公钥、证书签发者、过期时间等。当然，最后还要附上签发者的数字签名，其中，数字签名用于判断证书的真伪。<br>从上面我们知道，数字签名需要使用签发者公钥解密，那么如何获得证书签发者的公钥以便验证证书的真伪？如何判断获得的签发者公钥没被篡改？<br>额，似乎要进入死循环了…</p><p>此时，CA (Certificate Authority，证书授权中心) 应运而生，其作为第三方权威可信机构，承担 PKI 中公钥合法性校验的职责，并签发认证证书以及对证书的维护管理等。</p><blockquote><p>A public key infrastructure (PKI) is a set of roles, policies, and procedures needed to create, manage, distribute, use, store, and revoke digital certificates[1] and manage public-key encryption.</p></blockquote><p><img src="/img/CA.jpg" alt=""><br>上图为证书从 CA 到服务器，再到客户端的大致流程：</p><ul><li>服务器向 CA 提出证书申请 (需要提供公钥、域名、申请人信息等)；</li><li>CA 对提出的申请进行核审；</li><li>核审通过后向申请者签发证书 (证书除了包含申请人公钥、域名等信息，还有证书过期时间，最重要的是 CA 的签名)；</li><li>客户端连接服务器时，服务器下发证书；</li><li>客户端验证证书，若验证通过则进行后续连接操作 (如：协商通信密钥等)。</li></ul><p>再回到前面的问题『如何获得证书签发者的公钥以便验证证书的真伪？如何判断获得的签发者公钥没被篡改？』<br>由于 CA 是公认的权威机构，系统或浏览器会内置其自签名的证书 (根证书)。</p><h2 id="证书链-Certificate-chains"><a href="#证书链-Certificate-chains" class="headerlink" title="证书链 (Certificate chains)"></a>证书链 (Certificate chains)</h2><p>由于证书的需求量巨大，为了减少一级 CA 的工作量，出现了二级、三级、… CA 机构，其签发出来的证书也就构成了一个证书链。<br><img src="/img/CertificateChain.jpg" alt=""><br>如<a href="https://docs.oracle.com/cd/E19693-01/819-0997/gdzen/index.html" target="_blank" rel="noopener">上图</a>所示，所有 CA 机构组成一个树状结构。<br><img src="/img/VerifyingACertificateChain.jpg" alt=""><br>证书的校验逆证书链而上，直到找到系统信任的证书。<br><img src="/img/googleCertificateChain.jpg" alt=""><br>上图是 google.com.hk 的证书链，可以看到 *google.com.hk 的证书是由二级 CA: Google Internet Authority G2签发，而该二级 CA 的证书则由根 CA: GeoTrust Global CA 签发，从而构成一个可信任的证书链。</p><p>好了，下面该回到正题了。</p><h2 id="TLS-SSL-协议"><a href="#TLS-SSL-协议" class="headerlink" title="TLS/SSL 协议"></a>TLS/SSL 协议</h2><hr><p>我们已经知道，在 HTTPS 协议栈中，TLS/SSL 处于 HTTP 与 TCP 之间。进一步细分的话，TLS 分为2层5条协议：<img src="/img/TLSprotocolstack.jpg" alt=""></p><p>其中，TLS Record Protocol 用于处理传输的数据，其主要职责是将上层协议下发的数据分块 (一块最大2^14 = 16384 bytes)、压缩、添加 MAC、加密等 (对于从底层协议上行的数据，其操作正好相反：解密、校验、解压、重组)。<br><img src="/img/RecordProtocoloperation.jpg" alt=""></p><h3 id="TLS-SSL-Handshake"><a href="#TLS-SSL-Handshake" class="headerlink" title="TLS/SSL Handshake"></a>TLS/SSL Handshake</h3><hr><p>TCP 为了建立可靠连接需要三次握手，TLS 为了实现加密、校验、身份认证同样需要握手 (握手，简单讲就是通信双方协商在后续通信过程中需要使用的信息)。</p><p>整个握手过程双方大概要确认以下几点：</p><ul><li>双方通信使用的 TLS 版本；</li><li>交换双方用于生成对称加密密钥的参数；</li><li>确认双方使用的加密算法、压缩算法；</li><li>完成身份认证。</li></ul><p>我们知道，身份认证时的数字签名采用的是非对称加密。出于效率考虑，在 TLS 链接建立后，双方通信时采用的是对称加密。因此，TLS 握手需要确定对称加密密钥 (Master Secret)。目前有两种方法计算 Master Secret：RSA 以及 Diffie-Hellman，因此，TLS Handshake 分为 RSA Handshake、Diffie-Hellman 握手。</p><h3 id="RSA-Handshake"><a href="#RSA-Handshake" class="headerlink" title="RSA Handshake"></a>RSA Handshake</h3><p><img src="/img/RSAHandshake.jpg" alt=""><br>上图是 RSA Handshake 的基本流程：</p><ul><li>Client Hello：客户端首先发起 TLS 握手，告诉服务端其支持的最高 TLS 版本、加密套件列表 (cipher suites)、压缩方法并产生随机数 Random_C；</li><li>Server Hello：服务端根据客户端支持的最大 TLS 版本决定此次通信使用的 TLS 版本、从客户端加密套件列表中选择一种加密套件以及压缩方法、生成随机数 Random_S 并将 Session Id 一起传给客户端；</li><li>Server Certificate：服务端将证书传给客户端以便认证其身份；</li><li>Server Hello Done：告知客户端服务端已完成握手相关的所有数据的传送；</li><li>客户端校验 Server Certificate；</li><li>Client Key Exchange：客户端生成随机密钥 PreMaster Secret，并用服务端公钥加密后发送给服务端；</li><li>Client change_cipher_spec：通知服务端后续消息将加密；</li><li>Client Finished：第一条加密的消息，表示握手完成；</li><li>服务端接收到加密的 PreMaster Secret后，用私钥解密，此时双方都掌握了计算 Master Secret 的所有信息 (Random_C、Random_S、PreMaster Secret)，双方分别计算 Master Secret；</li><li>Server change_cipher_spec：通知客户端后续通信会加密；</li><li>Server Finished：握手完成。</li></ul><h3 id="Diffie-Hellman-Handshake"><a href="#Diffie-Hellman-Handshake" class="headerlink" title="Diffie-Hellman Handshake"></a>Diffie-Hellman Handshake</h3><p>新技术的出现往往是原有技术存在不足或缺陷，那么 RSA Handshake 存在什么问题？<br>在 RSA 中，身份认证以及对 PreMaster Secret 加密使用的是同一对 public-private key，如果攻击者截获了服务器的私钥并窃听了整个握手过程，那么其可以顺利的破解整个通信消息。更严重的是，整个通信过程对称加密密钥是固定不变的，所以即使当前攻击者没有掌握服务端私钥，其可以将整个通信过程记录下来，等其获取到服务端私钥后，再进行破解。</p><p>而在 Diffie-Hellman Handshake 过程中，双方不需要在握手过程中传递类似 PreMaster Secret 的信息，更可喜的是，通过 Diffie-Hellman key exchange 可以生成新的对称密钥，废弃老的密钥，也就是在通信过程中对称密钥不固定，可以随时更换。</p><p>在握手流程上与 RSA Handshake 相比，Diffie-Hellman Handshake 双方都要交换 Diffie–Hellman 参数：<br><img src="/img/Diffie-HellmanHandshake.jpg" alt=""></p><p>下面我们使用 Safari 访问 『<a href="https://www.google.com.hk』，并通过" target="_blank" rel="noopener">https://www.google.com.hk』，并通过</a> Wireshark 抓包来了解一下其中 TSL 握手的过程：<br>1、Client Hello<img src="/img/ClientHello.jpg" alt=""><br>可以看到在 Client Hello 中包含了：TLS Version (客户端支持的最高版本 TLS 1.2)、Random、Cipher Suites (37套)、 Compression Methods (null，表示不压缩)。</p><p>2、Server Hello<img src="/img/ServerHello.jpg" alt=""><br>可以看到在 Server Hello 中包含了：TLS Version (确定双方通信使用 TLS 1.2)、Random、Session ID、Cipher Suite 选择了 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA、不加密 (Compression Method 为 null)。<br>其中，TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 的含义如下：</p><ul><li>TLS 自然表示是 TLS 协议；</li><li>ECDHE 表示使用 Elliptic Curve Diffie-Hellman Ephemeral 方式生成对称加密密钥 (Master Secret)；</li><li>RSA 表示数字签名使用非对称加密 RSA；</li><li>AES_128_CBC 表示对称加密使用 128 bit 的 AES 方式；</li><li>SHA 表示使用安全哈希算法 (Secure Hash Algorithm) 计算摘要。</li></ul><p>3、Server Certificate<img src="/img/ServerCertificate.jpg" alt=""><br>4、Server Key Exchange<img src="/img/ServerKeyChange.jpg" alt=""><br>5、Server Hello Done<img src="/img/ServerHelloDone.jpg" alt=""><br>Server Hello Done 表示服务端已发送完所有握手相关的数据。<br>6、Client Key Exchange<img src="/img/ClientKeyExchange.jpg" alt=""><br>7、Client Change_Cipher_Spec<img src="/img/ClientChangeCipherSpec.jpg" alt=""><br>Change_Cipher_Spec 表示通知对方后续通信将加密 (此时 Master Secret 已计算出来)<br>8、Client Finished (Encrypted Handshke Message)<img src="/img/TLSHandshakeFinished.jpg" alt=""><br>紧接着 Change_Cipher_Spec，会发送一条 Finished 消息，用于验证之前的 key exchange 以及身份认证是否成功。Finished 消息是 TLS 链接建立后的第一条使用握手过程协商的加密算法、密钥加密的消息。Finished 消息的内容是整个握手过程中接收到的数据，对方在接收到 Finished 消息后需要对其解密并验证消息内容是否正确。<br>9、Server Change_Cipher_Spec<br>10、Server Finished<br>服务端同样需要发送 Change_Cipher_Spec、Finished 消息。<br>至此，若所有步骤都正确无误，则 TLS 握手过程顺利完成！后续所有消息都将通过对称加密的方式发送。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>再来看 HTTPS 的三个主要任务：</p><ul><li>加密：通过握手过程协商的加密算法、密钥对消息加密；</li><li>完整性校验：通过 MAC 实现；</li><li>身份认证：通过数字证书完成。</li></ul><p>以上就是 HTTPS 相关的一些知识。</p><h1 id="未尽事宜"><a href="#未尽事宜" class="headerlink" title="未尽事宜"></a>未尽事宜</h1><ul><li>证书管理：证书可能会被 CA 吊销、失效等，终端可以通过 CRL (Certificate Revocation List) 或 OCSP (Online Certificate Status Protocol) 等机制查询证书的状态；<br>在证书中会包含 CRL、OCSP 相关的信息：<img src="/img/CRLOCSP.jpg" alt=""></li><li>session 复用：从上述介绍我们可以知道，建立 TLS 链接是十分耗时的，可以通过 session id 以及 session ticket 机制实现链接复用。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hpbn.co/transport-layer-security-tls/" target="_blank" rel="noopener">Transport Layer Security (TLS)</a><br><a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">The Transport Layer Security (TLS) Protocol Version 1.2</a><br><a href="https://tools.ietf.org/html/rfc5280" target="_blank" rel="noopener">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a><br><a href="http://www.uniroma2.it/didattica/iss/deposito/4_tls.pdf" target="_blank" rel="noopener">Transport Layer Security (secure Socket Layer)</a><br><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener">Keyless SSL: The Nitty Gritty Technical Details</a><br><a href="https://docs.oracle.com/cd/E19693-01/819-0997/gdzen/index.html" target="_blank" rel="noopener">Certificates and Certificate Authorities (CA)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从问题入手，简单分析了 HTTPS 中 TLS 握手过程以及简单介绍了数字签名、数字证书、对称加密、非对称加密等知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="NetWorking" scheme="http://zxfcumtcs.github.io/tags/NetWorking/"/>
    
  </entry>
  
  <entry>
    <title>GUI 架构简述</title>
    <link href="http://zxfcumtcs.github.io/2016/07/20/MobileArchitecture/"/>
    <id>http://zxfcumtcs.github.io/2016/07/20/MobileArchitecture/</id>
    <published>2016-07-20T14:03:26.000Z</published>
    <updated>2019-11-23T10:26:19.814Z</updated>
    
    <content type="html"><![CDATA[<p>本文从细节入手，尝试分析了几种常见的 GUI 架构：MVC、MVCS、MVP、MVVM。对于在实际开发中如何选择给出了一些参考意见。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>移动开发架构，无论是 iOS、Andriod 还是 Web 都属于 GUI (Graphical User Interfaces) 架构范畴。2006年，Martin Fowler 的 <a href="http://martinfowler.com/eaaDev/uiArchs.html" target="_blank" rel="noopener">GUI Architectures</a> 一文可谓是经典之作。文中 Martin Fowler 提到 MVC 模式如何组织代码、划分模块职责，还提到 <a href="http://martinfowler.com/eaaDev/DataBinding.html" target="_blank" rel="noopener">Data Binding</a>、<a href="http://martinfowler.com/eaaDev/FlowSynchronization.html" target="_blank" rel="noopener">Flow Synchronization</a> 以及 <a href="http://www.martinfowler.com/eaaDev/MediatedSynchronization.html" target="_blank" rel="noopener">Observer Synchronization</a> 等核心概念。<br>纵观十年来 GUI 架构演变，无论是 MVCS、MVP 还是 MVVM，其实讨论的核心问题还是如何分层、如何划分模块职责、做好代码隔离。</p><p>谈到 iOS 上常见架构，相信只要有半年以上开发经验的同学都能侃侃而谈。但在实际交流过程中发现不少同学对关键细节问题却认知模糊，甚至是错误的。因此，本文尝试从细节入手对几种常见架构进行简单描述(对架构的认识智者见智、仁者见仁，我所描述的也不一定是正确的)。</p><h1 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h1><hr><p>上文提到各种架构虽各种不同，但它们其实都是在讨论一个问题：『如何分层』。<br>那么在继续之前，我们有必要思考一下：<strong><em>为什么要分层？</em></strong></p><p>计算机界有一句大道至简的名言：</p><blockquote><p>All problems in computer science can be solved by another level of indirection.</p></blockquote><p>之所以要分层，最终目的是降低系统整体复杂度。<br>通过分层我们至少能获得以下能力：</p><ul><li>提供良好的抽象，隐藏实现细节，降低耦合度；</li><li>隔离变化；</li><li>提高模块可复用性；</li><li>增强系统可扩展性。</li></ul><p>说到分层，可能最先想到的例子是 OSI 七层或 TCP/IP 五层网络模型：<img src="/img/OSI.jpg" alt=""><br>在分层网络模型中，不同协议工作在不同网络层，互不干扰，又协调有致，如：IP 协议工作在网络层，主要职责是网络寻址；TCP 协议工作在传输层，主要负责建立可靠的网络连接、负责拥塞控制等。正是因为良好的分层，IP 协议无需关心 TCP 协议的工作，反之亦然。同时 IP 协议也可以在 TCP、UDP 协议间复用。</p><p>如今对网络安全越来越重视，HTTPS 协议也慢慢普及，通过分层，只需在原有 HTTP 协议基础上添加一个 TLS/SSL 的安全传输层即可，由它来负责加解密，而原有的 HTTP、TCP 协议无需修改：<img src="/img/HTTPHTTPS.png" alt=""></p><h1 id="Model-View-Controller"><a href="#Model-View-Controller" class="headerlink" title="Model-View-Controller"></a>Model-View-Controller</h1><hr><p>MVC(Model-View-Controller)作为最经典的架构，广为人熟知，也是 Apple 官方推荐的移动架构。<img src="/img/MVC-Apple.jpg" alt=""><br>MVC模式的核心思想是数据层(Domain)与表现层(Presentation)的隔离。</p><blockquote><p><a href="http://www.martinfowler.com/eaaDev/uiArchs.html" target="_blank" rel="noopener">Separated Presentation:</a><br>Ensure that any code that manipulates presentation only manipulates presentation, pushing all domain and data source logic into clearly separated areas of the program.</p></blockquote><p><img src="/img/DomainPresentation.png" alt=""><br>那么，在数据与展现被隔离之后，它们之间如何同步数据、状态？<br>这就涉及 MVC 模式另一个重要思想：观察者同步(Observer Synchronization)。</p><blockquote><p><a href="http://www.martinfowler.com/eaaDev/MediatedSynchronization.html" target="_blank" rel="noopener">Observer Synchronization:</a><br>Synchronize multiple screens by having them all be observers to a shared area of domain data.</p></blockquote><p>常用方法：在Presentation Object(Controller)中注册通知、设置delegate、传递block等。当数据需要更新时，Domain Object(Model)通过上述方式将数据自底向上的同步给Presentation Object。</p><p>下面简单介绍一下 Model、View、Controller：</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><hr><p>Apple: Model Objects Encapsulate Data and Basic Behaviors.<br>Stanford: Model = What your application is (but not how it is displayed).<br>简单讲：Model = Data + Manipulate Data</p><p>(ps:本文中的Stanford表示斯坦福的 iOS 公开课)<br><img src="/img/QRBookShelfModel.png" alt=""><br>如：我们书架的 Model：<code>QRBookShelfModel</code>，包含了数据：<code>NSArray&lt;QRBookShelfItem *&gt; *books</code>以及对数据的操作：<code>addBook:</code>、<code>deleteBook:</code>等。</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><hr><p>Apple: Controller Objects Tie the Model to the View.<br>Stanford: Controller = How your Model is presented to the user(UI logic).</p><p>Controller 是 Model 与 View 间的连接器，其核心职责有：</p><ul><li>处理用户事件；</li><li>处理展示逻辑；</li><li>连接 Model 与 View。</li></ul><p>这里有个问题：到底什么是展示逻辑？<br>简单讲：将业务数据转换成UI数据，如：</p><ul><li>下载进度，从 Model 层返回的是 double 型，将其转换成可展示的 string 类型(0.811—&gt;81.1%)；</li><li>性别，从 Model 返回的是0、1这样的 int 型，将其转换成：1-&gt;男，0—&gt;女；</li><li>日期，将时间戳格式化：123456789923—&gt;2016-07-01 10:09.</li></ul><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><hr><p>Apple: View Objects Present Information to the User<br>Stanford: View=Your Controller’s minions</p><p>总之，View 只做一件事：layout。</p><h2 id="MVC-规则"><a href="#MVC-规则" class="headerlink" title="MVC 规则"></a>MVC 规则</h2><hr><p>为了实现 MVC 的核心思想：业务 (model) 与展示 (View) 的隔离，必须严格遵守一些规则：</p><ul><li>Controller 依赖(持有) Model、View(可直接与它们通信)；</li><li>Model 与 View 互不可见(不可通信)；</li><li>View 只负责layout，且不能保存业务数据 (需要数据时通过 datasource 方式向 Controller 要)；</li><li>View 可通过 target、delegate 与 Controller 同步状态；</li><li>Model 不能主动与 Controller 通信，通过 Notification、KVO、delegate、block 等机制通知 Controller 数据变化。</li></ul><p>看到这里，大家有没有一种熟悉的味道？<br>没错，UITableView 与外界 (Contoller) 的交互与此处的描述高度一致。<br><img src="/img/MVC.jpg" alt=""></p><p>(关于 MVC 规则的描述，大家也可以参考 Stanford iOS 公开课中的相关内容)</p><h2 id="有问题吗？"><a href="#有问题吗？" class="headerlink" title="有问题吗？"></a>有问题吗？</h2><hr><p>此时，大家或许心中有些疑问：<br>1、在 MVC 模式中，网络请求、数据存储谁来完成？<br>2、Model、View、Controller 谁的可复用性最强？<br>3、展示逻辑为什么由 Controller 完成而不是 View？</p><ul><li><p>在 MVC 模式中，网络请求、数据存储谁来完成？<br>  Controller、Model 都可以，一般由 Model 完成。此时的 Model 已不再是简单的 Model Object，而是 Model layer，在我们项目中通常将其称为 Manager。</p></li><li><p>Model、View、Controller 谁的可复用性最强？<br>  View&gt;Model&gt;Controller</p></li><li><p>展示逻辑为什么由 Controller 完成而不是 View？<br>  View可复用性高，不应关心具体展示逻辑，只专注于 layout</p></li></ul><h2 id="Massive-View-Controller"><a href="#Massive-View-Controller" class="headerlink" title="Massive View Controller"></a>Massive View Controller</h2><hr><p>MVC 模式被批评最多的就是 Controller 过于臃肿，那么 Controller 都做了什么？</p><ul><li>处理复杂的展示逻辑；</li><li>处理用户事件；</li><li>初始化 View、管理部分 View 的生命周期并提供数据；</li><li>处理业务数据变化，转换为 UI 结果；</li><li>获取、存储数据(可选)。</li></ul><p>尤其是如今很多产品经理『擅长』做加法，页面、交互越来越复杂，这对于 Controller 来说无疑是雪上加霜。</p><h1 id="Model-View-Controller-Store"><a href="#Model-View-Controller-Store" class="headerlink" title="Model-View-Controller-Store"></a>Model-View-Controller-Store</h1><hr><p>前面提到，在 MVC 模式中，并没有讨论获取数据属于哪个模块的职责 (一般由 model 负责)。MVCS 模式就是在 MVC 基础上将数据单独提取为一层(Store)。<br><img src="/img/MVCS.png" alt=""></p><h1 id="Model-View-Presenter"><a href="#Model-View-Presenter" class="headerlink" title="Model-View-Presenter"></a>Model-View-Presenter</h1><hr><p>在 MVC 模式中，展示逻辑被划分为 Controller 的职责范围。如今，展示逻辑越来越复杂，Controller 随之也变得越来越臃肿。同时，Controller 也被认为是 View 的一部分，这样 Model 与 View 间并没有完全隔离、解耦。<br>MVP (Model-View-Presenter) 就是在这样的背景下产生的，其将展示逻辑提取为一个单独的层(Presenter)，简化了 Controller，也彻底隔离了 Model 与 View。<br><img src="/img/MVP.png" alt=""></p><p>新产生的 Presenter 层有以下特点：</p><ul><li>UI 无关 (在 Presenter 中不能包含 UIKit 相关头文件)；</li><li>处理展示逻辑；</li><li>Model 与 View 间的桥接者。</li></ul><h1 id="Model-View-View-Model"><a href="#Model-View-View-Model" class="headerlink" title="Model View View-Model"></a>Model View View-Model</h1><hr><p>最近两三年对 MVVM(Model View View-Model) 的讨论比较多，其提出的愿景也是为了简化 Controller、彻底将 View 与 Model 解耦、并提供 Data Binding。<br><img src="/img/MVCMVVM.jpg" alt=""><br>在 MVVM 中 Controller 被认为是 View，更准确的说是：<br><img src="/img/MVMCV.jpg" alt=""></p><h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><hr><p>在 MVVM 模式中，各模块间的依赖关系、数据流向、数据传递的格式都有严格的规定：<br><img src="/img/MVVMRules.jpg" alt=""><br>如上图所示，View、View Model 以及 Model 需要遵守以下规则：</p><ul><li><p>View(UIViewController/UIView):<br>  1.可以依赖(持有) View、View Model，即可直接调用其方法；<br>  2.不能依赖(持有) Model、Model Object(Item)；<br>  3.UI 绑定到View Model上(如：titleLabel.text-&gt;viewModel.title)<br>  4.通过 RACCommands/RACActions 或直接调用 View Model 的方法将用户事件传递给 View Model。</p></li><li><p>View Model:<br>  1.可以依赖(持有) View Model、Model 以及 Model Object；<br>  2.不能依赖(持有) View、Raw Model Object；<br>  3.其公开属性只能是基础数据类型(NSInteger、NSString等)或其他 View Model；<br>  4.将 Model Object 转换成可直接在 View 上显示的属性或Sub View Model(展示逻辑)；<br>  5.接受来自 View 或 Sub View Model 的输入(用户事件)。</p></li><li><p>Model (Layer)：<br>  1.可以依赖(持有) 其他 Model、Model Object、Data Source、Raw Model Object；<br>  2.不能依赖(持有) View Model、View；<br>  3.将 Raw Model Object 转换为 Model Object；<br>  4.为 View Model 提供数据(异步)。</p></li></ul><p>其中，View 与 View Model 类似 UIView 与 CALayer 的关系，一一对应(包括层次结构)：<br><img src="/img/ViewViewModel.jpg" alt=""></p><h2 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h2><hr><p><img src="/img/MVVMDataBinding.jpg" alt=""><br>从上图可知，在 MVVM 中数据流方向与依赖关系正好相反，数据流的流动就是建立在 Observer Synchronization 思想基础之上。</p><p>从 Data Source 到 Model、Model 到 View Model 可采用一般的同步方法，如：Delegate、Notification 以及 block 等。而从 ViewModel 到 View 的 Data Binding 是 MVVM 模式与其他 MV* 模式最大的区别。</p><p>遗憾的是 iOS 并没有原生的 Data Binding 方式，目前大概只能通过两种方式实现 Data Binding：KVO 或 ReactiveCocoa。KVO/RAC是一种更加激进的 Observer Synchronization：</p><ul><li>优势：绑定关系确定后，同步更加方便；</li><li>劣势：数据流不直观，调试较困难；</li></ul><h2 id="MVVM-VS-MVP"><a href="#MVVM-VS-MVP" class="headerlink" title="MVVM VS. MVP"></a>MVVM VS. MVP</h2><hr><p>MVVM 与 MVP 有很多相似的点：</p><ul><li>将展示逻辑从 Controller 中提取出来(分别放到 View Model 和 Presenter 中)；</li><li>分别在 View Model、Presenter 中响应用户事件；</li><li>分别通过 View Model、Presenter 连接 View 与 Model；</li><li>解耦 View 与 Model。</li></ul><p>两者最大的区别在于：MVVM 有 Data Binding 而 MVP 没有。</p><h1 id="华山论剑——MV-VS-MVVM"><a href="#华山论剑——MV-VS-MVVM" class="headerlink" title="华山论剑——MV* VS. MVVM"></a>华山论剑——MV* VS. MVVM</h1><hr><p>根据是否有 Data Binding，可将常见 GUI 构架分为两大阵营：</p><ul><li>有 Data Binding：MVVM；</li><li>没有 Data Binding：MVC、MVP、MVCS 等。</li></ul><p>MVVM 的 Data Binding 在一定程度上增加了编码的复杂度、数据流也变得不够直观、调试难度也有所增加。但对于数据可变的场景，一旦通过 Data Binding 将 View 与 View Model 绑定起来，在数据变化时，会自动映射到 UI 上，十分方便。</p><p>根据展示逻辑是否独立于 Controller，可分为：</p><ul><li>独立：MVVM、MVP</li><li>不独立：MVC、MVCS</li></ul><p>MVVM、MVP 分别将展示逻辑从 Controller 中提取出来，使 Controller 得到一定程度的简化，在展示逻辑复杂的情况下，效果更加明显。</p><h2 id="没有好坏，只有适合"><a href="#没有好坏，只有适合" class="headerlink" title="没有好坏，只有适合"></a>没有好坏，只有适合</h2><hr><p>通过上述分析，我们可以看到，常见几种架构：MVC、MVCS、MVP、MVVM 并没有绝对的好坏之分，只是各有不同的适用场景。<br>我们在选择时可以根据以下两点作为参考依据：</p><ul><li>数据是否可变(UI是动态还是静态)<br>  静态：MV*<br>  动态：MVVM</li><li>展示逻辑是否复杂<br>  复杂：MVVM、MVP</li></ul><h2 id="万变不离其宗——MVC是根"><a href="#万变不离其宗——MVC是根" class="headerlink" title="万变不离其宗——MVC是根"></a>万变不离其宗——MVC是根</h2><hr><p>MVCS、MVP、MVVM 等各种新生架构，虽各有不同，但都是源自于 MVC，它们的核心思想一直没变，也不能变：</p><ul><li>Separated Presentation;</li><li>Observer Synchronization.</li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><hr><p>理论的东西讲了不少，下面结合实际的项目，看看应该如何选择架构。</p><h2 id="书籍详情页"><a href="#书籍详情页" class="headerlink" title="书籍详情页"></a>书籍详情页</h2><hr><p>书籍详情页在整个 QQ 阅读 app 中，无论是展示还是业务逻辑都是最复杂的一个模块。<br><img src="/img/DetailPage.jpg" alt=""></p><ul><li>在书籍下载过程中下载按钮需要显示下载状态(进度)——动态 UI；</li><li>评分、作者分类、包月相关提示、打赏、粉丝榜等展示逻辑十分复杂。</li></ul><p>因此，该模块采用 MVVM 架构比较合适。遗憾的是，当时设计该模块时没有充分意识到其复杂程序，而是选择了传统的 MVC 架构。结果造成详情页 Controller 十分复杂，下面这段就是 Controller 中根据下载状态修改 toolbar 上3个按钮状态的代码(ps：看不清没关系，只要能看出其很复杂即可^_^)：<br><img src="/img/DetailPageChangeBookInfo.jpg" alt=""><br>同时，大量的展示逻辑也耦合在了各个 View 中：<br><img src="/img/BookDetailHeaderView.jpg" alt=""><br>如果，采用 MVVM 架构，各种展示逻辑可以放到相应的 View Model 中，让 View 只专注于 layout。同时在 View Model 中处理下载相关逻辑，使下载逻辑与 View 解耦。</p><h2 id="信息流"><a href="#信息流" class="headerlink" title="信息流"></a>信息流</h2><hr><p>信息流作为 QQ 阅读一大亮点，能为用户个性化推荐书籍，是整个 app 中最重要的一个页面：<br><img src="/img/FeedFlow.jpg" alt=""><br>信息流是最重要的页面，但不是最复杂的页面：</p><ul><li>信息流的数据是静态的，在显示过程中不会改变——静态UI；</li><li>展示逻辑相对简单。</li></ul><p>因此，信息流模块没必要使用复杂的 MVVM 架构。<br><strong><em>很多场景属于此类情形：通过 UITableView 列举多行静态数据，若数据有更新时直接 reload tableview。</em></strong></p><h1 id="无剑胜有剑-皆可为剑"><a href="#无剑胜有剑-皆可为剑" class="headerlink" title="无剑胜有剑 皆可为剑"></a>无剑胜有剑 皆可为剑</h1><hr><p>各种分层架构都是前辈充满智慧的宝贵经验，值得尊敬、借鉴、学习，但也不必拘泥于形式，重点是理解其背后的思想。设计模式有六大原则：</p><ul><li>单一职责原则</li><li>里氏代换原则</li><li>依赖倒转原则</li><li>接口隔离原则</li><li>迪米特法则</li><li>开放-封闭原则</li></ul><p>其中除了里氏代换原则，其他五大原则都是分层架构的指导思想。只要我们深刻理解并能严格遵守这些原则，无论我们选择哪种架构、或在其基础上进行衍化，都能设计出高质量的代码。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>代码设计、架构选择及理解仁者见仁、智者见智，但经典的设计理念是公认的、也是经过时间检验的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://martinfowler.com/eaaDev/uiArchs.html" target="_blank" rel="noopener">GUI Architectures</a><br><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" target="_blank" rel="noopener">Model-View-Controller</a><br><a href="https://www.objc.io/issues/13-architecture/mvvm/" target="_blank" rel="noopener">Introduction to MVVM</a><br><a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/" target="_blank" rel="noopener">Lighter View Controllers</a><br><a href="http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/" target="_blank" rel="noopener">ReactiveCocoa and MVVM, an Introduction</a><br><a href="http://twocentstudios.com/2014/06/08/on-mvvm-and-architecture-questions/" target="_blank" rel="noopener">On MVVM, and Architecture Questions</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从细节入手，尝试分析了几种常见的 GUI 架构：MVC、MVCS、MVP、MVVM。对于在实际开发中如何选择给出了一些参考意见。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="GUI" scheme="http://zxfcumtcs.github.io/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>NSURLSession 拾遗</title>
    <link href="http://zxfcumtcs.github.io/2016/06/09/NSURLSession_Supplements/"/>
    <id>http://zxfcumtcs.github.io/2016/06/09/NSURLSession_Supplements/</id>
    <published>2016-06-09T09:51:28.000Z</published>
    <updated>2018-12-08T08:41:32.859Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了实际开发过程中在 NSURLSession 上遇到的各种问题。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>NSURLSession 是 Apple 在 iOS7 推出的一套网络组件库，用于取代 NSURLConnection(在 iOS9 中已被废弃)。</p><blockquote><p>本文并不是 NSURLSession 的科普文章(这类文章网上已有很多，也可以参考之前的文章：<a href="http://zxfcumtcs.github.io/2014/08/02/NSUrlSession/">NSURLSession—网络框架新生代</a>)。</p></blockquote><p>最近在项目中对下载模块做了一次重构，其中用到 NSURLSession，期间遇到了一些有趣的问题，故小结一下。</p><h1 id="网络错误"><a href="#网络错误" class="headerlink" title="网络错误"></a>网络错误</h1><hr><p>在调试过程中发现，当断开网络时并没有收到回调：<code>URLSession:task:didCompleteWithError:</code>。<br>原来，从 iOS8 开始对于<code>background mode</code>的 NSURLSession，当无法连接服务器时，NSURLSession 并不会调用<code>URLSession:task:didCompleteWithError:</code>，而是让上传、下载任务处于空闲等待状态，当网络恢复后，NSURLSession 自动恢复之前的任务。</p><p>iOS7 上若无法连接服务器会立即调用上述回调方法并返回错误：<br>Error Domain=NSURLErrorDomain Code=-1009 “The Internet connection appears to be offline.”</p><h1 id="timeoutIntervalForResource"><a href="#timeoutIntervalForResource" class="headerlink" title="timeoutIntervalForResource"></a>timeoutIntervalForResource</h1><hr><p>上小节了解到当无法连接服务器时，NSURLSession 并不会将这类问题反馈给业务层，但有时业务层可能需要了解这一事实，从而在 UI 上给出相应的提示。此时可以通过 NSURLSessionConfigure 的<code>timeoutIntervalForResource</code>属性设置一个超时时间。</p><p>在此，需要区分清楚 NSURLSessionConfigure 的两个属性<code>timeoutIntervalForResource</code>与<code>timeoutIntervalForRequest</code>的区别：</p><ul><li>timeoutIntervalForResource：整个任务(上传或下载)完成的最长时间，默认值为1周；</li><li>timeoutIntervalForRequest：两个数据包之间的最大时间间隔；</li></ul><p>timeoutIntervalForResource指整个任务完成的最大时间，简单讲就是 NSURLSession 里面所有 task 完成的总时间(包括因控制最大并发数而排队等待的时间)。</p><h1 id="自动重试"><a href="#自动重试" class="headerlink" title="自动重试"></a>自动重试</h1><hr><p>在调试过程中还发现一个有趣的问题，当把网络调成弱网时：<br><img src="/img/downloadTask-didWriteData-totalBytesWritten-totalBytesExpectedToWrite.png" alt=""><br>上图是在 <code>URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:</code> 中打印的 log，理论上totalBytesWritten应该是递增的，但从上图可以看到出现了断裂，从168640降到了3906，而3906恰是本次接收的字节数(bytesWritten)。<br>这点说明 NSURLSession 在弱网络下出现失败时会自动重试。</p><p>那么，这点对我们有何影响呢？</p><ul><li>业务层基本上不需要再进行重试操作了(以前我们经常会在失败时进行多次重试)；</li><li>如果需要显示进度，需要作特殊处理，不然可能会出现抖动。</li></ul><h1 id="background-mode"><a href="#background-mode" class="headerlink" title="background mode"></a>background mode</h1><hr><p>background 模式下的 NSURLSession 可以在后台执行相应的任务，此时 app 可能处于 background、suspended 或 terminated 状态。当 app 处于 suspended 或 terminated 状态时是不能执行任何代码的，那么下载任务是如何执行的呢？<br>对于 background mode NSURLSession，所有的上传、下载任务都会交由系统在一个独立的进程中执行。<br>通过 instruments 可以看到这个进程：<br>有下载任务时：<img src="/img/NSURLSessionProcess.png" alt=""><br>处于空闲状态时：<img src="/img/NSURLSessionProcess1.png" alt=""></p><p><em>ps：如果用户在任务中心强制将 app kill 掉，所有 background task 都会被 cancel。</em></p><h1 id="identifier"><a href="#identifier" class="headerlink" title="identifier"></a>identifier</h1><hr><p>在创建 background 模式的 NSURLSession 时需要提供一个唯一的<code>identifier</code>，<strong><em>这里的『唯一』不仅仅是在 app 内部，而是在整个系统中都要求是唯一的(因为所有的 background session 都是在同一个进程中处理)。</em></strong>因此，可以将bundle ID拼接到identifier中。</p><p>同时，需要将正在执行中的 session identifier存储起来，当 app crash、suspended 或 terminated 后可以通过存储的 identifier 恢复尚未完成的 sesssion。</p><h1 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a>delegate</h1><hr><p>NSURLSession 会对 delegate 保持强引用，因此像 NSTimer 一样，在任务完成时需要调用 <code>invalidateAndCancel</code> 或 <code>finishTasksAndInvalidate</code> 方法，否则会出现内存泄漏。</p><h1 id="deep-copy-NSURLSessionConfigure"><a href="#deep-copy-NSURLSessionConfigure" class="headerlink" title="deep copy NSURLSessionConfigure"></a>deep copy NSURLSessionConfigure</h1><hr><p>在创建 NSURLSession 时，会对 NSURLSessionConfigure 进行深拷贝，也就是在创建 NSURLSession 后再对 configure 进行修改不会影响之前创建的 session。</p><h1 id="URLSession-downloadTask-didFinishDownloadingToURL"><a href="#URLSession-downloadTask-didFinishDownloadingToURL" class="headerlink" title="URLSession:downloadTask:didFinishDownloadingToURL:"></a>URLSession:downloadTask:didFinishDownloadingToURL:</h1><hr><p>在下载任务完成后，NSURLSession 会回调该方法，在该方法返回前需要将下载文件(保存在<code>location</code>参数指定的位置)读取到内存或拷贝到其他地方，在该方法返回后系统会自动删除<code>location</code>处的下载文件。</p><h1 id="application-handleEventsForBackgroundURLSession-completionHandler"><a href="#application-handleEventsForBackgroundURLSession-completionHandler" class="headerlink" title="application:handleEventsForBackgroundURLSession:completionHandler:"></a>application:handleEventsForBackgroundURLSession:completionHandler:</h1><hr><p>当 app 处于 suspended 或 terminated 状态，若此时有 background session 完成任务或需要鉴权，系统会调用该方法。通过该方法系统会传递一个 block 类型的 <code>completionHandler</code>过来，在我们处理完 session 相关的任务后，需要执行该 block，在执行完该 block 后，系统大概在5秒后再次被挂起。</p><h1 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h1><hr><p>当 cacel 正在执行中的 session task 时，NSURLSession 会回调 <code>URLSession:task:didCompleteWithError:</code> 方法，并返回错误信息：<br>Error Domain=NSURLErrorDomain Code=-999 “cancelled”</p><h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><hr><p>在 NSURLSession 带来的诸多利好中还有一个就是在 iOS9 上自动支持 HTTP/2，无需使用方额外做任何事情。<br>HTTP/2 与 HTTP/1.1、HTTP/1.0相比，特大的特点就是『快』。<br><a href="https://medium.com/apps-and-networking/http-2-makes-media-loading-3-15-times-faster-on-mobile-a455c3e68135#.1ptt4gx4s" target="_blank" rel="noopener">HTTP/2 makes media loading 3–15 times faster on mobile</a> 这篇文章对 HTTP/2 与 HTTP/1.1 在速度上做了对比：<br><img src="/img/http2vs1wifi.jpg" alt=""><br><img src="/img/http2vs13g.png" alt=""></p><p>HTTP/2 与 HTTP/1.1相比主要区别有：</p><ul><li>每个 Host 只需一个 TCP connection；</li><li>连接多路复用(HTTP/1.0 中一个连接一次只能有一个请求、HTTP/1.1 中一个连接同时可以有多个请求，但一次只能有一个响应，HTTP/2则完全是多路复用的)；</li><li>request 可以设置优先级；</li><li>二进制协议(HTTP：超文本传输协议，以前是文本协议)；</li><li>头部压缩；</li><li>服务器可以主动 push。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="noopener">URL Session Programming Guide</a><br><a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/" target="_blank" rel="noopener">NSURLSession Class Reference</a><br><a href="http://stackoverflow.com/questions/23288780/nsurlsessiontask-never-calls-back-after-timeout-when-using-background-configurat" target="_blank" rel="noopener">NSURLSessionTask never calls back after timeout when using background configuration</a></p><p><a href="https://http2.github.io/faq/" target="_blank" rel="noopener">HTTP/2 Frequently Asked Questions</a><br><a href="https://medium.com/apps-and-networking/http-2-makes-media-loading-3-15-times-faster-on-mobile-a455c3e68135#.1ptt4gx4s" target="_blank" rel="noopener">HTTP/2 makes media loading 3–15 times faster on mobile</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了实际开发过程中在 NSURLSession 上遇到的各种问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="NetWorking" scheme="http://zxfcumtcs.github.io/tags/NetWorking/"/>
    
  </entry>
  
  <entry>
    <title>细说 NSOperation</title>
    <link href="http://zxfcumtcs.github.io/2016/05/17/NSOperation/"/>
    <id>http://zxfcumtcs.github.io/2016/05/17/NSOperation/</id>
    <published>2016-05-17T15:25:12.000Z</published>
    <updated>2018-12-08T08:41:32.859Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细介绍了在实现同步、异步 NSOperation 时分别需要实现哪些方法、注意哪些问题。最后对 GCD 与 NSOperation Queue 作了一个简单的对比。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>在 iOS 中实现并发编程主要有三种方式：GCD、NSOperation Queue以及Thread，其中前两者使用广泛。<br>在正式开始之前有必要区分两组概念：同步、异步与串行、并行。</p><ul><li>同步(Synchronous)、异步(Asynchronous)通常指方法(或函数)，同步方法表示直到任务完成才返回(如：<code>dispatch_sync</code>)，异步方法则是将任务抛出去，在任务没完成前就返回(如：<code>dispatch_async</code>)；</li><li>串行(Serial)、并行(Concurrent)通常指 App 执行一组任务的模式，串行表示一次只能执行一个任务，只有当前一个任务完成后才启动下一个任务，而并行指可以同时执行多个任务。最常见的莫过于 GCD 中的串行、并行队列。</li></ul><p>NSOperation Queue + NSOperation 作为 iOS 中『高级的、面向对象的并发编程方式』耳熟能详，但具体到一些细节问题上认识往往又比较模糊。本文在苹果官方文档 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html" target="_blank" rel="noopener">Concurrency Programming Guide</a>、<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/index.html" target="_blank" rel="noopener">NSOperation Class Reference</a> 以及 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperationQueue_class/index.html" target="_blank" rel="noopener">NSOperationQueue Class Reference</a> 的基础上做了一次疏理和总结。</p><h1 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h1><hr><p><code>NSOperation</code> 本身是个抽象类，在使用前必须子类化(系统预定义了两个子类：<code>NSInvocationOperation</code> 和 <code>NSBlockOperation</code>)。那问题来了，在子类化过程中，需要重写父类的哪些方法？</p><p>这首先就要了解一下<code>NSOperation</code>类中几个重要方法的默认实现：<br><img src="/img/NSOperationDefault.png" alt=""><br>在 NSOperation 中还有一个重要概念：operation 的状态，并且当状态变化时需要通过 KVO 的方式通知外：<br><img src="/img/NSOperationKeypath.png" alt=""><br>回到前面那个问题：子类化 NSOperation 时需要重写哪些方法？<br>这取决于子类化后的 operation 是 Synchronous 还是 Asynchronous(NSOperation 默认是Synchronous)。</p><h2 id="Synchronous-VS-Asynchronous-Operations"><a href="#Synchronous-VS-Asynchronous-Operations" class="headerlink" title="Synchronous VS. Asynchronous Operations"></a>Synchronous VS. Asynchronous Operations</h2><hr><p>由于操作 NSOperation 与 NSOperation 任务的执行往往在不同的线程上进行，在继续之前需要强调线程安全问题：『NSOperation 本身是 thread-safe，<em>当我们在子类重写或自定义方法时同样需要保证 thread-safe</em>』。</p><h3 id="Synchronous-Operations"><a href="#Synchronous-Operations" class="headerlink" title="Synchronous Operations"></a>Synchronous Operations</h3><p>对于 Synchronous Operation，在调用其 <code>start</code> 方法的线程上同步执行该 operation 的任务，<code>start</code> 方法返回时 operation 执行完成。因此，对于 Synchronous Operation 一般只需重写 <code>main</code> 方法即可(<code>start</code>方法的默认实现已实现相关 KVO 功能)。</p><h3 id="Asynchronous-Operations"><a href="#Asynchronous-Operations" class="headerlink" title="Asynchronous Operations"></a>Asynchronous Operations</h3><p>然而对于 Asynchronous Operation，调用其 <code>start</code> 方法后，在 <code>start</code> 返回时 operation 的任务可能还没完成(为了实现异步，一般需要在其他线程执行 operation 的具体任务)。因此 <code>start</code> 方法默认实现不能满足异步需要(默认实现会在<code>start</code>返回前将 <code>isExecuting</code> 置为 NO、<code>isFinished</code> 置为 YES，并产生 KVO 通知)。此时至少需要重写以下方法：</p><ul><li>start：<br>  我们知道 NSOperation 本身不具备并发(或者说异步执行)能力，因此需要 <code>start</code> 方法来实现，可以通过创建子线程或其他异步方式完成。同时需要在任务开始前将 <code>isExecuting</code> 置为YES 并抛出 KVO 通知。<br>  <strong><em>『重写的 <code>start</code> 方法一定不能调用 <code>[super start]</code>』</em></strong></li><li>asynchronous<br>  返回 YES，一般不需要抛出 KVO 通知</li><li>executing<br>  返回 operation 的执行状态，在其值发生变化时需要在 <code>isExecuting</code> 上抛出 KVO 通知</li><li>finished<br>  返回 operation 的完成状态，同样值变化时需要在 <code>isFinished</code> 上抛出 KVO 通知</li></ul><p>这里我们看看著名的网络框架 AFNetworking 中关于 NSOperation 的使用：</p><blockquote><p>AFNetworking 3.0 全面使用 <code>NSURLSession</code>，而 <code>NSURLSession</code> 本身是异步的、且没有 <code>NSURLConnection</code> 需要 runloop 配合的问题，因此在3.0版本中并没有使用 NSOperation，代码得到很大的简化。这里我们说的是 AFNetworking 2.3.1 版本。</p></blockquote><p>在 AFNetworking 中 AFURLConnectionOperation 是个异步的 NSOperation 子类，其 <code>start</code> 方法如下：<br><img src="/img/AFURLConnectionOperation-start.png" alt=""><br>从上面 <code>start</code> 方法的实现可以看到：</p><ol><li>用 lock(递归锁) 保证了thread-safe；</li><li>检查了 operation 是否已被 cancel；</li><li>检查了 operation 是否已 ready；</li><li>通过子线程实现并发；</li><li>在 state setter 中实现了 KVO。<br><img src="/img/AFURLConnectionOperation-statesetter.png" alt=""></li></ol><p>再来看看 AFURLConnectionOperation 使用的子线程：<br><img src="/img/AFURLConnectionOperation-thread.png" alt=""><br>可以看到，所有 AFURLConnectionOperation 实例底层使用的是同一个子线程，并在该线程中启动了 runloop（<code>NSURLConnection</code> 的网络回调必须要有 runloop 的配合，通过port-based input source 唤醒 runloop 处理网络事件），也就是说 AFURLConnectionOperation 是在一条常驻子线程中处理网络回调。</p><p>前面我们提到 operation 被 cancel 时也被认为是完成，这点在自定义 <code>start</code> 时同样需要注意：<br><img src="/img/AFURLConnectionOperation-cancel.png" alt=""><br>在 AFURLConnectionOperation 的 <code>cancelConnection</code> 以及 <code>connection:didFailWithError:</code> 方法中都会调用其 <code>finish</code> 方法：<br><img src="/img/AFURLConnectionOperation-finish.png" alt=""><br>ps：虽然 NSOperation 支持 cancel，但在调用 <code>cancel</code> 方法后该如何处理完全由我们自定义的 <code>start</code> 方法决定(当然良好的设计应该要符合 cancel 的语义)。</p><p>同时，AFURLConnectionOperation 也实现了以下方法：<br><img src="/img/AFURLConnectionOperation-isReady-isFinished.png" alt=""></p><h3 id="关于-NSOperation-其他细节问题"><a href="#关于-NSOperation-其他细节问题" class="headerlink" title="关于 NSOperation 其他细节问题"></a>关于 NSOperation 其他细节问题</h3><hr><ul><li><p>dependencies:<br>  我们可以在 operation 间添加依赖关系，在某个 operation 所依赖的 operations 完成之前，其一直处于未就绪状态(<code>isReady</code> 为 NO)。<br>  需要注意的是，依赖关系是 operation 自身的状态，也就是说有依赖关系的 operations 可以处在不同的 NSOperationQueue 中。</p></li><li><p>isReady:<br>  <code>isReady</code> 默认实现主要处理 operation 间的依赖关系，当我们自定义该方法时需要考虑 <code>super</code> 的值，如 AFURLConnectionOperation中关于 <code>isReady</code> 的实现：<img src="/img/AFURLConnectionOperation-isReady.png" alt=""></p></li><li><p>qualityOfService:<br>  用于表示 operation 在获取系统资源时的优先级，默认值：<code>NSQualityOfServiceBackground</code>，我们可以根据需要给 operation 赋不同的优化级，如最高优化级：<code>NSQualityOfServiceUserInteractive</code>。</p></li><li><p>queuePriority:<br>  用于设置 operation 在 operation queue 中的相对优化级，同一 queue 中优化级高的 operation(<code>isReady</code> 为 YES) 会被优先执行。需要注意区分<code>qualityOfService</code>(在系统层面，operation 与其他线程获取资源的优先级)与<code>queuePriority</code>(同一 queue 中 operation 间执行的优化级)的区别。<br>  同时，需要注意<code>dependencies</code>(严格控制执行顺序)与<code>queuePriority</code>(queue 内部相对优先级)的区别。</p></li></ul><h1 id="NSOperation-Queue"><a href="#NSOperation-Queue" class="headerlink" title="NSOperation Queue"></a>NSOperation Queue</h1><hr><p>NSOperation Queue 用于管理、执行 NSOperation，无论其中的 operation 是并行还是串行，queue 都会在子线程(借用 GCD)中执行 operation。<br>从上小节我们知道，实现异步 operation 比同步 operation 要复杂许多，因此如果打算将 operation 加入 queue 中，则完全可以将 operation 实现为同步方式。<br>对于 queue 中已就绪的 operation，queue 会选择 <code>queuePriority</code> 值最大的 operation 执行。</p><p>关于 NSOperation Queue 有两点需要强调：</p><ul><li>cancelAllOperations：用于取消队列中的 operations，对 queue 中所有 operations 调用 <code>cancel</code>方法。(从上小节我们知道，对 operation 调用 <code>cancel</code> 方法后的效果完全由 operation 自己决定。<code>cancel</code> 唯一能影响的就是清除 operation 的依赖关系，使其立即可以被执行)。此时 queue 并不会 remove 其中的 operations，remove 操作仅发生在 operation 完成时。</li><li>suspended：将该属性置为 YES，会阻止 queue 执行新的 operation，但已经在执行中的 operation 不受此影响。</li></ul><h1 id="GCD-vs-NSOperation-Queue"><a href="#GCD-vs-NSOperation-Queue" class="headerlink" title="GCD vs. NSOperation Queue"></a>GCD vs. NSOperation Queue</h1><hr><p>GCD 与 NSOperation Queue 作为常见的并发编程方式，在使用时该如何选择？<br>首先，对比一下我们关心的几个问题：<br><img src="/img/GCDvsNSOperationQueue.png" alt=""><br>我们可以看到，NSOperation Queue 作为高级 API，有很多 GCD 没有的功能，如需要支持：控制并发数、取消、添加依赖关系等需要使用 NSOperation Queue。<br>另外，由于 block 可复用性没有 NSOperation 好，对于独立性强、可复用性高的任务建议使用 NSOperation 实现。<br>当然，NSOperation 在使用时需要 sub-classing，工作量较大，对于简单的任务使用 GCD 即可。</p><p>别忘了，我们还有第三种选择：NSThread。由于使用 NSThread 时需要处理线程相关的问题，一般很少使用。但无论是 GCD 还是 NSOperation Queue，其中的任务具体何时执行是由系统控制的，对于实时性要求很高的任务则可以使用 NSThread。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>本文简单讨论了在使用 NSOperation 时需要重写哪些方法、注意哪些问题。同时也对 GCD 与 NSOperation Queue 作了简单对比，在清楚了它们各自的特点之后再做选择时会更加清晰。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p> <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html" target="_blank" rel="noopener">Concurrency Programming Guide</a><br> <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/index.html" target="_blank" rel="noopener">NSOperation Class Reference</a><br> <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperationQueue_class/index.html" target="_blank" rel="noopener">NSOperationQueue Class Reference</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细介绍了在实现同步、异步 NSOperation 时分别需要实现哪些方法、注意哪些问题。最后对 GCD 与 NSOperation Queue 作了一个简单的对比。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
