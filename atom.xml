<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雪峰的blog</title>
  <icon>https://www.gravatar.com/avatar/00bbf828835d0686e9010b2a2e951bdd</icon>
  <subtitle>善于总结, 乐于分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zxfcumtcs.github.io/"/>
  <updated>2022-03-19T08:17:40.631Z</updated>
  <id>http://zxfcumtcs.github.io/</id>
  
  <author>
    <name>赵雪峰</name>
    <email>zxfcumtcs@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 新并发框架之 Sendable</title>
    <link href="http://zxfcumtcs.github.io/2022/03/19/SwiftModernConcurrency-sendable/"/>
    <id>http://zxfcumtcs.github.io/2022/03/19/SwiftModernConcurrency-sendable/</id>
    <published>2022-03-19T07:46:45.000Z</published>
    <updated>2022-03-19T08:17:40.631Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 『 Swift 新并发框架 』系列文章的第三篇，主要介绍 Swift 5.6 引入的 Sendable。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><p>本系列文章对 Swift 新并发框架中涉及的内容逐个进行介绍，内容如下：</p><ul><li><p>Swift 新并发框架之 async/await</p></li><li><p>Swift 新并发框架之 actor</p></li><li><p>Swift 新并发框架之 Sendable</p></li><li><p>Swift 新并发框架之 Task</p></li></ul><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>书接前文 (<a href="">『 Swift 新并发框架之 actor 』</a>)，本文主要介绍 Sendable 为何物以及如何解决前文提到的那些问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The Sendable protocol indicates that value of the given type can</span></span><br><span class="line"><span class="comment">/// be safely used in concurrent code.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Sendable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Sendable</code> 是一个空协议：</p><p><strong>用于向外界声明实现了该协议的类型在并发环境下可以安全使用，更准确的说是可以自由地跨 actor 传递。</strong></p><p>这属于一种 『 语义 』上的要求。</p><p>像 <code>Sendable</code> 这样的协议有一个专有名称：<em>『 Marker Protocols 』</em>，其具有以下特征：</p><ul><li><p>具有特定的语义属性 (semantic property)，且它们是编译期属性而非运行时属性。</p><p>如 <code>Sendable</code> 的语义属性就是要求并发下可以安全地跨 actor 传递；</p></li><li><p>协议体必须为空；</p></li><li><p>不能继承自 non-marker protocols (这其实是第 2 点的延伸)；</p></li><li><p>不能作为类型名用于 <code>is</code>、<code>as?</code>等操作</p><p>如：x is Sendable，编译报错: Marker protocol ‘Sendable’ cannot be used in a conditional cast.</p></li><li><p>不能用作泛型类型的约束，从而使某类型遵守一个 non-marker protocol，如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Error: Conditional conformance to non-marker protocol 'P' cannot depend on conformance of 'T' to non-marker protocol 'Sendable'</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">A</span>: <span class="title">P</span> <span class="title">where</span> <span class="title">T</span>: <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们知道，值语义 (Value semantics) 类型在传递时 (如作为函数参数、返回值等) 是会执行拷贝操作的，也就是它们跨 Actor 传递是安全的。故，这些类型隐式地自动遵守 <code>Sendable</code> 协议，如：</p><ul><li><p>基础类型，<code>Int</code>、<code>String</code>、<code>Bool</code> 等；</p></li><li><p>不含有引用类型成员的 <code>struct</code>；</p></li><li><p>不含有引用类型关联值的 <code>enum</code>；</p></li><li><p>所含元素类型符合 <code>Sendable</code> 协议的集合，如：<code>Array</code>、<code>Dictionary</code> 等。</p></li></ul><p>当然了，所有 actor 类型也是自动遵守 <code>Sendable</code> 协议的。</p><blockquote><p>事实上是所有 actor 都遵守了 <code>Actor</code>协议，而该协议继承自 <code>Sendable</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@available</span>(macOS <span class="number">10.15</span>, iOS <span class="number">13.0</span>, watchOS <span class="number">6.0</span>, tvOS <span class="number">13.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Actor</span> : <span class="title">AnyObject</span>, <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">    nonisolated <span class="keyword">var</span> unownedExecutor: <span class="type">UnownedSerialExecutor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>class 需要主动声明遵守 <code>Sendable</code> 协议，并有以下限制：</p><ul><li><p>class 必须是 <code>final</code>，否则有 Warning: Non-final class ‘X’ cannot conform to ‘Sendable’; use ‘ @unchecked Sendable’</p></li><li><p>class 的存储属性必须是 immutable，否则有 Warning: Stored property ‘x’ of ‘Sendable’-conforming class ‘X’ is mutable</p></li><li><p>class 的存储属性必须都遵守 <code>Sendable</code> 协议，否则 Warning: Stored property ‘y’ of ‘Sendable’-conforming class ‘X’ has non-sendable type ‘Y’</p></li><li><p>class 的祖先类 (如有) 必须遵守 <code>Sendable</code> 协议或者是 <code>NSObject</code>，否则 Error: ‘Sendable’ class ‘X’ cannot inherit from another class other than ‘NSObject’。</p></li></ul><p>以上这些限制都很好理解，都是确保实现了 <code>Sendable</code> 协议的类数据安全的必要保障。</p><p>回到上面那个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AccountManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">user</span><span class="params">()</span></span> async -&gt; <span class="type">User</span> &#123;</span><br><span class="line">    <span class="comment">// Warning: Non-sendable type 'User' returned by implicitly asynchronous call to actor-isolated instance method 'user()' cannot cross actor boundary</span></span><br><span class="line">    <span class="keyword">return</span> await bankAccount.user()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，要消除例子中的 Warning，只需让 <code>User</code> 实现 <code>Sendable</code>协议即可。</p><p>就本例而言，<code>User</code>有 2 种改造方案：</p><ul><li><p>由 class 改成 struct：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>手动实现 <code>Sendable</code> 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>: <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>回头想想，<code>Sendable</code> 对实现它的 class 的要求是不是太严格了 (final、immutable property) ？！</p><p>有点过于理想，有点不切实际</p><p>从并发安全的角度说，完全可以通过传统的串行队列、锁等机制保障。</p><p>此时，可以通过 <code>@unchecked</code> attribute 告诉编译器不进行 <code>Sendable</code> 语义检查，如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于说 User 的并发安全由开发人员自行保证，不用编译器检查</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>: @<span class="title">unchecked</span> <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Sendable</code> 作为协议只能用于常规类型，对于函数、闭包等则无能为力。</p><p>此时，就轮到 <code>@Sendable</code> 登场了。</p><h1 id="Sendable"><a href="#Sendable" class="headerlink" title="@Sendable"></a>@Sendable</h1><hr><p>被 <code>@Sendable</code> 修饰的函数、闭包可以跨 actor 传递。</p><p>对于前文提到的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">addAge</span><span class="params">(amount: Int, completion: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    age += amount</span><br><span class="line">    completion(age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AccountManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">addAge</span><span class="params">()</span></span> async &#123;</span><br><span class="line">    <span class="comment">// Wraning: Non-sendable type '(Int) -&gt; Void' passed in implicitly asynchronous call to actor-isolated instance method 'addAge(amount:completion:)' cannot cross actor boundary</span></span><br><span class="line">    await bankAccount.addAge(amount: <span class="number">1</span>, completion: &#123; age <span class="keyword">in</span></span><br><span class="line">      <span class="built_in">print</span>(age)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需对 <code>addAge</code> 方法的 <code>completion</code> 参数加上 <code>@Sendable</code> 即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addAge</span><span class="params">(amount: Int, completion: @Sendable <span class="params">(User)</span></span></span> -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure><p>总结一下，用<code>@Sendable</code> 修饰 Closure 真正意味着什么？</p><p><strong>其实是告诉 Closure 的实现者，该 Closure 可能会在并发环境下调用，请注意数据安全！</strong></p><p><em>因此，如果对外提供的接口涉及 Closure (作为方法参数、返回值)，且其可能在并发环境下执行，就应用 <code>@Sendable</code>修饰。</em></p><blockquote><p>根据这一原则，actor 对外的方法如涉及 Closure，也应用 <code>@Sendable</code>修饰。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Task</span> <span class="title">where</span> <span class="title">Failure</span> == <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(priority: <span class="type">TaskPriority</span>? = <span class="literal">nil</span>, operation: @escaping @<span class="type">Sendable</span> () async <span class="keyword">throws</span> -&gt; <span class="type">Success</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如 <code>Task</code> 的 <code>operation</code> 闭包会在并发环境下执行，故用了 <code>@Sendable</code> 修饰。</p><p>当然编译器会对 @Sendable Closure 的实现进行各种合规检查：</p><ul><li><p>不能捕获 actor-isolated 属性，否则 Error: Actor-isolated property ‘x’ can not be referenced from a Sendable closure；(原因也很简单，@Sendable Closure 可能会在并发环境下执行，这与 actor 串行保护数据有冲突)</p><blockquote><p>如果 @Sendable 闭包是异步的 (@Sendable () async )，则不受此限制。</p><p>大家可以思考一下是为啥？</p></blockquote></li><li><p>不能捕获 <code>var</code> 变量，否则 Error: Mutation of captured var ‘x’ in concurrently-executing code；</p></li><li><p>所捕获对象必须实现 Sendable 协议，否则 Warning: Capture of ‘x’ with non-sendable type ‘X’ in a <code>@Sendable</code> closure。</p></li></ul><p>还记得 <a href="">Swift 新并发框架之 actor</a> 中最后那个 crash 吗：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">testUser</span><span class="params">(callback: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</span><br><span class="line">      <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        callback()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="type">User</span>.<span class="keyword">init</span>(name: <span class="string">"Tom"</span>, age: <span class="number">18</span>)</span><br><span class="line">    user.testUser &#123;</span><br><span class="line">      <span class="keyword">let</span> b = <span class="keyword">self</span>.balances[<span class="number">1</span>] ?? <span class="number">0.0</span></span><br><span class="line">      <span class="keyword">self</span>.balances[<span class="number">1</span>] = b + <span class="number">1</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"i = \(0), \(Thread.current), balance = \(String(describing: self.balances[1]))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 crash 该如何 fix 呢？</p><p>可以思考一下~</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 由于 callback 会在并发环境下执行，故用 `@Sendable` 修饰</span></span><br><span class="line">  <span class="comment">// 一般情况下，@Sendable closure 都是异步的，否则受限于 @Sendable 的规则无法捕获 Actor-isolated property</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(callback: @escaping @Sendable <span class="params">()</span></span></span> async -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</span><br><span class="line">      <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        <span class="comment">// 在同步上下文中一般通过 Task 开启一个异步上下文</span></span><br><span class="line">        <span class="type">Task</span>&#123;</span><br><span class="line">          await callback()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">changeBalances</span><span class="params">(newValue: Double)</span></span> &#123;</span><br><span class="line">    balances[<span class="number">1</span>] = newValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="type">User</span>.<span class="keyword">init</span>(name: <span class="string">"Tom"</span>, age: <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    user.test &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> b = await <span class="keyword">self</span>.balances[<span class="number">1</span>] ?? <span class="number">0.0</span></span><br><span class="line">      <span class="comment">// 对 Actor-isolated property 的修改需提取到单独的方法里</span></span><br><span class="line">      <span class="comment">// 不能直接在 @Sendable 闭包修改</span></span><br><span class="line">      await <span class="keyword">self</span>.changeBalances(newValue: b + <span class="number">1</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"i = \(0), \(Thread.current), balance = \(String(describing: await self.balances[1]))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Future-Improvement"><a href="#Future-Improvement" class="headerlink" title="Future Improvement"></a>Future Improvement</h1><hr><p>Apple 在 <a href="https://developer.apple.com/videos/play/wwdc2021/10133/" target="_blank" rel="noopener">Protect mutable state with Swift actors - WWDC21</a> 上提到将来 Swift 编译器会禁止共享 (传递) 非 Sendable 类型的实例。</p><p><img src="https://i1.wp.com/swiftsenpai.com/wp-content/uploads/2021/10/sendable-data-races-non-sendable-share-error-1024x653.png?resize=1024%2C653&amp;ssl=1" alt="Compiler error when try to share nonSendable types from actors in Swift"></p><p>那么，本文提到的所有 Warning 都将变成 Error！</p><p>好了，关于 Sendable 就聊这么多！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p><code>Sendable</code> 本身是一个 Marker Protocol，用于编译期的合规检查；</p></li><li><p>所有值语义类型都自动遵守 <code>Sendable</code> 协议；</p></li><li><p>所有遵守 <code>Sendable</code> 协议的类型都可以跨 actor 传递；</p></li><li><p><code>@Sendable</code> 用于修饰方法、闭包；</p></li><li><p>对于会在并发环境下执行的闭包都应用 <code>@Sendable</code> 修饰。</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md" target="_blank" rel="noopener">swift-evolution/0296-async-await.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md" target="_blank" rel="noopener">swift-evolution/0302-concurrent-value-and-concurrent-closures.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md" target="_blank" rel="noopener">swift-evolution/0337-support-incremental-migration-to-concurrency-checking.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md#jobs" target="_blank" rel="noopener">swift-evolution/0304-structured-concurrency.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md" target="_blank" rel="noopener">swift-evolution/0306-actors.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md" target="_blank" rel="noopener">swift-evolution/0337-support-incremental-migration-to-concurrency-checking.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://www.andyibanez.com/posts/understanding-async-await-in-swift/" target="_blank" rel="noopener">Understanding async/await in Swift • Andy Ibanez</a></p><p><a href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html#" target="_blank" rel="noopener">Concurrency — The Swift Programming Language (Swift 5.6)</a></p><p><a href="https://www.swiftbysundell.com/articles/connecting-async-await-with-other-swift-code/" target="_blank" rel="noopener">Connecting async/await to other Swift code | Swift by Sundell</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 『 Swift 新并发框架 』系列文章的第三篇，主要介绍 Swift 5.6 引入的 Sendable。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://zxfcumtcs.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 新并发框架之 actor</title>
    <link href="http://zxfcumtcs.github.io/2022/03/19/SwiftModernConcurrency-actor/"/>
    <id>http://zxfcumtcs.github.io/2022/03/19/SwiftModernConcurrency-actor/</id>
    <published>2022-03-19T00:48:09.000Z</published>
    <updated>2022-03-19T08:20:31.059Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 『 Swift 新并发框架 』系列文章的第二篇，主要介绍 Swift 5.5 引入的 actor。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><p>本系列文章对 Swift 新并发框架中涉及的内容逐个进行介绍，内容如下：</p><ul><li><p>Swift 新并发框架之 async/await</p></li><li><p>Swift 新并发框架之 actor</p></li><li><p>Swift 新并发框架之 Sendable</p></li><li><p>Swift 新并发框架之 Task</p></li></ul><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>Swift 新并发模型不仅要解决我们在『 <a href="">Swift 新并发框架之 async/await</a> 』一文中提到的异步编程问题，它还致力于解决并发编程中最让人头疼的 Data races 问题。</p><p>为此，Swift 引入了 <a href="https://en.wikipedia.org/wiki/Actor_model" target="_blank" rel="noopener">Actor model</a> ：</p><ul><li><p>Actor 代表一组在并发环境下可以安全访问的(可变)状态；</p></li><li><p>Actor 通过所谓数据隔离 (<strong>Actor isolation</strong>) 的方式确保数据安全，其实现原理是 Actor 内部维护了一个串行队列 (mailbox)，所有涉及数据安全的外部调用都要入队，即它们都是串行执行的。</p></li></ul><p><img src="/img/actor.png" alt=""></p><p>为此，Swift 引入了 <code>actor</code> 关键字，用于声明 Actor 类型，如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">BankAccount</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> accountNumber: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> balance: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">BankAccountError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> insufficientBalance(<span class="type">Double</span>)</span><br><span class="line">    <span class="keyword">case</span> authorizeFailed</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(accountNumber: <span class="type">Int</span>, initialDeposit: <span class="type">Double</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.accountNumber = accountNumber</span><br><span class="line">    <span class="keyword">self</span>.balance = initialDeposit</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(amount: Double)</span></span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(amount &gt;= <span class="number">0</span>)</span><br><span class="line">    balance = balance + amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了不支持继承，<code>actor</code> 与 <code>class</code> 非常类似：</p><ul><li><p>引用类型；</p></li><li><p>可以遵守指定的协议；</p></li><li><p>支持 extension 等。</p></li></ul><p>当然了，它们最大的区别在于 actor 内部实现了数据访问的同步机制，如上图所示。</p><h1 id="Actor-isolation"><a href="#Actor-isolation" class="headerlink" title="Actor isolation"></a>Actor isolation</h1><hr><p>所谓 Actor isolation 就是以 actor 实例为单元 (边界)，将其内部与外界隔离开。</p><p>严格限制跨界访问。</p><p>跨越 Actor isolation 的访问称之为 <em>cross-actor reference</em>，如下图所示：<br><img src="/img/Actorisolation.png" alt=""></p><p>cross-actor reference 有 2 种情况：</p><ul><li><p>引用 actor 中的 <strong>『 不可变状态 (immutable state) 』</strong>，如上面例子中的<code>accountNumber</code>，由于其初始化后就不会被修改，也就不存在 Data races，故即使是跨界访问也不会有问题；</p></li><li><p>引用 actor 中的 <strong>『 可变状态 (mutable state)、调用其方法、访问计算属性 』</strong> 等都被认为有潜在的 Data races，故不能像普通访问那样。</p><p>如前所述，Actor 内部有一个<code>mailbox</code>，专门用于接收此类访问，并依次串行执行它们，从而确保在并发下的数据安全。</p><p>从这里我们也可以看出，此类访问具有『 异步 』特征，即不会立即返回结果，需要排队依次执行。</p><p>因此，需要通过 <code>await</code>执行此类访问，如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bankAccount = <span class="type">BankAccount</span>.<span class="keyword">init</span>(accountNumber: <span class="number">123456789</span>, initialDeposit: <span class="number">1_000</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">depoist</span><span class="params">()</span></span> async &#123;</span><br><span class="line">    <span class="comment">// 下面的 bankAccount.accountNumber、bankAccount.deposit(amount: 1) 都属于cross-actor reference</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 let accountNumber 可以像普通属性那样访问</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">print</span>(bankAccount.accountNumber)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 而对于方法，无论是否是异步方法都需通过 await 调用</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    await bankAccount.deposit(amount: <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   当然，更不可能 cross-actor 直接修改 actor state：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">depoist</span><span class="params">()</span></span> async &#123;    </span><br><span class="line">  <span class="comment">// ❌ Error: Actor-isolated property 'balance' can not be mutated from a non-isolated context</span></span><br><span class="line">  bankAccount.balance += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="nonisolated"><a href="#nonisolated" class="headerlink" title="nonisolated"></a>nonisolated</h1><hr><p>Actor 内部通过 mailbox 机制实现同步访问，必然会有一定的性能损耗。</p><p>然而，actor 内部的方法、计算属性并不一定都会引起 Data races。</p><p>为了解决这一矛盾，Swift 引入了关键字 <code>nonisolated</code> 用于修饰那些不会引起 Data races 的方法、属性，如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在该方法内部只引用了 let accountNumber，故不存在 Data races</span></span><br><span class="line">  <span class="comment">// 也就可以用 nonisolated 修饰</span></span><br><span class="line">  nonisolated <span class="function"><span class="keyword">func</span> <span class="title">safeAccountNumberDisplayString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> digits = <span class="type">String</span>(accountNumber)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(repeating: <span class="string">"X"</span>, <span class="built_in">count</span>: digits.<span class="built_in">count</span> - <span class="number">4</span>) + <span class="type">String</span>(digits.suffix(<span class="number">4</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以像普通方法一样调用，无需 await 入队</span></span><br><span class="line">bankAccount.safeAccountNumberDisplayString()</span><br></pre></td></tr></table></figure><p>当然了，在<code>nonisolated</code>方法中是不能访问 isolated state 的，如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  nonisolated <span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(amount: Double)</span></span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(amount &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// Error: Actor-isolated property 'balance' can not be mutated from a non-isolated context</span></span><br><span class="line">    balance = balance + amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 actor 内部，无论是否是 nonisolated，各方法、属性都可以直接访问，如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在 deposit 方法中可以直接访问、修改 balance</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(amount: Double)</span></span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(amount &gt;= <span class="number">0</span>)</span><br><span class="line">    balance = balance + amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但需要注意的是，正如前面所述，Actor isolation 是以 actor 实例为边界，如下是有问题的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">transfer</span><span class="params">(amount: Double, to other: BankAccount)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> amount &gt; balance &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">BankAccountError</span>.insufficientBalance(balance)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Transferring \(amount) from \(accountNumber) to \(other.accountNumber)"</span>)</span><br><span class="line"></span><br><span class="line">    balance = balance - amount</span><br><span class="line">    <span class="comment">// Actor-isolated property 'balance' can not be mutated on a non-isolated actor instance</span></span><br><span class="line">    <span class="comment">// Actor-isolated property 'balance' can not be referenced on a non-isolated actor instance</span></span><br><span class="line">    other.balance = other.balance + amount  <span class="comment">// error: actor-isolated property 'balance' can only be referenced on 'self'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>other</code>相对于<code>self</code>来说属于另一个 actor 实例，故不能直接跨界访问。</p><h1 id="Actor-reentrancy"><a href="#Actor-reentrancy" class="headerlink" title="Actor reentrancy"></a>Actor reentrancy</h1><hr><p>为了避免死锁、提升性能，Actor-isolated 方法是可重入的：</p><ul><li><p>Actor-isolated 方法在显式声明为异步方法时，其内部可能存在暂停点；</p></li><li><p>当 Actor-isolated 方法因暂停点而被挂起时，该方法是可以重入的，也就是在前一个挂起被恢复前可以再次进入该方法；</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">authorize</span><span class="params">()</span></span> async -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// Simulate the authentication process</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">try</span>? await <span class="type">Task</span>.sleep(nanoseconds: <span class="number">1_000_000_000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">withdraw</span><span class="params">(amount: Double)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> balance &gt;= amount <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">BankAccountError</span>.insufficientBalance(balance)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// suspension point</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">guard</span> await authorize() <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">BankAccountError</span>.authorizeFailed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    balance -= amount</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bankAccount = <span class="type">BankAccount</span>.<span class="keyword">init</span>(</span><br><span class="line">    accountNumber: <span class="number">123456789</span>, </span><br><span class="line">    initialDeposit: <span class="number">1000</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">withdraw</span><span class="params">()</span></span> async &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">2</span> &#123;</span><br><span class="line">      <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> amount = <span class="number">600.0</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> balance = <span class="keyword">try</span> await bankAccount.withdraw(amount: amount)</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">"Withdrawal succeeded, balance = \(balance)"</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">BankAccount</span>.<span class="type">BankAccountError</span> &#123;</span><br><span class="line">          <span class="keyword">switch</span> error &#123;</span><br><span class="line">          <span class="keyword">case</span> .insufficientBalance(<span class="keyword">let</span> balance):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Insufficient balance, balance = \(balance), withdrawal amount = \(amount)!"</span>)</span><br><span class="line">          <span class="keyword">case</span> .authorizeFailed:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Authorize failed!"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Withdrawal succeeded, balance = 400.0</span><br><span class="line">Withdrawal succeeded, balance = -200.0</span><br></pre></td></tr></table></figure><p>上述结果显然是不对的。</p><p>一般的，check—reference/change 二步操作不应跨 await suspension point。</p><p>因此，fix 也很简单，在真正 reference/change 前再 check 一次：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withdraw</span><span class="params">(amount: Double)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> balance &gt;= amount <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">BankAccountError</span>.insufficientBalance(balance)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// suspension point</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">guard</span> await authorize() <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">BankAccountError</span>.authorizeFailed</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// re-check</span></span><br><span class="line">  <span class="keyword">guard</span> balance &gt;= amount <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">BankAccountError</span>.insufficientBalance(balance)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  balance -= amount</span><br><span class="line">  <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Withdrawal succeeded, balance = 400.0</span><br><span class="line">Insufficient balance, balance = 400.0, withdrawal amount = 600.0!</span><br></pre></td></tr></table></figure><p>总之，在开发过程中要注意 Actor reentrancy 的问题。</p><h1 id="globalActor-MainActor"><a href="#globalActor-MainActor" class="headerlink" title="globalActor/MainActor"></a>globalActor/MainActor</h1><hr><p>如前文所述，actor 是以其实例为界进行数据保护的。</p><p>但，如下，若需要对全局变量 <code>globalVar</code>、静态属性 <code>currentTimeStampe</code>、以及跨类型 (<code>ClassA1</code>、<code>ClassA2</code>)/跨实例进行数据保护该如何做？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVar: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">actor <span class="type">BankAccount</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> currentTimeStampe: <span class="type">Int64</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a1 = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">testA1</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a2 = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> a1: <span class="type">ClassA1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    a1 = <span class="type">ClassA1</span>.<span class="keyword">init</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">testA2</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这正是 <code>globalActor</code> 要解决的问题。</p><blockquote><p><code>currentTimeStampe</code> 虽定义在 actor <code>BankAccount</code> 中，但由于是 <code>static</code> 属性，故不在 actor 的保护范围内。<br>也就是不属于 <code>BankAccount</code> 的 actor-isolated 范围。</p><p>因此，可以在任意地方通过 <code>BankAccount.currentTimeStampe</code> 访问、修改其值。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@globalActor</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyGlobalActor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> actor <span class="type">MyActor</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">MyActor</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，定义了一个 global actor：<code>MyGlobalActor</code> ，几个关键点：</p><ul><li><p>global actor 的定义需要使用 <code>@globalActor</code>修饰；</p></li><li><p><code>@globalActor</code> 需要实现 <code>GlobalActor</code> 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@available</span>(macOS <span class="number">10.15</span>, iOS <span class="number">13.0</span>, watchOS <span class="number">6.0</span>, tvOS <span class="number">13.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">GlobalActor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The type of the shared actor instance that will be used to provide</span></span><br><span class="line">    <span class="comment">/// mutually-exclusive access to declarations annotated with the given global</span></span><br><span class="line">    <span class="comment">/// actor type.</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">ActorType</span> : <span class="type">Actor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The shared actor instance that will be used to provide mutually-exclusive</span></span><br><span class="line">    <span class="comment">/// access to declarations annotated with the given global actor type.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// The value of this property must always evaluate to the same actor</span></span><br><span class="line">    <span class="comment">/// instance.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> shared: <span class="type">Self</span>.<span class="type">ActorType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The shared executor instance that will be used to provide</span></span><br><span class="line">    <span class="comment">/// mutually-exclusive access for the global actor.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// The value of this property must be equivalent to `shared.unownedExecutor`.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> sharedUnownedExecutor: <span class="type">UnownedSerialExecutor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>GlobalActor</code> 协议中，一般我们只需实现 <code>shared</code> 属性即可 (<code>sharedUnownedExecutor</code> 在 <code>GlobalActor</code> extension 中有默认实现)；</p></li><li><p>global actor (本例中的<code>MyGlobalActor</code>) 本质上是一个 marker type，其同步功能是借助 <code>shared</code> 属性提供的 actor 实例完成的；</p></li><li><p>global actor 可用于修饰类型定义 (如：class、struct、enum，但不能用于 actor)、方法、属性、Closure等。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在闭包中的用法如下：</span></span><br><span class="line"><span class="type">Task</span> &#123; @<span class="type">MyGlobalActor</span> <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">MyGlobalActor</span> <span class="keyword">var</span> globalVar: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">actor <span class="type">BankAccount</span> &#123;</span><br><span class="line">  @<span class="type">MyGlobalActor</span> <span class="keyword">static</span> <span class="keyword">var</span> currentTimeStampe: <span class="type">Int64</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="type">MyGlobalActor</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a1 = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">testA1</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="type">MyGlobalActor</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a2 = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> a1: <span class="type">ClassA1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    a1 = <span class="type">ClassA1</span>.<span class="keyword">init</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">testA2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// globalVar、ClassA1/ClassA2 的实例、BankAccount.currentTimeStampe</span></span><br><span class="line">    <span class="comment">// 它们同属于 MyGlobalActor 的保护范围内</span></span><br><span class="line">    <span class="comment">// 故它们间的关系属 actor 内部关系，它们间可以正常访问</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    globalVar += <span class="number">1</span></span><br><span class="line">    a1.testA1()</span><br><span class="line">    <span class="type">BankAccount</span>.currentTimeStampe += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">await globalVar</span><br><span class="line">await <span class="type">BankAccount</span>.currentTimeStampe</span><br></pre></td></tr></table></figure><p><img src="/img/globalactor.png" alt=""><br>如上，可以通过 <code>@MyGlobalActor</code> 对它们进行数据保护，并在它们间形成一个以<code>MyGlobalActor</code> 为界的 actor-isolated：</p><ul><li><p>在 <code>MyGlobalActor</code> 内部可以对它们进行正常访问，如 <code>ClassA2.testA2</code> 方法所做；</p></li><li><p>在 <code>MyGlobalActor</code> 以外，需通过同步方式访问，如：<code>await globalVar</code>。</p></li></ul><p>UI 操作都需要在主线程上执行，因此有了 MainAcotr，几个关键点：</p><ul><li><p>MainActor 属于 globalAcotr 的特例；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@globalActor <span class="keyword">final</span> <span class="keyword">public</span> actor <span class="type">MainActor</span> : <span class="type">GlobalActor</span></span><br></pre></td></tr></table></figure></li><li><p>被 MainActor 修饰的方法、属性等都将在主线程上执行。</p></li></ul><blockquote><p>还记得在『 <a href="">Swift 新并发框架之 async/await</a> 』一文中提到的异步方法在暂停点前后可能会切换到不同线程上运行吗？</p><p>被 MainActor 修饰的方法是个例外，它一定是在主线程上执行。</p></blockquote><p>除了用 <code>@MainActor</code> 属性外，我们也可以通过 <code>MainActor.run</code> 在主线程上执行一段代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainActor</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// Execute the given body closure on the main actor.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;T&gt;<span class="params">(resultType: T.<span class="keyword">Type</span> = T.<span class="keyword">self</span>, body: @MainActor @Sendable <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) async <span class="keyword">rethrows</span> -&gt; <span class="type">T</span> <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Sendable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">await <span class="type">MainActor</span>.run &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="谨防内部幺蛾子"><a href="#谨防内部幺蛾子" class="headerlink" title="谨防内部幺蛾子"></a>谨防内部幺蛾子</h1><hr><p>至此，我们知道 actor 是通过 mailbox 机制串行执行外部调用来保障数据安全。</p><p>言外之意就是如果在 actor 方法内部存在 Data races，它是无能为力的，如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">BankAccount</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> balances: [<span class="type">Int</span>: <span class="type">Double</span>] = [<span class="number">1</span>: <span class="number">0.0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(amount: Double)</span></span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(amount &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</span><br><span class="line">      <span class="comment">// 在 actor 方法内部手动开启子线程</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="type">Thread</span>.detachNewThread &#123;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="keyword">self</span>.balances[<span class="number">1</span>] ?? <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">self</span>.balances[<span class="number">1</span>] = b + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"i = \(i), balance = \(self.balances[1])"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bankAccount = <span class="type">BankAccount</span>.<span class="keyword">init</span>(accountNumber: <span class="number">123</span>, initialDeposit: <span class="number">1000</span>, name: <span class="string">"Jike"</span>, age: <span class="number">18</span>)</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">depoist</span><span class="params">()</span></span> async &#123;</span><br><span class="line">    await bankAccount.deposit(amount: <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面这段代码(故意捏造的)，由于<code>BankAccount.deposit</code> 内部手动开启了子线程 (第 9 ~ 13 行)，故存在 Data races 问题，会 crash。</p><p><strong>一般地，actor 主要用作 Data Model，不应在其中处理大量业务逻辑。</strong></p><p><strong>尽量避免在其中手动开启子线程、使用GCD等，否则需要使用传统手法 (如 lock) 解决因此引起的多线程问题。</strong></p><h1 id="规避外部陷阱"><a href="#规避外部陷阱" class="headerlink" title="规避外部陷阱"></a>规避外部陷阱</h1><hr><p>说完内忧，再看外患！</p><p>正如前文所讲，Actor 通过 mailbox 机制解决了外部调用引起的多线程问题。</p><p>但是…，对于外部调用就可以高枕无忧了吗？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">actor <span class="type">BankAccount</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> accountNumber: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> balance: <span class="type">Double</span></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">user</span><span class="params">()</span></span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">User</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bankAccount = <span class="type">BankAccount</span>.<span class="keyword">init</span>(accountNumber: <span class="number">123</span>, initialDeposit: <span class="number">1000</span>, name: <span class="string">"Jike"</span>, age: <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">user</span><span class="params">()</span></span> async -&gt; <span class="type">User</span> &#123;</span><br><span class="line">    <span class="comment">// Wraning: Non-sendable type 'User' returned by implicitly asynchronous call to actor-isolated instance method 'user()' cannot cross actor boundary</span></span><br><span class="line">    <span class="keyword">return</span> await bankAccount.user()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面这段代码在编译时编译器给的 Warning：</p><p><em>Non-sendable type ‘User’ returned by implicitly asynchronous call to actor-isolated instance method ‘user()’ cannot cross actor boundary</em>.</p><blockquote><p>所有与 Sendable 相关的 warning 都需要 Xcode 13.3 才会报。</p></blockquote><p>先抛开什么是 Sendable 不谈</p><p>这个 warning 还是很好理解的：</p><ul><li><p>User 是引用类型(class)；</p></li><li><p>通过 actor-isolated 方法将 User 实例传递到了 actor 外面；</p></li><li><p>此后，被传递出来的 user 实例自然得不到 actor 的保护，在并发环境下显然就不安全了。</p></li></ul><p>通过参数跨 actor 边界传递类实例也是同样的问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">actor</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">updateUser</span><span class="params">(<span class="number">_</span> user: User)</span></span> &#123;</span><br><span class="line">    name = user.name</span><br><span class="line">    age = user.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AccountManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">updateUser</span><span class="params">()</span></span> async &#123;</span><br><span class="line">    <span class="comment">// Wraning: Non-sendable type 'User' passed in implicitly asynchronous call to actor-isolated instance method 'updateUser' cannot cross actor boundary</span></span><br><span class="line">    await bankAccount.updateUser(<span class="type">User</span>.<span class="keyword">init</span>(name: <span class="string">"Bob"</span>, age: <span class="number">18</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然了，跨 actor 传递函数、闭包也是不行的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">addAge</span><span class="params">(amount: Int, completion: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    age += amount</span><br><span class="line">    completion(age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AccountManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">addAge</span><span class="params">()</span></span> async &#123;</span><br><span class="line">    <span class="comment">// Wraning: Non-sendable type '(Int) -&gt; Void' passed in implicitly asynchronous call to actor-isolated instance method 'addAge(amount:completion:)' cannot cross actor boundary</span></span><br><span class="line">    await bankAccount.addAge(amount: <span class="number">1</span>, completion: &#123; age <span class="keyword">in</span></span><br><span class="line">      <span class="built_in">print</span>(age)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了这些 warning，还有货真价实的 crash：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">testUser</span><span class="params">(callback: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</span><br><span class="line">      <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        callback()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="type">User</span>.<span class="keyword">init</span>(name: <span class="string">"Tom"</span>, age: <span class="number">18</span>)</span><br><span class="line">    user.testUser &#123;</span><br><span class="line">      <span class="keyword">let</span> b = <span class="keyword">self</span>.balances[<span class="number">1</span>] ?? <span class="number">0.0</span></span><br><span class="line">      <span class="keyword">self</span>.balances[<span class="number">1</span>] = b + <span class="number">1</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"i = \(0), \(Thread.current), balance = \(String(describing: self.balances[1]))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，虽然 <code>BankAccount</code> 是 <code>actor</code> 类型，且其内部没有开启子线程等『 非法操作 』，</p><p>但在调用 <code>User.testUser(callback: @escaping () -&gt; Void)</code> 后会 crash。</p><p>怎么办？</p><p>这时就要轮到 Sendable 登场了：<a href="">『 Swift 新并发框架之 Sendable 』</a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>actor 是一种新的引用类型，旨在解决 Data Races；</p></li><li><p>actor 内部通过 mailbox 机制实现所有外部调用的串行执行；</p></li><li><p>对于明确不存在 Data Races 的方法、属性可以使用<code>nonisolated</code>修饰使之成为『 常规 』方法，以提升性能；</p></li><li><p>通过 <code>@globalActor</code> 可以定义全局 actor，用于对全局变量、静态变量、多实例等进行保护；</p></li><li><p>actor 内部尽量避免开启子线程以免引起多线程问题；</p></li><li><p>actor 应作 Data Model 用，不宜在其中处理过多业务逻辑。</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md" target="_blank" rel="noopener">swift-evolution/0296-async-await.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md" target="_blank" rel="noopener">swift-evolution/0302-concurrent-value-and-concurrent-closures.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md" target="_blank" rel="noopener">swift-evolution/0337-support-incremental-migration-to-concurrency-checking.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md#jobs" target="_blank" rel="noopener">swift-evolution/0304-structured-concurrency.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md" target="_blank" rel="noopener">swift-evolution/0306-actors.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md" target="_blank" rel="noopener">swift-evolution/0337-support-incremental-migration-to-concurrency-checking.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://www.andyibanez.com/posts/understanding-async-await-in-swift/" target="_blank" rel="noopener">Understanding async/await in Swift • Andy Ibanez</a></p><p><a href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html#" target="_blank" rel="noopener">Concurrency — The Swift Programming Language (Swift 5.6)</a></p><p><a href="https://www.swiftbysundell.com/articles/connecting-async-await-with-other-swift-code/" target="_blank" rel="noopener">Connecting async/await to other Swift code | Swift by Sundell</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 『 Swift 新并发框架 』系列文章的第二篇，主要介绍 Swift 5.5 引入的 actor。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://zxfcumtcs.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 新并发框架之 async/await</title>
    <link href="http://zxfcumtcs.github.io/2022/03/18/SwiftModernConcurrency-asyncawait/"/>
    <id>http://zxfcumtcs.github.io/2022/03/18/SwiftModernConcurrency-asyncawait/</id>
    <published>2022-03-18T14:00:56.000Z</published>
    <updated>2022-03-19T07:53:15.534Z</updated>
    
    <content type="html"><![CDATA[<p>即使对于经验丰富的开发者来说，写出健壮性、可维护性高的并发代码也是一项具有挑战性的任务，其挑战主要体现在两个方面：</p><ul><li><p>传统并发模型是基于异步模式，代码维护性不够友好；</p></li><li><p>并发往往意味着 Data Races，这是一类难复现、难排查的常见问题。</p></li></ul><p>Swift 在 5.5 开始引入的新并发框架主要着力解决这 2 个问题。</p><p>本文是 『 Swift 新并发框架 』系列文章的第一篇，主要介绍 Swift 5.5 引入的 async/await。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><p>本系列文章对 Swift 新并发框架中涉及的内容逐个进行介绍，内容如下：</p><ul><li><p>Swift 新并发框架之 async/await</p></li><li><p>Swift 新并发框架之 actor</p></li><li><p>Swift 新并发框架之 Sendable</p></li><li><p>Swift 新并发框架之 Task</p></li></ul><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>在正式开始前，简单回顾一下同步/异步、串行/并行的概念：</p><ul><li><p>同步(Synchronous)、异步(Asynchronous) 通常指方法(/函数)，同步方法表示直到任务完成才返回，异步方法则是将任务抛出去，在任务完成前就返回；</p><p>这也就意味着需要通过某种方式获得异步任务的结果，如：Delegate、Closure 等。</p></li><li><p>串行(Serial)、并行(Concurrent) 通常指 App 执行一组任务的模式，串行表示一次只能执行一个任务，只有当前任务完成后才启动下一个任务，而并行指可以同时执行多个任务。最常见的莫过于 GCD 中的串行、并行队列；</p><p> ps. 在此我们不严格区分并发、并行的区别。</p></li><li><p>传统的并发模型都是基于异步模式的，即异步获取并发任务的结果。</p></li></ul><p>同步代码是线性的 (straight-line)，非常适合人脑处理。</p><p>而异步代码是非线性的、跳跃式的 (类似于 <code>goto</code> 语句)，对于单核的人脑来说是一大挑战。</p><p>除了在阅读上对人脑思维模式构成较大挑战外，异步代码在具体实现上常伴有以下问题：</p><ul><li><p>回调地狱 (Callback Hell)；</p></li><li><p>错误处理 (Error Handling)；</p></li><li><p>容易出错。</p></li></ul><h1 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h1><hr><p>我们先通过一个简单的例子对比一下传统并发模型与新的并发模型间的区别。</p><p>该例子通过 token 获取头像，其步骤有：</p><ul><li><p>通过 token 获取头像 URL；</p></li><li><p>通过 URL 下载头像数据(加密)；</p></li><li><p>对头像数据解密；</p></li><li><p>图片解码。</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvatarLoader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">loadAvatar</span><span class="params">(token: String, completion: <span class="params">(Image)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    fetchAvatarURL(token: token) &#123; url <span class="keyword">in</span></span><br><span class="line">      fetchAvatar(url: url) &#123; data <span class="keyword">in</span></span><br><span class="line">        decryptAvatar(data: data) &#123; data <span class="keyword">in</span></span><br><span class="line">          decodeImage(data: data) &#123; image <span class="keyword">in</span></span><br><span class="line">            completion(image)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">fetchAvatarURL</span><span class="params">(token: String, completion: <span class="params">(String)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// fetch url from net...</span></span><br><span class="line">    completion(avatarURL)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">fetchAvatar</span><span class="params">(url: String, completion: <span class="params">(Data)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// download avatar data...</span></span><br><span class="line">    completion(avatarData)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">decryptAvatar</span><span class="params">(data: Data, completion: <span class="params">(Data)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// decrypt...</span></span><br><span class="line">    completion(decryptedData)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">decodeImage</span><span class="params">(data: Data, completion: <span class="params">(Image)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// decode...</span></span><br><span class="line">    completion(avatar)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadAvatar</code> 方法中回调层级之深不言而喻。</p><p>上述代码还遗漏了一个重要问题：错误处理，其中的网络请求、解密、解码都有可能出错。</p><blockquote><p>优雅地处理错误是一项非常考验基本功的任务。</p></blockquote><p>一般地，错误处理分为 2 种情况：</p><ul><li><p>同步方法：优先考虑通过 <code>throw</code> 抛出<code>error</code>，这样调用方就不得不处理错误，因此带有一定的强制性；</p></li><li><p>异步方法：在回调中传递 error，这种情况下调用方通常会有意无意地忽略错误，使健壮性大打折扣。</p></li></ul><p>为了处理错误，对上述代码进行升级：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvatarLoader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">loadAvatar</span><span class="params">(token: String, completion: <span class="params">(Image?, Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    fetchAvatarURL(token: token) &#123; url, error  <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> url = url <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在这个路径，经常容易漏掉执行 completion 或者 return 语句</span></span><br><span class="line">        completion(<span class="literal">nil</span>, error)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      fetchAvatar(url: url) &#123; data, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">          completion(<span class="literal">nil</span>, error)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        decryptAvatar(data: data) &#123; data, error <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">            completion(<span class="literal">nil</span>, error)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          decodeImage(data: data) &#123; image, error <span class="keyword">in</span></span><br><span class="line">            completion(image, error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">fetchAvatarURL</span><span class="params">(token: String, completion: <span class="params">(String?, Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// fetch url from net...</span></span><br><span class="line">    completion(avatarURL, error)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">fetchAvatar</span><span class="params">(url: String, completion: <span class="params">(Data?, Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// download avatar data...</span></span><br><span class="line">    completion(avatarData, error)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">decryptAvatar</span><span class="params">(data: Data, completion: <span class="params">(Data?, Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// decrypt...</span></span><br><span class="line">    completion(decryptedData, error)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">decodeImage</span><span class="params">(data: Data, completion: <span class="params">(Image?, Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// decode...</span></span><br><span class="line">    completion(avatar, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，为了处理错误，在 <code>completion</code> 中增加了 <code>error</code> 参数，同时需要将 2 个参数都定义成 <code>Optional</code>。</p><p>同时，在 <code>loadAvatar</code> 中添加了大量的 <code>guard</code>，这样的代码无疑非常丑陋。</p><blockquote><p>Optional 无形中增加了代码成本。</p></blockquote><p>为此，Swift 5 引入了 <code>Result</code> 用于优化上述错误处理场景：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvatarLoader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">loadAvatar</span><span class="params">(token: String, completion: <span class="params">(Result&lt;Image, Error&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    fetchAvatarURL(token: token) &#123; result <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">switch</span> result &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">let</span> .success(url):</span><br><span class="line">        fetchAvatar(url: url) &#123; result <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">switch</span> result &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="keyword">let</span> .success(decryptData):</span><br><span class="line">            decryptAvatar(data: decryptData) &#123; result <span class="keyword">in</span></span><br><span class="line">              <span class="keyword">switch</span> result &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="keyword">let</span> .success(avaratData):</span><br><span class="line">                decodeImage(data: avaratData) &#123; result <span class="keyword">in</span></span><br><span class="line">                  completion(result)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">case</span> <span class="keyword">let</span> .failure(error):</span><br><span class="line">                completion(.failure(error))</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">case</span> <span class="keyword">let</span> .failure(error):</span><br><span class="line">            completion(.failure(error))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">let</span> .failure(error):</span><br><span class="line">        completion(.failure(error))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">fetchAvatarURL</span><span class="params">(token: String, completion: <span class="params">(Result&lt;String, Error&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// fetch url from net...</span></span><br><span class="line">    completion(.success(avatarURL))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">fetchAvatar</span><span class="params">(url: String, completion: <span class="params">(Result&lt;Data, Error&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// download avatar data...</span></span><br><span class="line">    completion(.success(avatarData))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">decryptAvatar</span><span class="params">(data: Data, completion: <span class="params">(Result&lt;Data, Error&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// decrypt...</span></span><br><span class="line">    completion(.success(decryptData))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">decodeImage</span><span class="params">(data: Data, completion: <span class="params">(Result&lt;Image, Error&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// decode...</span></span><br><span class="line">    completion(.success(avatar))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Result 是 enum 类型，含有 <code>success</code>、<code>failure</code> 2 个 case。</p></blockquote><p>可以看到，通过使用 <code>Result</code>，参数不必是 <code>Optional</code>，另外可以通过 <code>switch/case</code> 来处理结果，在一定程度保证了调用方对错误的处理。</p><blockquote><p>在上面这个 Callback Hell 中，直观上， Result 不但没有使代码简洁，反而更加复杂了。</p><p>主要是没有把代码抽离开来，不要对 Result 有什么误解^__^。</p></blockquote><p>通过这个简单的例子，可以看到基于 Callback 的异步模型问题不少。</p><p>因此，将异步代码同步化一直是业界努力的方向。</p><p>如：<a href="https://www.promisejs.org/" target="_blank" rel="noopener">Promise</a>，不过其同步也是建立在 callback 基础上的。</p><p>Swift 5.5 引入了 <code>async/await</code> 用于将异步代码同步化。</p><blockquote><p>很多语言都已支持 <code>async/await</code>，如： JavaScript、Dart 等</p></blockquote><p>先直观感受一下 <code>async/await</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvatarLoader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">loadAvatar</span><span class="params">(token: String)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="keyword">try</span> await fetchAvatarURL(token: token)</span><br><span class="line">    <span class="keyword">let</span> encryptedData = <span class="keyword">try</span> await fetchAvatar(url: url)</span><br><span class="line">    <span class="keyword">let</span> decryptedData = <span class="keyword">try</span> await decryptAvatar(data: encryptedData)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> await decodeImage(data: decryptedData)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">fetchAvatarURL</span><span class="params">(token: String)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="comment">// fetch url from net...</span></span><br><span class="line">    <span class="keyword">return</span> avatarURL</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">fetchAvatar</span><span class="params">(url: String)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">    <span class="comment">// download avatar data...</span></span><br><span class="line">    <span class="keyword">return</span> avatarData</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">decryptAvatar</span><span class="params">(data: Data)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">    <span class="comment">// decrypt...</span></span><br><span class="line">    <span class="keyword">return</span> decryptData</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">decodeImage</span><span class="params">(data: Data)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="comment">// decode...</span></span><br><span class="line">    <span class="keyword">return</span> avatar</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比基于 Callback 的异步版本，基于 <code>async/await</code> 的版本是不是清晰多了。</p><p>尤其是 <code>loadAvatar</code> 方法从感观上就是一个同步方法，阅读起来无比顺畅。</p><p>其错误处理也使用了同步式的 throws。</p><p>至此，通过对比，对 <code>async/await</code> 有了一个较直观的认识，下面简单探讨一下其实现机制。</p><h1 id="深究"><a href="#深究" class="headerlink" title="深究"></a>深究</h1><hr><p>首先，还是有必要对 <code>async/await</code> 作一个正式的介绍：</p><ul><li><p><code>async</code> — 用于修饰方法，被修饰的方法则被称为异步方法 (<em>asynchronous method</em>)，异步方法意味着其在执行过程中可能会被暂停 (挂起)；</p></li><li><p><code>await</code> — 对 <em>asynchronous method</em> 的调用需加上 <code>await</code>。同时，<code>await</code>只能出现在异步上下文中 (<em>asynchronous context</em>)；</p><p><code>await</code> 则表示一个潜在暂停点 (<em>potential suspension points</em>)。</p></li></ul><p>什么是 <em>asynchronous context</em> ？其存在于 2 种环境下：</p><ul><li><p>asynchronous method body — 异步方法体属于异步上下文的范畴；</p></li><li><p>Task closure — Task 任务闭包也属于 asynchronous context。</p><blockquote><p>Task 是在 Swift 5.5 中引入的，主要用于创建、执行异步任务，后续文章会介绍。</p></blockquote></li></ul><p>因此，<strong>只能在异步方法或 Task 闭包中通过 <code>await</code> 调用异步方法。</strong></p><p>异步方法执行过程中可能会暂停？</p><p>potential suspension points？</p><p>怎么暂停？</p><p>刚开始接触 <code>async/await</code> 时，下意识地可能会有这些疑问。</p><p>2 个关键点：</p><ul><li><p>暂停的是方法，而不是执行方法的线程；</p></li><li><p>暂停点前后可能会发生线程切换。</p></li></ul><p>在 Swift 新并发模型中进一步弱化了『 线程 』，理想情况下整个 App 的线程数应与内核数一致，线程的创建、管理完全交由并发框架负责。</p><p>Swift 对异步方法 (asynchronous method) 的处理就遵守了上述思想：</p><ul><li><p>异步方法被暂停点 (suspension points) 分割为若干个 <code>Job</code>；</p></li><li><p>在并发框架中 <code>Job</code> 是任务调度的基本单元；</p></li><li><p>并发框架根据实时情况动态决定某个 <code>Job</code> 的执行线程；</p></li><li><p>也就是同一个异步方法中的不同 <code>Job</code> 可能运行在不同线程上。</p></li></ul><p>正是由于异步方法在其暂停点前后可能会变换执行线程，因此在异步方法中要慎用锁、信号量等同步操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lock = <span class="type">NSLock</span>.<span class="keyword">init</span>()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> async &#123;</span><br><span class="line">  lock.lock()</span><br><span class="line">  <span class="keyword">try</span>? await <span class="type">Task</span>.sleep(nanoseconds: <span class="number">1_000_000_000</span>)</span><br><span class="line">  lock.unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">  <span class="type">Task</span> &#123;</span><br><span class="line">    await test()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这样的代码在 <code>lock.lock()</code> 处会产生死锁，换成信号量也是一样。</p><blockquote><p>await 之所以称为『 潜在 』暂停点，而不是暂停点，是因为并不是所有的 await 都会暂停，只有遇到类似 IO、手动起子线程等情况时才会暂停当前调用栈的运行。</p></blockquote><p>总之，对于异步方法如何切分 <code>Job</code> 等细节可以不关心，<strong>但 <code>await</code> 可能会暂停当前方法的运行，并在时机成熟后在其他线程恢复运行是我们需要明确了解的</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md" target="_blank" rel="noopener">swift-evolution/0296-async-await.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md" target="_blank" rel="noopener">swift-evolution/0302-concurrent-value-and-concurrent-closures.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md" target="_blank" rel="noopener">swift-evolution/0337-support-incremental-migration-to-concurrency-checking.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md#jobs" target="_blank" rel="noopener">swift-evolution/0304-structured-concurrency.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md" target="_blank" rel="noopener">swift-evolution/0306-actors.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md" target="_blank" rel="noopener">swift-evolution/0337-support-incremental-migration-to-concurrency-checking.md at main · apple/swift-evolution · GitHub</a></p><p><a href="https://www.andyibanez.com/posts/understanding-async-await-in-swift/" target="_blank" rel="noopener">Understanding async/await in Swift • Andy Ibanez</a></p><p><a href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html#" target="_blank" rel="noopener">Concurrency — The Swift Programming Language (Swift 5.6)</a></p><p><a href="https://www.swiftbysundell.com/articles/connecting-async-await-with-other-swift-code/" target="_blank" rel="noopener">Connecting async/await to other Swift code | Swift by Sundell</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;即使对于经验丰富的开发者来说，写出健壮性、可维护性高的并发代码也是一项具有挑战性的任务，其挑战主要体现在两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;传统并发模型是基于异步模式，代码维护性不够友好；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并发往往意味着 Data Races，这是一类难复现、难排查的常见问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Swift 在 5.5 开始引入的新并发框架主要着力解决这 2 个问题。&lt;/p&gt;
&lt;p&gt;本文是 『 Swift 新并发框架 』系列文章的第一篇，主要介绍 Swift 5.5 引入的 async/await。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://zxfcumtcs.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift Protocol 背后的故事(下)</title>
    <link href="http://zxfcumtcs.github.io/2022/02/04/SwiftProtocol2/"/>
    <id>http://zxfcumtcs.github.io/2022/02/04/SwiftProtocol2/</id>
    <published>2022-02-04T14:16:24.000Z</published>
    <updated>2022-02-07T06:38:24.525Z</updated>
    
    <content type="html"><![CDATA[<p>本文是下篇，主要讨论 Swift Protocol 实现机制。</p><p>内容涉及  Type Metadata、Protocol 内存模型 Existential Container、Generics 的实现原理以及泛型特化等。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><h1 id="Type-Metadata"><a href="#Type-Metadata" class="headerlink" title="Type Metadata"></a>Type Metadata</h1><hr><p>在 Objective-C 中，通过 MetaClass 模型来表达类的元信息，并通过实例的 <code>isa</code> 指针来引用 MetaClass。这是整个 Objective-C runtime 的核心机制。</p><p>那在 Swift 中类型信息 (Type Metadata) 是如何表达的呢？</p><p>Swift runtime 为每种类型 (Class、Struct、Enum、Protocol、Tuple、Function 等等) 生成了一份元信息记录 (Metadata Record)，几个关键点：</p><ul><li><p>对于常规类型 (nominal types，如：类、结构体、枚举)，其对应的 Metadata Record 在编译期由编译器静态生成；</p></li><li><p>对于内在类型 (intrinsic types) 以及泛型实例，对应的 Metadata Record 则在运行时动态生成，如：元组、函数、协议等；</p></li><li><p>每个类型的 Metadata Record 都是唯一的，相同类型的 Metadata Record 是同一个</p></li></ul><p>不同类型的 Metadata 所包含的信息也不一样 (Metadata Layout)，但它们有一个共同的头部，其包含：</p><ul><li><p>VWT (Value Witness Table) Poniter — 指向 VWT (虚函数表) 的指针，在 VWT 中包含了该类型的实例如何分配内存 (allocating)、copy (copying)、销毁 (destroying) 等基础操作 (函数指针)；</p><blockquote><p>在 VWT 中除了包含上述函数指针外，还有该类型实例的 size、alignment、stride 等基础信息。</p></blockquote></li><li><p>Kind — 标记 Metadata 的类型，如：0 – Class，1 – Struct，2 – Enum，12 – Protocol 等等。</p></li></ul><p><img src="/img/MetadataType.png" alt=""></p><p>与本文讨论相关的是 VWT，关于 Metadata 的更多信息请参考：<a href="https://github.com/apple/swift/blob/main/docs/ABI/TypeMetadata.rst#protocol-metadata" target="_blank" rel="noopener">swift/TypeMetadata.rst at main · apple/swift · GitHub</a>。</p><h1 id="Inside-Protocol"><a href="#Inside-Protocol" class="headerlink" title="Inside Protocol"></a>Inside Protocol</h1><hr><h2 id="Existential-Container"><a href="#Existential-Container" class="headerlink" title="Existential Container"></a>Existential Container</h2><p>Class、Struct 以及 Enum 对应的实例都有确定的『模型』用于指导其内存布局。</p><blockquote><p>『模型』就是 Class、Struct 以及 Enum 本身的定义，它们包含的成员。</p></blockquote><p>而 Protocol 并没有确定的『模型』，因为其背后的真实类型可能千奇百怪，那么 Protocol 类型的变量按什么进行内存布局？</p><p>Swift 用了一种称之为 <strong>Existential Container</strong> 的模型来指导 Protocol 变量布局内存。</p><p>Existential Container 又分为两类：</p><ul><li><p><em>Opaque Existential Container</em> — 用于没有<strong>类</strong>约束的 Protocol (no class constraint on protocol)，也就是说这种协议背后的真实类型可能是类、结构体以及枚举等。因此其存储就非常复杂。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpaqueExistentialContainer</span> </span>&#123;</span><br><span class="line">  void *fixedSizeBuffer[<span class="number">3</span>];</span><br><span class="line">  <span class="type">Metadata</span> *type;</span><br><span class="line">  <span class="type">WitnessTable</span> *witnessTables[<span class="type">NUM_WITNESS_TABLES</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上，<code>OpaqueExistentialContainer</code> 包含3个成员：</p><ul><li><p><code>fixedSizeBuffer</code> — 3 个指针大小的 buffer 空间，当真实类型的 size (内存对齐后的大小) 小于 3 个字时则其内容直接存储在 fixedSizeBuffer 中，否则在 heap 上另辟空间存储，并将指针存储在 fixedSizeBuffer 中；</p></li><li><p><code>type</code> — 指向真实类型的 Metadata，最重要的就是引用其中的 VWT 用于完成内存的各种操作；</p></li><li><p><code>witnessTables</code> — 指向协议函数表 (Protocol Witness Table, PWT)，协议函数表中存储的是真实类型中对应函数的地址。</p></li></ul></li><li><p><em>Class Existential Container</em> — 用于有<strong>类</strong>约束的 Protocol，该协议背后真实的类型只能是类，而类的实例都是在 Heap 上分配内存的。</p><p>因此，在 Existential Container 中只需要一个指向堆内存的指针即可。</p><p>同时，由于类的实例含有指向其 Metadata 的指针，故在 Existential Container 中也就没必要再存一份 Metadata 的指针了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClassExistentialContainer</span> </span>&#123;</span><br><span class="line">  <span class="type">HeapObject</span> *value;</span><br><span class="line">  <span class="type">WitnessTable</span> *witnessTables[<span class="type">NUM_WITNESS_TABLES</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上，<code>ClassExistentialContainer</code> 只包含2个成员：</p><ul><li><p><code>value</code> — 指向堆内存的指针；</p></li><li><p><code>witnessTables</code> — PWT 指针。</p></li></ul></li></ul><p>下面我们来看一个例子：</p><p><img src="/img/ExistentialContainer.png" alt=""></p><p>如图，由于  <code>protocol Drawable</code> 没有 class constraint，故其对应的 Existential Container 是 <code>OpaqueExistentialContainer</code>：</p><ul><li><p>由于 <code>Point</code> 实例占用 2 个字的内存空间 (小于 3)，故对于 <code>Drawable</code> 协议类型的变量 <code>point</code> 直接使用 <code>OpaqueExistentialContainer#buffer</code> 来存储其内容(<code>x</code>、<code>y</code>)；</p></li><li><p>而 <code>Line</code> 的实例要占用 4 个字的内存空间，故 <code>line</code> 需要在 heap 上分配内存用于存储其内容(<code>x0</code>、<code>y0</code>、<code>x1</code>、<code>y1</code>)；</p></li><li><p>Existential Container 中的 <code>type</code> 分别指向了其背后真实类型的 Metadata；</p></li><li><p>PWT 中的函数指针则指向真实类型中的函数。</p></li></ul><p>对应编译器生成的(伪)代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point: <span class="type">Drawable</span> = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">point.draw()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器生成的(伪)代码</span></span><br><span class="line"><span class="keyword">let</span> _point: <span class="type">Point</span> = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> point: <span class="type">OpaqueExistentialContainer</span> = <span class="type">OpaqueExistentialContainer</span>()</span><br><span class="line"><span class="keyword">let</span> metadata = _point.type</span><br><span class="line"><span class="keyword">let</span> vwt = metadata.vwt</span><br><span class="line">vwt.copy(&amp;(point.fixedSizeBuffer), _point)</span><br><span class="line">point.type = metadata</span><br><span class="line">point.witnessTables = <span class="type">PWT</span>(<span class="type">Point</span>.draw)</span><br><span class="line">point.pwt.draw()</span><br><span class="line">vwt.dealloc(point)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> line: <span class="type">Drawable</span> = <span class="type">Line</span>(x0: <span class="number">0</span>, y0: <span class="number">0</span>, x1: <span class="number">1</span>, y1: <span class="number">1</span>)</span><br><span class="line">line.draw()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器生成的(伪)代码</span></span><br><span class="line"><span class="keyword">let</span> _line: <span class="type">Line</span> = <span class="type">Line</span>(x0: <span class="number">0</span>, y0: <span class="number">0</span>, x1: <span class="number">1</span>, y1: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> line：<span class="type">OpaqueExistentialContainer</span> = <span class="type">OpaqueExistentialContainer</span>()</span><br><span class="line"><span class="keyword">let</span> metadata = _line.type</span><br><span class="line"><span class="keyword">let</span> vwt = metadata.vwt</span><br><span class="line">line.fixedSizeBuffer[<span class="number">0</span>] = vwt.allocate()</span><br><span class="line">vwt.copy(line.fixedSizeBuffer, _line)</span><br><span class="line">line.type = metadata</span><br><span class="line">line.witnessTables = <span class="type">PWT</span>(<span class="type">Line</span>.draw)</span><br><span class="line">line.pwt.draw()</span><br><span class="line">vwt.dealloc(line)</span><br></pre></td></tr></table></figure><p>关于更多 Type Layout 的信息请参考: <a href="https://github.com/apple/swift/blob/main/docs/ABI/TypeLayout.rst" target="_blank" rel="noopener">swift/TypeLayout.rst at main · apple/swift · GitHub</a></p><p>从上面的伪代码可以看到对于协议类型的变量，编译器在背后做了大量的工作。也有一定的性能损耗。</p><h2 id="Protocol-Type-Stored-Properties"><a href="#Protocol-Type-Stored-Properties" class="headerlink" title="Protocol Type Stored Properties"></a>Protocol Type Stored Properties</h2><p>从上一小节可知，协议类型的变量其实质类型是 Existential Container (<code>OpaqueExistentialContainer</code> / <code>ClassExistentialContainer</code>)。</p><p>因此，当协议类型变量作为存储属性时，其在寄主实例中的内存占用就是一个 Existential Container 实例 (下图来自: <a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="noopener">Understanding Swift Performance · WWDC2016</a>)：</p><p><img src="/img/ProtocolTypeStoredProperties.png" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Protocol 不同于一般类型 (Class、Struct、Enum)，具有以下特点：</p><ul><li><p>使用 Existential Container (<code>OpaqueExistentialContainer</code> / <code>ClassExistentialContainer</code>) 作为内存模型；</p></li><li><p>内存占用 &lt;= 3 的实例，直接存储在 Existential Container buffer 中，否则在 heap 上另行分配内存，并将指针存储在 Existential Container buffer[0] 中；</p></li><li><p>内存管理 (allocating、copying、destroying) 相关的方法保存在 VWT 中；</p></li><li><p>通过 PWT 实现方法动态派发 (Dynamic dispatch)。</p></li></ul><h1 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h1><hr><p>泛型作为提升代码灵活性、可复用性的重要手段被大多数语言所支持，如：Swift、Java、C++ (模板)。</p><p>Swift 结合 Protocol 赋以泛型更多的灵活性。</p><p>下面我们简单探讨一下泛型在 Swift 中是如何实现的。</p><p>Swift 中泛型可以添加类型约束 (Type Constraints)，约束可以是类，也可以是协议。</p><p>因此，Swift 泛型根据类型约束可以分为 3 类：</p><ul><li><p>No Constraints</p></li><li><p>Class Constraints</p></li><li><p>Protocol Constraints</p></li></ul><p>下面，分别对这 3 类情况进行简要分析。</p><blockquote><p>通过 SIL (<a href="https://github.com/apple/swift/blob/main/docs/SIL.rst" target="_blank" rel="noopener">swift/SIL.rst at main · apple/swift · GitHub</a>) 可以大致了解 Swift 背后的实现原理。</p><p><code>swiftc demo.swift -O -emit-sil -o demo-sil.s</code> </p><p>如上，通过 swiftc 命令可以生成 SIL。</p><p>其中的 <code>-O</code> 是对生成的 SIL 代码进行编译优化，使 SIL 更简洁高效。</p><p>后面要讲到的泛型特化 (Specialization of Generics) 也只有在 <code>-O</code> 优化下会发生。</p></blockquote><h2 id="No-Constraints"><a href="#No-Constraints" class="headerlink" title="No Constraints"></a>No Constraints</h2><p>其实，这类泛型能执行的操作非常少。无法在 heap 上实例化 (创建) 对象，也不能执行任何方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@inline(never)  <span class="comment">// 禁止编译器做 inline 优化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;T&gt;<span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> T, <span class="number">_</span> b: <span class="keyword">inout</span> T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，<code>swapTwoValues</code> 用于交换 2 个变量的值，其泛型参数 <code>T</code> 没有任何约束。</p><p>其对应的 SIL 如下，关键点：</p><ul><li><p>第<code>8</code>行，通过 <code>alloc_stack</code> 在栈上为类型 <code>T</code> 分配内存 (<code>temp</code>);</p></li><li><p>第<code>9</code>行，通过 <code>copy_addr</code> 进行内存级拷贝 (不会执行任何 <code>init</code> 方法)；</p></li><li><p>第<code>12</code>行，通过 <code>dealloc_stack</code> 销毁上述开辟的内存；</p></li><li><p>其他就是做一些内存拷贝的操作。</p></li></ul><blockquote><p>需要注意的是，对于引用类型，<code>$T</code>是指针，即在栈上开辟的是存储指针的内存，而非引用类型本身。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="comment">// swapTwoValues&lt;A&gt;(_:_:)</span></span><br><span class="line"><span class="number">2</span>   sil hidden [noinline] @$s4main13swapTwoValuesyyxz_xztlF : $<span class="meta">@convention</span>(thin) &lt;<span class="type">T</span>&gt; (@<span class="keyword">inout</span> <span class="type">T</span>, @<span class="keyword">inout</span> <span class="type">T</span>) -&gt; () &#123;</span><br><span class="line"><span class="number">3</span>   <span class="comment">// %0 "a"                                         // users: %5, %6, %2</span></span><br><span class="line"><span class="number">4</span>   <span class="comment">// %1 "b"                                         // users: %7, %6, %3</span></span><br><span class="line"><span class="number">5</span>   bb0(%<span class="number">0</span> : $*<span class="type">T</span>, %<span class="number">1</span> : $*<span class="type">T</span>):</span><br><span class="line"><span class="number">6</span>    debug_value_addr %<span class="number">0</span> : $*<span class="type">T</span>, <span class="keyword">var</span>, name <span class="string">"a"</span>, argno <span class="number">1</span> <span class="comment">// id: %2</span></span><br><span class="line"><span class="number">7</span>    debug_value_addr %<span class="number">1</span> : $*<span class="type">T</span>, <span class="keyword">var</span>, name <span class="string">"b"</span>, argno <span class="number">2</span> <span class="comment">// id: %3</span></span><br><span class="line"><span class="number">8</span>    %<span class="number">4</span> = alloc_stack $<span class="type">T</span>, <span class="keyword">let</span>, name <span class="string">"temp"</span>           <span class="comment">// users: %8, %7, %5</span></span><br><span class="line"><span class="number">9</span>    copy_addr %<span class="number">0</span> to [initialization] %<span class="number">4</span> : $*<span class="type">T</span>       <span class="comment">// id: %5</span></span><br><span class="line"><span class="number">10</span>   copy_addr [take] %<span class="number">1</span> to %<span class="number">0</span> : $*<span class="type">T</span>                 <span class="comment">// id: %6</span></span><br><span class="line"><span class="number">11</span>   copy_addr [take] %<span class="number">4</span> to [initialization] %<span class="number">1</span> : $*<span class="type">T</span> <span class="comment">// id: %7</span></span><br><span class="line"><span class="number">12</span>   dealloc_stack %<span class="number">4</span> : $*<span class="type">T</span>                          <span class="comment">// id: %8</span></span><br><span class="line"><span class="number">13</span>   %<span class="number">9</span> = tuple ()                                   <span class="comment">// user: %10</span></span><br><span class="line"><span class="number">14</span>   <span class="keyword">return</span> %<span class="number">9</span> : $()                                 <span class="comment">// id: %10</span></span><br><span class="line"><span class="number">15</span> &#125; <span class="comment">// end sil function '$s4main13swapTwoValuesyyxz_xztlF'</span></span><br></pre></td></tr></table></figure><h2 id="Class-Constraints"><a href="#Class-Constraints" class="headerlink" title="Class Constraints"></a>Class Constraints</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span></span><br><span class="line">  <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span></span><br><span class="line">  <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@inline(never)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">drawShape</span>&lt;T: Shape&gt;<span class="params">(<span class="number">_</span> s: T)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> s0 = <span class="type">T</span>()</span><br><span class="line">  s0.draw()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如例：</p><ul><li><p>将泛型类型 upcast 到约束类型 (第 <code>5~6</code>行)；</p></li><li><p>通过 <code>class_method</code> 指令找到要执行的方法 (<code>init</code>、<code>draw</code> 方法 [第 <code>7~10</code> 行]，在 vtable 中找)；</p></li><li><p>可以在 Heap 上创建泛型类型的实例 (第 <code>8</code> 行)；</p></li><li><p>其实质就是通过虚函数表实现的多态。</p></li></ul><p>总之，由于有基础类作为类型约束，通过虚函数表就可以执行所有基础类公开的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="comment">// drawShape&lt;A&gt;(_:)</span></span><br><span class="line"><span class="number">2</span>  sil hidden [noinline] @$s4main9drawShapeyyxAA0C0CRbzlF : $<span class="meta">@convention</span>(thin) &lt;<span class="type">T</span> <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Shape</span>&gt; (@guaranteed <span class="type">T</span>) -&gt; () &#123;</span><br><span class="line"><span class="number">3</span>  <span class="comment">// %0 "s"</span></span><br><span class="line"><span class="number">4</span>  bb0(%<span class="number">0</span> : $<span class="type">T</span>):</span><br><span class="line"><span class="number">5</span>    %<span class="number">1</span> = metatype $@thick <span class="type">T</span>.<span class="type">Type</span>                    <span class="comment">// user: %2</span></span><br><span class="line"><span class="number">6</span>    %<span class="number">2</span> = upcast %<span class="number">1</span> : $@thick <span class="type">T</span>.<span class="type">Type</span> to $@thick <span class="type">Shape</span>.<span class="type">Type</span> <span class="comment">// users: %4, %3</span></span><br><span class="line"><span class="number">7</span>    %<span class="number">3</span> = class_method %<span class="number">2</span> : $@thick <span class="type">Shape</span>.<span class="type">Type</span>, #<span class="type">Shape</span>.<span class="keyword">init</span>!allocator : (<span class="type">Shape</span>.<span class="type">Type</span>) -&gt; () -&gt; <span class="type">Shape</span>, $<span class="meta">@convention</span>(method) (@thick <span class="type">Shape</span>.<span class="type">Type</span>) -&gt; @owned <span class="type">Shape</span> <span class="comment">// user: %4</span></span><br><span class="line"><span class="number">8</span>    %<span class="number">4</span> = apply %<span class="number">3</span>(%<span class="number">2</span>) : $<span class="meta">@convention</span>(method) (@thick <span class="type">Shape</span>.<span class="type">Type</span>) -&gt; @owned <span class="type">Shape</span> <span class="comment">// users: %7, %5, %6</span></span><br><span class="line"><span class="number">9</span>    %<span class="number">5</span> = class_method %<span class="number">4</span> : $<span class="type">Shape</span>, #<span class="type">Shape</span>.draw : (<span class="type">Shape</span>) -&gt; () -&gt; <span class="type">Bool</span>, $<span class="meta">@convention</span>(method) (@guaranteed <span class="type">Shape</span>) -&gt; <span class="type">Bool</span> <span class="comment">// user: %6</span></span><br><span class="line"><span class="number">10</span>   %<span class="number">6</span> = apply %<span class="number">5</span>(%<span class="number">4</span>) : $<span class="meta">@convention</span>(method) (@guaranteed <span class="type">Shape</span>) -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="number">11</span>   strong_release %<span class="number">4</span> : $<span class="type">Shape</span>                      <span class="comment">// id: %7</span></span><br><span class="line"><span class="number">12</span>   %<span class="number">8</span> = tuple ()                                   <span class="comment">// user: %9</span></span><br><span class="line"><span class="number">13</span>   <span class="keyword">return</span> %<span class="number">8</span> : $()                                 <span class="comment">// id: %9</span></span><br><span class="line"><span class="number">14</span> &#125; <span class="comment">// end sil function '$s4main9drawShapeyyxAA0C0CRbzlF'</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> sil_vtable <span class="type">Shape</span> &#123;</span><br><span class="line"><span class="number">17</span>   #<span class="type">Shape</span>.<span class="keyword">init</span>!allocator: (<span class="type">Shape</span>.<span class="type">Type</span>) -&gt; () -&gt; <span class="type">Shape</span> : @$s4main5ShapeCACycfC    <span class="comment">// Shape.__allocating_init()</span></span><br><span class="line"><span class="number">18</span>   #<span class="type">Shape</span>.draw: (<span class="type">Shape</span>) -&gt; () -&gt; <span class="type">Bool</span> : @$s4main5ShapeC4drawSbyF    <span class="comment">// Shape.draw()</span></span><br><span class="line"><span class="number">19</span>   #<span class="type">Shape</span>.<span class="keyword">deinit</span>!deallocator: @$s4main5ShapeCfD    <span class="comment">// Shape.__deallocating_deinit</span></span><br><span class="line"><span class="number">20</span> &#125;</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> sil_vtable <span class="type">Triangle</span> &#123;</span><br><span class="line"><span class="number">23</span>   #<span class="type">Shape</span>.<span class="keyword">init</span>!allocator: (<span class="type">Shape</span>.<span class="type">Type</span>) -&gt; () -&gt; <span class="type">Shape</span> : @$s4main8TriangleCACycfC [<span class="keyword">override</span>]    <span class="comment">// Triangle.__allocating_init()</span></span><br><span class="line"><span class="number">24</span>   #<span class="type">Shape</span>.draw: (<span class="type">Shape</span>) -&gt; () -&gt; <span class="type">Bool</span> : @$s4main8TriangleC4drawSbyF [<span class="keyword">override</span>]    <span class="comment">// Triangle.draw()</span></span><br><span class="line"><span class="number">25</span>   #<span class="type">Triangle</span>.<span class="keyword">deinit</span>!deallocator: @$s4main8TriangleCfD    <span class="comment">// Triangle.__deallocating_deinit</span></span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="Protocol-Constraints"><a href="#Protocol-Constraints" class="headerlink" title="Protocol Constraints"></a>Protocol Constraints</h2><blockquote><p>这里讨论的 Protocol 是没有 class constraint 的，对于只能由类实现的协议作为泛型约束时，其效果同上节讨论的 Class Constraints。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@inline(never)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">equal</span>&lt;T: Equatable&gt;<span class="params">(<span class="number">_</span> a: T, <span class="number">_</span> b: T)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> a0 = a</span><br><span class="line">  <span class="keyword">let</span> b0 = b</span><br><span class="line">  <span class="keyword">return</span> a0 == b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从下列 SIL 可以看到：</p><ul><li><p>通过 <code>alloc_stack</code> 可以为泛型类型在 Stack 上分配内存 (无论泛型类型是值类型还是引用类型)；</p></li><li><p>同样通过 <code>copy_addr</code> 执行内存拷贝；</p></li><li><p>通过 <code>witness_method</code> 指令在泛型类型上查找 Protocol 指定的方法 (查 PWT 表)。</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equal&lt;A&gt;(_:_:)</span></span><br><span class="line">sil hidden [noinline] @$s4main5equalySbx_xtSQRzlF : $<span class="meta">@convention</span>(thin) &lt;<span class="type">T</span> <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Equatable</span>&gt; (@in_guaranteed <span class="type">T</span>, @in_guaranteed <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="comment">// %0 "a"                                         // users: %5, %2</span></span><br><span class="line"><span class="comment">// %1 "b"                                         // users: %8, %3</span></span><br><span class="line">bb0(%<span class="number">0</span> : $*<span class="type">T</span>, %<span class="number">1</span> : $*<span class="type">T</span>):</span><br><span class="line">  debug_value_addr %<span class="number">0</span> : $*<span class="type">T</span>, <span class="keyword">let</span>, name <span class="string">"a"</span>, argno <span class="number">1</span> <span class="comment">// id: %2</span></span><br><span class="line">  debug_value_addr %<span class="number">1</span> : $*<span class="type">T</span>, <span class="keyword">let</span>, name <span class="string">"b"</span>, argno <span class="number">2</span> <span class="comment">// id: %3</span></span><br><span class="line">  %<span class="number">4</span> = alloc_stack $<span class="type">T</span>, <span class="keyword">let</span>, name <span class="string">"a0"</span>             <span class="comment">// users: %9, %10, %8, %5</span></span><br><span class="line">  copy_addr %<span class="number">0</span> to [initialization] %<span class="number">4</span> : $*<span class="type">T</span>       <span class="comment">// id: %5</span></span><br><span class="line">  %<span class="number">6</span> = metatype $@thick <span class="type">T</span>.<span class="type">Type</span>                    <span class="comment">// user: %8</span></span><br><span class="line">  %<span class="number">7</span> = witness_method $<span class="type">T</span>, #<span class="type">Equatable</span>.<span class="string">"=="</span> : &lt;<span class="type">Self</span> <span class="keyword">where</span> <span class="type">Self</span> : <span class="type">Equatable</span>&gt; (<span class="type">Self</span>.<span class="type">Type</span>) -&gt; (<span class="type">Self</span>, <span class="type">Self</span>) -&gt; <span class="type">Bool</span> : $<span class="meta">@convention</span>(witness_method: <span class="type">Equatable</span>) &lt;τ<span class="number">_0_0</span> <span class="keyword">where</span> τ<span class="number">_0_0</span> : <span class="type">Equatable</span>&gt; (@in_guaranteed τ<span class="number">_0_0</span>, @in_guaranteed τ<span class="number">_0_0</span>, @thick τ<span class="number">_0_0</span>.<span class="type">Type</span>) -&gt; <span class="type">Bool</span> <span class="comment">// user: %8</span></span><br><span class="line">  %<span class="number">8</span> = apply %<span class="number">7</span>&lt;<span class="type">T</span>&gt;(%<span class="number">4</span>, %<span class="number">1</span>, %<span class="number">6</span>) : $<span class="meta">@convention</span>(witness_method: <span class="type">Equatable</span>) &lt;τ<span class="number">_0_0</span> <span class="keyword">where</span> τ<span class="number">_0_0</span> : <span class="type">Equatable</span>&gt; (@in_guaranteed τ<span class="number">_0_0</span>, @in_guaranteed τ<span class="number">_0_0</span>, @thick τ<span class="number">_0_0</span>.<span class="type">Type</span>) -&gt; <span class="type">Bool</span> <span class="comment">// user: %11</span></span><br><span class="line">  destroy_addr %<span class="number">4</span> : $*<span class="type">T</span>                           <span class="comment">// id: %9</span></span><br><span class="line">  dealloc_stack %<span class="number">4</span> : $*<span class="type">T</span>                          <span class="comment">// id: %10</span></span><br><span class="line">  <span class="keyword">return</span> %<span class="number">8</span> : $<span class="type">Bool</span>                               <span class="comment">// id: %11</span></span><br><span class="line">&#125; <span class="comment">// end sil function '$s4main5equalySbx_xtSQRzlF'</span></span><br></pre></td></tr></table></figure><p>再看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>()</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@inline(never)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">drawShape</span>&lt;T: Drawable&gt;<span class="params">(<span class="number">_</span> s: T)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> s0 = <span class="type">T</span>()</span><br><span class="line">  s0.draw()</span><br><span class="line">  <span class="keyword">return</span> s0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从下列 SIL 可以看出：</p><ul><li>可以在 Heap 上创建泛型类型实例 (无论是值类型还是引用类型)；</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drawShape&lt;A&gt;(_:)</span></span><br><span class="line">sil hidden [noinline] @$s4main9drawShapeyxxAA8DrawableRzlF : $<span class="meta">@convention</span>(thin) &lt;<span class="type">T</span> <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Drawable</span>&gt; (@in_guaranteed <span class="type">T</span>) -&gt; @out <span class="type">T</span> &#123;</span><br><span class="line"><span class="comment">// %0 "$return_value"                             // users: %4, %6</span></span><br><span class="line"><span class="comment">// %1 "s"</span></span><br><span class="line">bb0(%<span class="number">0</span> : $*<span class="type">T</span>, %<span class="number">1</span> : $*<span class="type">T</span>):</span><br><span class="line">  %<span class="number">2</span> = metatype $@thick <span class="type">T</span>.<span class="type">Type</span>                    <span class="comment">// user: %4</span></span><br><span class="line">  %<span class="number">3</span> = witness_method $<span class="type">T</span>, #<span class="type">Drawable</span>.<span class="keyword">init</span>!allocator : &lt;<span class="type">Self</span> <span class="keyword">where</span> <span class="type">Self</span> : <span class="type">Drawable</span>&gt; (<span class="type">Self</span>.<span class="type">Type</span>) -&gt; () -&gt; <span class="type">Self</span> : $<span class="meta">@convention</span>(witness_method: <span class="type">Drawable</span>) &lt;τ<span class="number">_0_0</span> <span class="keyword">where</span> τ<span class="number">_0_0</span> : <span class="type">Drawable</span>&gt; (@thick τ<span class="number">_0_0</span>.<span class="type">Type</span>) -&gt; @out τ<span class="number">_0_0</span> <span class="comment">// user: %4</span></span><br><span class="line">  %<span class="number">4</span> = apply %<span class="number">3</span>&lt;<span class="type">T</span>&gt;(%<span class="number">0</span>, %<span class="number">2</span>) : $<span class="meta">@convention</span>(witness_method: <span class="type">Drawable</span>) &lt;τ<span class="number">_0_0</span> <span class="keyword">where</span> τ<span class="number">_0_0</span> : <span class="type">Drawable</span>&gt; (@thick τ<span class="number">_0_0</span>.<span class="type">Type</span>) -&gt; @out τ<span class="number">_0_0</span></span><br><span class="line">  %<span class="number">5</span> = witness_method $<span class="type">T</span>, #<span class="type">Drawable</span>.draw : &lt;<span class="type">Self</span> <span class="keyword">where</span> <span class="type">Self</span> : <span class="type">Drawable</span>&gt; (<span class="type">Self</span>) -&gt; () -&gt; <span class="type">Bool</span> : $<span class="meta">@convention</span>(witness_method: <span class="type">Drawable</span>) &lt;τ<span class="number">_0_0</span> <span class="keyword">where</span> τ<span class="number">_0_0</span> : <span class="type">Drawable</span>&gt; (@in_guaranteed τ<span class="number">_0_0</span>) -&gt; <span class="type">Bool</span> <span class="comment">// user: %6</span></span><br><span class="line">  %<span class="number">6</span> = apply %<span class="number">5</span>&lt;<span class="type">T</span>&gt;(%<span class="number">0</span>) : $<span class="meta">@convention</span>(witness_method: <span class="type">Drawable</span>) &lt;τ<span class="number">_0_0</span> <span class="keyword">where</span> τ<span class="number">_0_0</span> : <span class="type">Drawable</span>&gt; (@in_guaranteed τ<span class="number">_0_0</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">  %<span class="number">7</span> = tuple ()                                   <span class="comment">// user: %8</span></span><br><span class="line">  <span class="keyword">return</span> %<span class="number">7</span> : $()                                 <span class="comment">// id: %8</span></span><br><span class="line">&#125; <span class="comment">// end sil function '$s4main9drawShapeyxxAA8DrawableRzlF'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sil_witness_table hidden <span class="type">Shape</span>: <span class="type">Drawable</span> module main &#123;</span><br><span class="line">  method #<span class="type">Drawable</span>.<span class="keyword">init</span>!allocator: &lt;<span class="type">Self</span> <span class="keyword">where</span> <span class="type">Self</span> : <span class="type">Drawable</span>&gt; (<span class="type">Self</span>.<span class="type">Type</span>) -&gt; () -&gt; <span class="type">Self</span> : @$s4main5ShapeCAA8DrawableA2aDPxycfCTW    <span class="comment">// protocol witness for Drawable.init() in conformance Shape</span></span><br><span class="line">  method #<span class="type">Drawable</span>.draw: &lt;<span class="type">Self</span> <span class="keyword">where</span> <span class="type">Self</span> : <span class="type">Drawable</span>&gt; (<span class="type">Self</span>) -&gt; () -&gt; <span class="type">Bool</span> : @$s4main5ShapeCAA8DrawableA2aDP4drawSbyFTW    <span class="comment">// protocol witness for Drawable.draw() in conformance Shape</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面简单的分析可以看出 No Constraints、Class Constraints 以及 Protocol Constraints 的泛型类型在实现上的区别：</p><ul><li><p>No Constraints 泛型能做的事很少，不能执行任何方法，只能 Stack 上为泛型类型分配内存并执行内存拷贝；</p></li><li><p>Class Constraints 泛型可以在 Heap 上创建新实例，方法调用通过虚函数表 (vtable) 实现；</p></li><li><p>Protocol Constraints 泛型可以在 Stack 上也可以在 Heap 上按需创建泛型类型实例，无论泛型是值类型还是引用类型；</p></li><li><p>Protocol Constraints 泛型通过 PWT 实现方法调用；</p></li><li><p>也就是说泛型中的方法调用都是动态派发 (Dynamic dispatch)，通过 vtable 或者 PWT。</p></li></ul><h2 id="Specialization-of-Generics"><a href="#Specialization-of-Generics" class="headerlink" title="Specialization of Generics"></a>Specialization of Generics</h2><p>从上一小节可知，泛型方法调用都是动态派发 (通过 vtable 或 PWT)，有一定的性能损耗。</p><p>为了优化此类损耗，Swift 编译器会对泛型进行特化 (Specialization of Generics)。</p><p>所谓特化就是为具体类型生成相应版本的函数，从而将泛型转成非泛型，实现方法调用的静态派发。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@inline(never)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;T&gt;<span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> T, <span class="number">_</span> b: <span class="keyword">inout</span> T)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = a</span><br><span class="line">  a = b</span><br><span class="line">  b = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">swapTwoValues(&amp;a, &amp;b)</span><br></pre></td></tr></table></figure><p>如例，通过 <code>Int</code> 型参数调用 <code>swapTwoValues</code> 时，编译器就会生成该方法的 <code>Int</code> 版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// specialized swapTwoValues&lt;A&gt;(_:_:)</span></span><br><span class="line">sil shared [noinline] @$s4main13swapTwoValuesyyxz_xztlFSi_Tg5 : $<span class="meta">@convention</span>(thin) (@<span class="keyword">inout</span> <span class="type">Int</span>, @<span class="keyword">inout</span> <span class="type">Int</span>) -&gt; () &#123;</span><br><span class="line"><span class="comment">// %0 "a"                                         // users: %6, %4, %2</span></span><br><span class="line"><span class="comment">// %1 "b"                                         // users: %7, %5, %3</span></span><br><span class="line">bb0(%<span class="number">0</span> : $*<span class="type">Int</span>, %<span class="number">1</span> : $*<span class="type">Int</span>):</span><br><span class="line">  debug_value_addr %<span class="number">0</span> : $*<span class="type">Int</span>, <span class="keyword">var</span>, name <span class="string">"a"</span>, argno <span class="number">1</span> <span class="comment">// id: %2</span></span><br><span class="line">  debug_value_addr %<span class="number">1</span> : $*<span class="type">Int</span>, <span class="keyword">var</span>, name <span class="string">"b"</span>, argno <span class="number">2</span> <span class="comment">// id: %3</span></span><br><span class="line">  %<span class="number">4</span> = load %<span class="number">0</span> : $*<span class="type">Int</span>                            <span class="comment">// user: %7</span></span><br><span class="line">  %<span class="number">5</span> = load %<span class="number">1</span> : $*<span class="type">Int</span>                            <span class="comment">// user: %6</span></span><br><span class="line">  store %<span class="number">5</span> to %<span class="number">0</span> : $*<span class="type">Int</span>                          <span class="comment">// id: %6</span></span><br><span class="line">  store %<span class="number">4</span> to %<span class="number">1</span> : $*<span class="type">Int</span>                          <span class="comment">// id: %7</span></span><br><span class="line">  %<span class="number">8</span> = tuple ()                                   <span class="comment">// user: %9</span></span><br><span class="line">  <span class="keyword">return</span> %<span class="number">8</span> : $()                                 <span class="comment">// id: %9</span></span><br><span class="line">&#125; <span class="comment">// end sil function '$s4main13swapTwoValuesyyxz_xztlFSi_Tg5'</span></span><br></pre></td></tr></table></figure><p>那么，什么时候会进行泛型特化呢？</p><p>总的原则是在编译泛型方法时知道有哪些调用方，同时调用方的类型是可推演的。</p><p>最简单的情况就是泛型方法与调用方在同一个源文件里，一起进行编译。</p><p>另外在编译时若开启了 Whole-Module Optimization ，同一模块内部的泛型调用也可以被特化。</p><blockquote><p>关于全模块优化请参考<a href="https://www.swift.org/blog/whole-module-optimizations/" target="_blank" rel="noopener">Swift.org - Whole-Module Optimization in Swift 3</a>，在此不再赘述。</p></blockquote><h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><ul><li><p>Swift 为每种类型生成了一份 Metadata Record，其中包含了 VWT (Value Witness Table)；</p></li><li><p>Protocol 使用 Existential Container 作为其内存模型，所有 Protocol 类型的变量都是 Existential Container 的实例；</p></li><li><p>Protocol 通过 PWT 实现方法动态派发 (Dynamic dispatch)；</p></li><li><p>泛型调用在满足一定条件时会进行特化，以提升性能。</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md" target="_blank" rel="noopener">swift-evolution · Opaque Result Types</a></p><p><a href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html" target="_blank" rel="noopener">OpaqueTypes</a></p><p><a href="https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift/#closures-to-the-rescue" target="_blank" rel="noopener">Different flavors of type erasure in Swift</a></p><p><a href="https://www.raywenderlich.com/24942207-opaque-return-types-and-type-erasure" target="_blank" rel="noopener">Opaque Return Types and Type Erasure</a></p><p><a href="https://www.swiftbysundell.com/articles/phantom-types-in-swift/" target="_blank" rel="noopener">Phantom types in Swift</a></p><p><a href="https://www.hackingwithswift.com/plus/advanced-swift/how-to-use-phantom-types-in-swift" target="_blank" rel="noopener">How to use phantom types in Swift</a></p><p><a href="https://github.com/apple/swift/blob/main/docs/ABI/TypeMetadata.rst#protocol-metadata" target="_blank" rel="noopener">swift/TypeMetadata.rst at main · apple/swift · GitHub</a></p><p><a href="https://github.com/apple/swift/blob/main/docs/ABI/TypeLayout.rst" target="_blank" rel="noopener">swift/TypeLayout.rst at main · apple/swift · GitHub</a></p><p><a href="https://speakerdeck.com/kateinoigakukun/swift-type-metadata?slide=48" target="_blank" rel="noopener">Swift Type Metadata</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="noopener">Understanding Swift Performance · WWDC2016</a></p><p><a href="https://www.swift.org/blog/whole-module-optimizations/" target="_blank" rel="noopener">Swift.org - Whole-Module Optimization in Swift 3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是下篇，主要讨论 Swift Protocol 实现机制。&lt;/p&gt;
&lt;p&gt;内容涉及  Type Metadata、Protocol 内存模型 Existential Container、Generics 的实现原理以及泛型特化等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://zxfcumtcs.github.io/tags/Swift/"/>
    
      <category term="Protocol" scheme="http://zxfcumtcs.github.io/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>Swift Protocol 背后的故事(上)</title>
    <link href="http://zxfcumtcs.github.io/2022/02/01/SwiftProtocol1/"/>
    <id>http://zxfcumtcs.github.io/2022/02/01/SwiftProtocol1/</id>
    <published>2022-02-01T02:06:08.000Z</published>
    <updated>2022-02-07T06:32:43.255Z</updated>
    
    <content type="html"><![CDATA[<p>我们将从实践技巧、实现原理两个方面对 Swift Protocol 展开深入讨论。</p><p>本文作为上篇主要介绍实践技巧，以一个 Protocol 相关的编译错误为引，通过实例对 Type Erasure、Opaque Types 、Generics 以及 Phantom Types 做了较详细的讨论。它们对于写出更优、更雅的 Swift 代码有一定的帮助。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><h1 id="引"><a href="#引" class="headerlink" title="引"></a>引</h1><hr><p>Swift 推崇面向协议编程 (POP, Protocol Oriented Programming)，因此 Protocol 在 Swift 中就显得尤为重要。</p><p>但本文要讨论的既不是 Protocol 的使用，也不是 POP。</p><p>我们的讨论从一个编译错误开始：</p><blockquote><p>Protocol ‘Equatable’ can only be used as a generic constraint because it has Self or associated type requirements.</p></blockquote><p>对于 Swift 开发者来说上面这个编译错误应该不陌生。</p><p>其字面意思不难理解：含有 <code>Self</code> 或关联类型的协议只能用作泛型约束，不能单独作为类型使用。</p><p>Why？</p><p><em>因为 Swift 是类型安全的语言 (type-safe language)。</em></p><p>why？</p><p>上面这个解释是句『 正确的废话 』，没有说到点子上。</p><p>下面我们以一个 Demo 为基础展开今天的讨论 (<a href="https://github.com/zxfcumtcs/MarkdownDemo" target="_blank" rel="noopener">GitHub - zxfcumtcs/MarkdownDemo: Swift Protocol Demo</a>)：<br><img src="/img/MarkdownDemo.png" alt=""></p><p>如上图，MarkdownEditor 是一个 Markdown 格式的编辑器。</p><p>为了处理不同的 Markdown 格式，我们定义了协议 <code>MarkdownBuilder</code>， 其作为公开接口曝露给业务方：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MarkdownBuilder</span>: <span class="title">Equatable</span>, <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> style: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(from text: String)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于有判等需求，<code>MarkdownBuilder</code> 继承了 <code>Equatable</code> 协议。</p></blockquote><p>如果我们直接将 <code>MarkdownBuilder</code> 作为类型使用，如：<code>var builder: MarkdownBuilder</code> ，就会报上面的错误。</p><p>因为，Equatable 有 <strong>Self requirements</strong>：要求 <code>==</code> 操作符的两个参数 <code>lhs</code> 与 <code>rhs</code> 的类型必须相同 (注意是准确的类型，而不是说只要遵守 <code>Equatable</code> 即可)。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如，允许有 <code>Self requirements</code> / <code>Associated Type</code> 的 Protocol 作为类型使用，就会出现以下情况，而编译器却无能为力：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lhs: <span class="type">Equatable</span> = <span class="number">1</span>           <span class="comment">// Int</span></span><br><span class="line"><span class="keyword">let</span> rsh: <span class="type">Equatable</span> = <span class="string">"1"</span>         <span class="comment">// String</span></span><br><span class="line">lhs == rsh                       <span class="comment">// ?!, 不同类型的值可以判等</span></span><br></pre></td></tr></table></figure><p>对于 <code>Associated Type</code> 也是同样的道理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于校验电话号码是否合法</span></span><br><span class="line"><span class="comment">// 由于电话号码可以有多种表达格式</span></span><br><span class="line"><span class="comment">// 抽取了协议，并实现了Int、String两种格式</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PhoneNumberVerifier</span> </span>&#123;</span><br><span class="line">  <span class="keyword">associatedtype</span> <span class="type">Phone</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">verify</span><span class="params">(<span class="number">_</span> model: Phone)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntPhoneNumberVerifier</span>: <span class="title">PhoneNumberVerifier</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">verify</span><span class="params">(<span class="number">_</span> model: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// do some verify</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StrPhoneNumberVerifier</span>: <span class="title">PhoneNumberVerifier</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">verify</span><span class="params">(<span class="number">_</span> model: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// do some verify</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> verifiers: [<span class="type">PhoneNumberVerifier</span>] = [...]</span><br><span class="line">verifiers.forEach &#123; verifier <span class="keyword">in</span></span><br><span class="line">  verifier.verify(???) <span class="comment">// 这里的参数怎么传？Int? String? 编译器无法保证类型安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说这么多，归根结底是因为 Protocol 是运行时特性，而其附带的 <code>Self requirements</code> / <code>Associated Type</code> 却需要在编译时保证。其结果必定凉凉~</p><blockquote><p>Generics 是编译期特性，在编译时就能明确泛型的具体类型，故有 <code>Self requirements</code>/<code>Associated Type</code> 的 Protocol 只能作为其约束使用。</p></blockquote><h1 id="Type-Erasure"><a href="#Type-Erasure" class="headerlink" title="Type Erasure"></a>Type Erasure</h1><hr><p>回到上节提到的 Markdown 编辑器：MarkdownEditor，我们实现了4种格式的 MarkdownBuilder：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MarkdownBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> id: <span class="type">String</span> &#123; style &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 斜体</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">struct</span> <span class="title">ItalicsBuilder</span>: <span class="title">MarkdownBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> style: <span class="type">String</span> &#123; <span class="string">"*Italics*"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(from text: String)</span></span> -&gt; <span class="type">String</span> &#123; <span class="string">"*\(text)*"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 粗体</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">struct</span> <span class="title">BoldBuilder</span>: <span class="title">MarkdownBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> style: <span class="type">String</span> &#123; <span class="string">"**Bold**"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(from text: String)</span></span> -&gt; <span class="type">String</span> &#123; <span class="string">"**\(text)**"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除线</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">struct</span> <span class="title">StrikethroughBuilder</span>: <span class="title">MarkdownBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> style: <span class="type">String</span> &#123; <span class="string">"~Strikethrough~"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(from text: String)</span></span> -&gt; <span class="type">String</span> &#123; <span class="string">"~\(text)~"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超链接</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkBuilder</span>: <span class="title">MarkdownBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> style: <span class="type">String</span> &#123; <span class="string">"[Link](link)"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(from text: String)</span></span> -&gt; <span class="type">String</span> &#123; <span class="string">"[\(text)](https://github.com)"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>struct MarkdownView: View</code>是整个 Demo 的主界面，需要在其中存储所有支持的 Markdown Builder，以及当前选中的 Builder。</p><p>所以，我们不加思索地写下了以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MarkdownView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> allBuilders: [<span class="type">MarkdownBuilder</span>]</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> selectedBuilders: [<span class="type">MarkdownBuilder</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果可想而知！</p><p>怎么办？</p><p>Generics？ 在这里似乎行不通！</p><p>将所有支持的 Builder 逐个定义出来？</p><p>太蠢了！且不符合『 OCP 』原则。</p><p>此时，就需要用到本节的主角：Type Erasure (类型擦除)。</p><blockquote><p>Type Erasure 是一项通用技术，并非 Swift 特有，核心思想是在编译期擦除 (转换) 原有类型，使其对业务方不可见。</p><p>有多种方式可以实现 Type Erasure，如：Boxing、Closures 等。</p></blockquote><p>在 MarkdownEditor 中，我们通过 Boxing 实现 Type Erasure，简单讲就是对原有类型做一次封装 (Wrapper)：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AnyBuilder</span>: <span class="title">MarkdownBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">let</span> style: <span class="type">String</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> id: <span class="type">String</span> &#123; <span class="string">"AnyBuilder-\(style)"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> wrappedApply: (<span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">B</span>: <span class="type">MarkdownBuilder</span>&gt;(<span class="number">_</span> builder: <span class="type">B</span>) &#123;</span><br><span class="line">    style = builder.style</span><br><span class="line">    wrappedApply = builder.build(from:)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(from text: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    wrappedApply(text)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: AnyBuilder, rhs: AnyBuilder)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    lhs.id == rhs.id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个关键点：</p><ul><li><code>AnyBuilder</code> 实现了 <code>MarkdownBuilder</code>协议，(一般情况下 Wrapper 都需要实现待封装的协议)；</li><li>其 <code>init</code> 是泛型方法，并将参数传递过来的 <code>style</code>、<code>build(from:)</code> 存储下来；</li><li>在其自身的<code>build(from:)</code>方法中直接调用存储的 <code>wrappedApply</code>，其本身相当于一个转发代理。</li></ul><p>同时，扩展 <code>MarkdownBulider</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">MarkdownBuilder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">asAnyBuilder</span><span class="params">()</span></span> -&gt; <span class="type">AnyBuilder</span> &#123;</span><br><span class="line">    <span class="type">AnyBuilder</span>(<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们就可以愉快地在 <code>MarkdownView</code> 中使用 <code>AnyBuilder</code> 了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MarkdownView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> allBuilders: [<span class="type">AnyBuilder</span>]  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> selectedBuilders: [<span class="type">AnyBuilder</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于有上面的 <code>MarkdownBuilder</code> 扩展，可以通过 2 种方式生成 <code>AnyBuilder</code> 实例：</p><ul><li><code>BoldBuilder().asAnyBuilder()</code></li><li><code>AnyBuilder(BoldBuilder())</code></li></ul><blockquote><p>在 Swift 标准库中有大量通过 Boxing 实现的 Type Erasure ，如： <code>AnySequence</code>、<code>AnyHashable</code>、<code>AnyCancellable</code>等等。</p><p>以 Any 为前缀的几乎都是。</p></blockquote><h1 id="Opaque-Types"><a href="#Opaque-Types" class="headerlink" title="Opaque Types"></a>Opaque Types</h1><hr><p>如果，我们准备将 MarkdownEditor 做成一个独立的三方库，并且除了 <code>MarkdownBuilder</code> 协议，不打算曝露任何其他的实现细节以增加其灵活性。</p><p>即，<code>ItalicsBuilder</code>、<code>BoldBuilder</code>、<code>StrikethroughBuilder</code> 以及 <code>LinkBuilder</code> 都是库私有的。</p><p>如何做？</p><p>又一次不加思索地写下了以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">italicsBuilder</span><span class="params">()</span></span> -&gt; <span class="type">MarkdownBuilder</span> &#123;</span><br><span class="line">  <span class="type">ItalicsBuilder</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">boldBuilder</span><span class="params">()</span></span> -&gt; <span class="type">MarkdownBuilder</span> &#123;</span><br><span class="line">  <span class="type">BoldBuilder</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">strikethroughBuilder</span><span class="params">()</span></span> -&gt; <span class="type">MarkdownBuilder</span> &#123;</span><br><span class="line">  <span class="type">StrikethroughBuilder</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">linkBuilder</span><span class="params">()</span></span> -&gt; <span class="type">MarkdownBuilder</span> &#123;</span><br><span class="line">  <span class="type">LinkBuilder</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望通过 public func 为业务方创建相应的 Builder 实例，同时以接口的方式返回。</p><p>理想丰满，现实骨感！</p><p>同样的错误在等着你！</p><p>怎么办？</p><p>轮到本节主角 Opaque Types 登场了！</p><p>简单讲，Opaque Types 就是让函数/方法的返回值是协议，而不是具体的类型。</p><blockquote><p>A function or method with an opaque return type hides its return value’s type information.<br>Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports.</p></blockquote><p>几个关键点：</p><ul><li><p>关键字 <code>some</code>，需在返回协议类型前添加 <code>some</code> 关键词，如：<br><em><code>public func regularBuilder() -&gt; some MarkdownBuilder</code></em><br>而不是 <code>public func regularBuilder() -&gt; MarkdownBuilder</code></p></li><li><p>Opaque Types 与直接返回协议类型的最大区别是：</p><ul><li><p>Opaque Types 只是对使用方(人)隐藏了具体类型细节，编译器是知道具体类型的；</p></li><li><p>而直接返回协议类型，则是运行时行为，编译器是无法知道的；</p></li><li><p>如下代码，编译器是明确知道 <code>italicsBuilder</code> 方法的返回值类型是 <code>ItalicsBuilder</code>，但方法调用方却只知道返回值遵守了 <code>MarkdownBuilder</code> 协议。从而也就达到了隐藏实现细节的目的；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">italicsBuilder</span><span class="params">()</span></span> -&gt; some <span class="type">MarkdownBuilder</span> &#123;</span><br><span class="line">  <span class="type">ItalicsBuilder</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>正是由于编译器需要明确确定 Opaque Types 背后的真实类型，故不能在 Opaque Types 方法中返回不同的类型值，如下面这样是不允许的 (Opaque Types 属于编译期特性)：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">italicsBuilder</span><span class="params">()</span></span> -&gt; some <span class="type">MarkdownBuilder</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ... &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">ItalicsBuilder</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">BoldBuilder</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>好了，现在我们知道只需在上述不加思索写出的代码中加入 <code>some</code>  关键字即可，不再赘述。</p><blockquote><p>在 SwiftUI 中，大量使用到  Opaque Types。甚至可以说 Opaque Types 是为 SwiftUI 而生的。</p></blockquote><h1 id="Phantom-Types"><a href="#Phantom-Types" class="headerlink" title="Phantom Types"></a><strong>Phantom Types</strong></h1><hr><p>Phantom Types 本身与本文讨论的内容相关性不大，作为相似的概念，我们简单介绍一下。</p><p>Phantom Types 也非 Swift 特有的，属于一种通用编码技巧。</p><p>Phantom Types 没有严格的定义，一般表述是：出现在泛型参数中，但没有被真正使用。</p><p>如下代码中的 <code>Role</code> (例子来自 <a href="https://www.hackingwithswift.com/plus/advanced-swift/how-to-use-phantom-types-in-swift" target="_blank" rel="noopener">How to use phantom types in Swift</a>)，它只出现在泛型参数中，在 <code>Employee</code> 实现中并未使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span>&lt;<span class="title">Role</span>&gt;: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>What?</p><p>Phantom Types 有何用？</p><p><em>用于对类型做进一步的强化。</em></p><p>Employee 可能有不同的角色，如：Sales、Programmer 等，我们将其定义为空 enum：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sales</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Programmer</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>由于 <code>Employee</code> 实现了 <code>Equatable</code>，可以在两个实例间进行判等操作。</p><p>但判等操作明显只有在同一种角色间进行才有意义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = <span class="type">Employee</span>&lt;<span class="type">Sales</span>&gt;.<span class="keyword">init</span>(name: <span class="string">"John"</span>)</span><br><span class="line"><span class="keyword">let</span> sea = <span class="type">Employee</span>&lt;<span class="type">Programmer</span>&gt;.<span class="keyword">init</span>(name: <span class="string">"Sea"</span>)</span><br><span class="line"></span><br><span class="line">john == sea</span><br></pre></td></tr></table></figure><p>正是由于 Phantom Types 在起作用，上述代码中的判等操作编译无法通过：</p><p>Cannot convert value of type ‘Employee<programmer>‘ to expected argument type ‘Employee<sales>‘</sales></programmer></p><blockquote><p>将 Phantom Types 定义成空 enum，使其无法被实例化，从而真正满足 Phantom Types 语义。</p><p>由于 Swift 没有 NameSpacing 这样的关键字，故通常用空 enum 来实现类似的效果，如 Apple Combine Framework 中的 <code>Publishers</code>:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Publishers</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>然后在 extension 中添加具体 Publisher 类型的定义，如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Publishers</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">First</span>&lt;<span class="title">Upstream</span>&gt;: <span class="title">Publisher</span> <span class="title">where</span> <span class="title">Upstream</span>: <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>从而，可以通过 <code>Publishers.First</code> 的方式引用具体的 Publisher。</p><p>关于适当使用命名空间的好处在：<a href="https://www.swiftbysundell.com/articles/powerful-ways-to-use-swift-enums/" target="_blank" rel="noopener">Five powerful, yet lesser-known ways to use Swift enums</a> 中有一段精彩描述：</p><p>Using the above kind of namespacing can be a great way to add clear semantics to a group of types without having to manually attach a given prefix or suffix to each type’s name.</p><p>So while the above <code>First</code> type <em>could</em> instead have been named <code>FirstPublisher</code> and placed within the global scope, the current implementation makes it publicly available as <code>Publishers.First</code> — which both reads really nicely, and also gives us a hint that <code>First</code> is just one of many publishers available within the <code>Publishers</code> namespace. </p><p>It also lets us type <code>Publishers.</code> within Xcode to see a list of all available publisher variations as autocomplete suggestions.</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>Swift 作为 POP (Protocol Oriented Programming) 的提倡者，Protocol 的地位自然十分重要，Swift 赋于其强大能力。</p><p>同时，Swift 又是类型安全的，因此对于带有 <code>Self requirements</code> / <code>Associated Type</code> 的 Protocol 在使用上又有一定的限制。</p><p>结合实例，本文主要介绍了如何通过 Type Erasure、Opaque Types 以及 Generics 等方式解决上述限制。</p><p>在 <a href="https://www.raywenderlich.com/24942207-opaque-return-types-and-type-erasure" target="_blank" rel="noopener">Opaque Return Types and Type Erasure</a> 这篇文章中作者分别从库的开发者 (Liam)、编译器 (Corrine)、使用方 (Abbie) 的视角分析了他们是否了解 Protocols、Opaque Types、Generics 以及 Type Erasure 背后的私密：</p><p><img src="/img/Protocols_OpaqueTypes_Generics_TypeErasure.png" alt=""></p><p>如上图：</p><ul><li><p>Protocols：</p><ul><li>协议本身具有隐藏实现细节以及运行时实例化的特性，故编译器、使用方无法知道其背后对应的真实类型；</li><li>但，作为库的开发者 (代码是他写的)，明确知道 Protocol 背后可能对应的所有真实类型。</li></ul></li><li><p>Opaque Types：</p><ul><li>同 Protocols，库的开发者肯定是知道的；</li><li>由于 Opaque Types 限制只能对应一种真实类型，并在编译期需明确，故编译器是知道的；</li><li>对于使用方来说，他们看到的还是隐藏了细节的 Protocol。</li></ul></li><li><p>Generics：</p><ul><li>泛型是将类型决定权让给使用方的，故库的开发者是不知道真实类型的，而使用方知道；</li><li>泛型属于编译期行为，故编译器能明确知道泛型对于的真实类型。</li></ul></li><li><p>Type Erasure：</p><ul><li>类型擦除属于使用方行为，用于规避编译错误等，故只有使用方知道。</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md" target="_blank" rel="noopener">swift-evolution · Opaque Result Types</a></p><p><a href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html" target="_blank" rel="noopener">OpaqueTypes</a></p><p><a href="https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift/#closures-to-the-rescue" target="_blank" rel="noopener">Different flavors of type erasure in Swift</a></p><p><a href="https://www.raywenderlich.com/24942207-opaque-return-types-and-type-erasure" target="_blank" rel="noopener">Opaque Return Types and Type Erasure</a></p><p><a href="https://www.swiftbysundell.com/articles/phantom-types-in-swift/" target="_blank" rel="noopener">Phantom types in Swift</a></p><p><a href="https://www.hackingwithswift.com/plus/advanced-swift/how-to-use-phantom-types-in-swift" target="_blank" rel="noopener">How to use phantom types in Swift</a></p><p><a href="https://github.com/apple/swift/blob/main/docs/ABI/TypeMetadata.rst#protocol-metadata" target="_blank" rel="noopener">swift/TypeMetadata.rst at main · apple/swift · GitHub</a></p><p><a href="https://github.com/apple/swift/blob/main/docs/ABI/TypeLayout.rst" target="_blank" rel="noopener">swift/TypeLayout.rst at main · apple/swift · GitHub</a></p><p><a href="https://speakerdeck.com/kateinoigakukun/swift-type-metadata?slide=48" target="_blank" rel="noopener">Swift Type Metadata</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="noopener">Understanding Swift Performance · WWDC2016</a></p><p><a href="https://www.swift.org/blog/whole-module-optimizations/" target="_blank" rel="noopener">Swift.org - Whole-Module Optimization in Swift 3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们将从实践技巧、实现原理两个方面对 Swift Protocol 展开深入讨论。&lt;/p&gt;
&lt;p&gt;本文作为上篇主要介绍实践技巧，以一个 Protocol 相关的编译错误为引，通过实例对 Type Erasure、Opaque Types 、Generics 以及 Phantom Types 做了较详细的讨论。它们对于写出更优、更雅的 Swift 代码有一定的帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://zxfcumtcs.github.io/tags/Swift/"/>
    
      <category term="Protocol" scheme="http://zxfcumtcs.github.io/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Flutter Framework 之自定义渲染型 Widget</title>
    <link href="http://zxfcumtcs.github.io/2021/08/28/deepinto-flutter-custom-renderobjectwidget/"/>
    <id>http://zxfcumtcs.github.io/2021/08/28/deepinto-flutter-custom-renderobjectwidget/</id>
    <published>2021-08-28T03:07:58.000Z</published>
    <updated>2021-09-04T15:08:01.191Z</updated>
    
    <content type="html"><![CDATA[<p>本文是『 深入浅出 Flutter Framework 』系列文章的第八篇，也是收官之作。通过自定义渲染型 Widget，我们一步步地实现了一个评分组件。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><p>本系列文章将深入 Flutter Framework 内部逐步去分析其核心概念和流程，主要包括：<br><a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">『 深入浅出 Flutter Framework 之 Widget 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">『 深入浅出 Flutter Framework 之 BuildOwner 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">『 深入浅出 Flutter Framework 之 Element 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/">『 深入浅出 Flutter Framework 之 PaintingContext 』</a><br><a href="https://zxfcumtcs.github.io/2020/06/07/deepinto-flutter-layer/">『 深入浅出 Flutter Framework 之 Layer 』</a><br><a href="https://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/">『 深入浅出 Flutter Framework 之 PipelineOwner 』</a><br><a href="https://zxfcumtcs.github.io/2021/03/27/deepinto-flutter-renderobject/">『 深入浅出 Flutter Framework 之 RenderObejct 』</a><br>『 深入浅出 Flutter Framework 之自定义渲染型 Widget 』</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>本文作为『 深入浅出 Flutter Framework 』系列文章的收官之作，为了对本系列文章所涉重点内容的回顾和总结，动手实现一个渲染型 Widget (Render-Widget)。<br>如下图，最终成品是一个评分组件 (源码已上传 Github: <a href="https://github.com/zxfcumtcs/Score" target="_blank" rel="noopener">Score</a>)：<br><img src="/img/Score.gif" alt=""></p><p>通过前面系列文章的介绍，我们知道 Render-Widget 大致有三类：</p><ul><li>作为『 Widget Tree 』的叶节点，也是最小的 UI 表达单元，一般继承自<code>LeafRenderObjectWidget</code>；</li><li>有一个子节点 ( Single Child )，一般继承自<code>SingleChildRenderObjectWidget</code>；</li><li>有多个子节点 ( Multi Child )，一般继承自<code>MultiChildRenderObjectWidget</code>。</li></ul><p>Widget 间的继承关系如下图：<br><img src="/img/Widget.png" alt=""></p><p>Widget、Element、RenderObject 间的对应关系如下：<br><img src="/img/Widget-Element-RenderObject.png" alt=""></p><blockquote><p>其中，Element 与 RenderObject 间用的是虚线，因为它们间的对应关系是基于 RenderBox 系列下的一种建议 (不是强制)。<br>Sliver 系列就不是基于<code>RenderBox</code>，而是<code>RenderSliver</code>。<br>通过<code>Render-Widget#createRenderObject</code>方法可以返回任意 RenderObject (如果你愿意)。</p></blockquote><p>对于<code>RenderBox</code>系列来说，如果要自定义子类，根据自定义子类子节点模型的不同需要有不同的处理：</p><ul><li>自定义子类本身是『 Render Tree 』的叶子节点，一般直接继承自<code>RenderBox</code>；</li><li>有一个子节点 (Single Child)，且子节点属于<code>RenderBox</code>系列：<ul><li>如果其自身的 size 完全 match 子节点的 size，则可以选择继承自<code>RenderProxyBox</code>(如：<code>RenderOffstage</code>)；</li><li>如果其自身的 size 大于子节点的 size，则可以选择继承自<code>RenderShiftedBox</code>(如：<code>RenderPadding</code>)；</li></ul></li><li>有一个子节点 (Single Child)，但子节点不属于<code>RenderBox</code>系列，自定义子类可以 mixin <code>RenderObjectWithChildMixin</code>，其提供了管理一个子节点的模型；</li><li>有多个子节点 (Multi Child)，自定义子类可以 mixin <code>ContainerRenderObjectMixin</code>、<code>RenderBoxContainerDefaultsMixin</code>，前者提供了管理多个子节点的模型，后者提供了基于<code>ContainerRenderObjectMixin</code>的一些默认实现。</li></ul><p>下面，我们一步步地来实现上面提到的评分组件。</p><h1 id="Custom-Leaf-Render-Widget"><a href="#Custom-Leaf-Render-Widget" class="headerlink" title="Custom Leaf Render Widget"></a>Custom Leaf Render Widget</h1><hr><p>首先，我们来实现评分组件里的五星部分 (ScoreStar Widget)：<br><img src="/img/Stars.png" width="40%" height="40%"></p><h2 id="LeafRenderObjectWidget"><a href="#LeafRenderObjectWidget" class="headerlink" title="LeafRenderObjectWidget"></a>LeafRenderObjectWidget</h2><p><code>ScoreStar</code>作为叶子节点，继承自<code>LeafRenderObjectWidget</code>，并实现了2个重要方法：<code>createRenderObject</code>、<code>updateRenderObject</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreStar</span> <span class="keyword">extends</span> <span class="title">LeafRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Color backgroundColor;</span><br><span class="line">  <span class="keyword">final</span> Color foregroundColor;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> score;</span><br><span class="line"></span><br><span class="line">  ScoreStar(<span class="keyword">this</span>.backgroundColor, <span class="keyword">this</span>.foregroundColor, <span class="keyword">this</span>.score);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObject createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RenderScoreStar(backgroundColor, foregroundColor, score);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, covariant RenderScoreStar renderObject) &#123;</span><br><span class="line">    renderObject</span><br><span class="line">      ..backgroundColor = backgroundColor</span><br><span class="line">      ..foregroundColor = foregroundColor</span><br><span class="line">      ..score = score;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，<code>updateRenderObject</code>方法会在 Widget re-build 时调用，用于更新复用的 Render Object 的属性。<br>在本例中，<code>score</code>会随着用户点击不同的区域而变化，就需要通过<code>updateRenderObject</code>方法来更新<code>RenderScoreStar#score</code>，以便刷新 UI。</p><h2 id="Leaf-Render-Object"><a href="#Leaf-Render-Object" class="headerlink" title="Leaf Render Object"></a>Leaf Render Object</h2><p>从上一小节<code>ScoreStar#createRenderObject</code>可知，<code>ScoreStar</code> 对应的 Render Object 是<code>RenderScoreStar</code>。<br><code>RenderScoreStar</code>继承自<code>RenderBox</code>。</p><p>如下代码：</p><ul><li>在 <code>socre setter</code> 中调用了<code>markNeedsPaint</code>方法，以便在<code>score</code>变化后及时 re-paint (由于 socre 变化不会引起 layout 变化，故此处只需调用<code>markNeedsPaint</code>，若会引起 layout 变化，则需要调用<code>markNeedsLayout</code>)；</li><li>关于<code>sizedByParent</code>，在该例子中设为<code>true</code> or <code>false</code>都可以，因为<code>RenderScoreStar#size</code>完全由<code>constraints</code>决定：<ul><li>从性能角度考虑，<code>sizedByParent</code>应设为<code>true</code>，以便满足<code>RepaintBoundary</code>的条件 (详情请参见[ <a href="https://zxfcumtcs.github.io/2021/03/27/deepinto-flutter-renderobject/">深入浅出 Flutter Framework 之 RenderObject</a> ] )；</li><li>若<code>sizedByParent</code>设为<code>true</code>，需要重写<code>performResize</code>方法来计算 size，由于<code>RenderScoreStar</code>没有 layout 操作需要执行，故不需要重写<code>performLayout</code>；</li><li>若<code>sizedByParent</code>设为<code>false</code>，则需要重写<code>performLayout</code>，并在该方法中完成 size 的计算；</li><li><code>22~30</code>、<code>32~40</code>两个代码片段随便使用哪个都可以。</li></ul></li><li>关于IntrinsicWidth/Height，若重写了<code>performLayout</code>方法，则进而需要重写以下四个方法：<ul><li><code>double computeMaxIntrinsicWidth(double height)</code>：用于计算一个最小宽度(没错，是最小宽度)，在最终 size.width 超过该宽度时，也不会减少 size.height (如，对 text 排版，将 text 排成一行需要的最小宽度就是这里的 MaxIntrinsicWidth，因为再增加宽度也不会减少 text 的高度)；</li><li><code>double computeMinIntrinsicWidth(double height)</code>：排版需要的最小宽度，若小于这个宽度内容就会被裁剪；</li><li><code>computeMinIntrinsicHeight</code>、<code>computeMaxIntrinsicHeight</code>与上面介绍的<code>computeMinIntrinsicWidth</code>、<code>computeMaxIntrinsicWidth</code>类似，不再赘述；</li><li>在一些特殊 RenderObject 排版时才会用到这些方法，在此我们根据 constraints 简单计算了一下。</li></ul></li><li>为了响应点击事件，重写<code>hitTestSelf</code>方法，并返回<code>true</code>，表示该 Render Object 需要响应用户事件； </li><li>关于<code>paint</code>方法中五角星 ★★★★★ 的绘制：<ul><li>对于背景 ★★★★★，设置好 path 后，直接通过<code>context.canvas.drawPath</code>绘制即可；</li><li>对于前景 ★★★★★，先通过<code>context.pushClipRect</code>对画布进行裁剪 ( rect.width 由 score 决定 )，再行绘制。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// 为了缩减篇幅，精简了部分代码</span><br><span class="line">//</span><br><span class="line">class RenderScoreStar extends RenderBox &#123;</span><br><span class="line">  Color _backgroundColor;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  Color _foregroundColor;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  double _score;</span><br><span class="line">  double get score =&gt; _score;</span><br><span class="line">  set score(double value) &#123;</span><br><span class="line">    _score = value;</span><br><span class="line">    </span><br><span class="line">    // score 变化时需要re-paint</span><br><span class="line">    //</span><br><span class="line">    markNeedsPaint();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RenderScoreStar(this._backgroundColor, this._foregroundColor, this._score);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool get sizedByParent =&gt; false;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void performLayout() &#123;</span><br><span class="line">    double height = min(constraints.biggest.height, constraints.biggest.width / 5);</span><br><span class="line">    height = max(height, constraints.smallest.height);</span><br><span class="line">    size = Size(constraints.biggest.width, height);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // @override</span><br><span class="line">  // bool get sizedByParent =&gt; true;</span><br><span class="line">  //</span><br><span class="line">  // @override</span><br><span class="line">  // void performResize() &#123;</span><br><span class="line">  //   double height = min(constraints.biggest.height, constraints.biggest.width / 5);</span><br><span class="line">  //   height = max(height, constraints.smallest.height);</span><br><span class="line">  //   size = Size(constraints.biggest.width, height);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  double computeMaxIntrinsicWidth(double height) &#123;</span><br><span class="line">    return constraints.biggest.width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  double computeMaxIntrinsicHeight(double width) &#123;</span><br><span class="line">    double height = min(constraints.biggest.height, constraints.biggest.width / 5);</span><br><span class="line">    height = max(height, constraints.smallest.height);</span><br><span class="line"></span><br><span class="line">    return height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool hitTestSelf(Offset position) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">    void _backgroundStarPainter(PaintingContext context, Offset offset) &#123;</span><br><span class="line">      _starPainter(context, offset, backgroundColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void _foregroundStarPainter(PaintingContext context, Offset offset) &#123;</span><br><span class="line">      _starPainter(context, offset, foregroundColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _backgroundStarPainter(context, offset);</span><br><span class="line">    context.pushClipRect(</span><br><span class="line">        needsCompositing,</span><br><span class="line">        offset,</span><br><span class="line">        Rect.fromLTRB(0, 0, size.width * score / 5, size.height),</span><br><span class="line">        _foregroundStarPainter</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void _starPainter(PaintingContext context, Offset offset, Color color) &#123;</span><br><span class="line">    Paint paint = Paint();</span><br><span class="line">    paint.color = color;</span><br><span class="line">    paint.style = PaintingStyle.fill;</span><br><span class="line"></span><br><span class="line">    double radius = min(size.height / 2, size.width/ (2 * 5));</span><br><span class="line"></span><br><span class="line">    Path path = Path();</span><br><span class="line">    _addStarLine(radius, path);</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">      path = path.shift(Offset(radius * 2, 0.0));</span><br><span class="line">      _addStarLine(radius, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path = path.shift(offset);</span><br><span class="line">    path.close();</span><br><span class="line"></span><br><span class="line">    context.canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void _addStarLine(double radius, Path path) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<code>RenderScoreStar</code>基本完成，完整代码请参见 [ Github：<a href="https://github.com/zxfcumtcs/Score" target="_blank" rel="noopener">Score</a> ]</p><h1 id="动态评分"><a href="#动态评分" class="headerlink" title="动态评分"></a>动态评分</h1><hr><p>如下图，我们希望评分组件不仅能展示分数，还能评分：<br><img src="/img/Score_small.gif" alt=""></p><p>在 Flutter UI 中，一个重要的思想就是：『 组合 』。<br>为了实现上图所示效果，只需组合<code>StatefulWidget</code> +<code>ScoreStar</code>即可：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> ScoreCallback = <span class="keyword">void</span> <span class="built_in">Function</span>(<span class="built_in">double</span> score);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Score</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> score;</span><br><span class="line">  <span class="keyword">final</span> ScoreCallback callback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Score(&#123;Key key, <span class="keyword">this</span>.score = <span class="number">0</span>, <span class="keyword">this</span>.callback&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ScoreState createState() =&gt; _ScoreState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScoreState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Score</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> score;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    score = widget.score ?? <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(Score oldWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line"></span><br><span class="line">    score = widget.score ?? <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">void</span> _changeScore(Offset offset) &#123;</span><br><span class="line">      Size _size = context.size;</span><br><span class="line">      <span class="built_in">double</span> offsetX = min(offset.dx, _size.width);</span><br><span class="line">      offsetX = max(<span class="number">0</span>, offsetX);</span><br><span class="line"></span><br><span class="line">      setState(() &#123;</span><br><span class="line">        score = <span class="built_in">double</span>.parse(((offsetX / _size.width) * <span class="number">5</span>).toStringAsFixed(<span class="number">1</span>));</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (widget.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        widget.callback(score);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      child: ScoreStar(Colors.grey, Colors.amber, score),</span><br><span class="line">      onTapDown: (TapDownDetails details) &#123;</span><br><span class="line">        _changeScore(details.localPosition);</span><br><span class="line">      &#125;,</span><br><span class="line">      onLongPressMoveUpdate:(LongPressMoveUpdateDetails details) &#123;</span><br><span class="line">        _changeScore(details.localPosition);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码比较简单，就不赘述了。<br>其中的关键还是上节介绍的<code>RenderScoreStar#hitTestSelf</code>需要返回<code>true</code>。</p><h1 id="Custom-MultiChild-RenderObject-Widget"><a href="#Custom-MultiChild-RenderObject-Widget" class="headerlink" title="Custom MultiChild RenderObject Widget"></a>Custom MultiChild RenderObject Widget</h1><hr><p><img src="/img/Score.gif" alt=""><br>我们希望通过自定义 MultiChild RenderObject Widget 实现如上图所示的效果。<br>没错，就是加了一个显示分数的 Text。</p><blockquote><p>本来，这完全没必要通过自定义 MultiChild RenderObject Widget 来实现，一般的 Widget 组合即可。<br>我们只是为了实践自定义 MultiChild RenderObject Widget 才这么做的。</p></blockquote><h2 id="MultiChildRenderObjectWidget"><a href="#MultiChildRenderObjectWidget" class="headerlink" title="MultiChildRenderObjectWidget"></a>MultiChildRenderObjectWidget</h2><p><code>RichScore</code>继承自<code>MultiChildRenderObjectWidget</code>。<br>在其初始化方法中，向父类传递了2个 children：<code>Score</code>、<code>Text</code>。<br>重写了<code>createRenderObject</code>方法，以便返回<code>RenderRichScore</code>实例。<br>由于<code>RenderRichScore</code>没有属性，故无需重写<code>updateRenderObject</code>方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichScore</span> <span class="keyword">extends</span> <span class="title">MultiChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  RichScore(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="built_in">double</span> score,</span><br><span class="line">    ScoreCallback callback,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(</span><br><span class="line">    key: key,</span><br><span class="line">    children: [</span><br><span class="line">      Score(score: score, callback: callback),</span><br><span class="line">      Text(<span class="string">'<span class="subst">$score</span>分'</span>, style: TextStyle(fontSize: <span class="number">28</span>)),</span><br><span class="line">    ]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObject createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RenderRichScore();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RichScoreParentData"><a href="#RichScoreParentData" class="headerlink" title="RichScoreParentData"></a>RichScoreParentData</h2><p>还记得 ParentData 吗？</p><blockquote><p>在<a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">『 深入浅出 Flutter Framework 之 Widget 』</a>中有过简单介绍。</p></blockquote><p>对于含有子节点的 RenderObject，一般都需要自定义自己的 ParentData 子类，用于辅助 layout。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichScoreParentData</span> <span class="keyword">extends</span> <span class="title">ContainerBoxParentData</span>&lt;<span class="title">RenderBox</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> scoreTextWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>RichScoreParentData</code>继承自<code>ContainerBoxParentData</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Abstract ParentData subclass for RenderBox subclasses that want the</span></span><br><span class="line"><span class="comment">/// ContainerRenderObjectMixin.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This is a convenience class that mixes in the relevant classes with</span></span><br><span class="line"><span class="comment">/// the relevant type arguments.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerBoxParentData</span>&lt;<span class="title">ChildType</span> <span class="keyword">extends</span> <span class="title">RenderObject</span>&gt; <span class="keyword">extends</span> <span class="title">BoxParentData</span> <span class="title">with</span> <span class="title">ContainerParentDataMixin</span>&lt;<span class="title">ChildType</span>&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p><p><code>ContainerBoxParentData</code>是抽象类，但其 mixin<code>ContainerParentDataMixin</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Parent data to support a doubly-linked list of children.</span></span><br><span class="line">mixin ContainerParentDataMixin&lt;ChildType <span class="keyword">extends</span> RenderObject&gt; on ParentData &#123;</span><br><span class="line">  <span class="comment">/// The previous sibling in the parent's child list.</span></span><br><span class="line">  ChildType previousSibling;</span><br><span class="line">  <span class="comment">/// The next sibling in the parent's child list.</span></span><br><span class="line">  ChildType nextSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ContainerParentDataMixin</code>在子节点间提供了双向链接的支持。</p><p>在<code>RichScoreParentData</code>中定义了唯一一个属性：<code>scoreTextWidth</code>，其作用在后面再介绍。</p><h2 id="MultiChild-RenderObject"><a href="#MultiChild-RenderObject" class="headerlink" title="MultiChild RenderObject"></a>MultiChild RenderObject</h2><p><code>RenderRichScore</code>继承自<code>RenderBox</code>并 minix 了<code>ContainerRenderObjectMixin</code>以及<code>RenderBoxContainerDefaultsMixin</code>：</p><ul><li>由于<code>RenderRichScore#size</code>受子节点的影响，即不完全由 Constraints 决定，故<code>sizedByParent</code>设为<code>false</code>，同时在调用子节点的<code>layout</code>方法时<code>parentUsesSize</code>参数需设为<code>true</code> (下面代码第<code>40</code>、<code>55</code>行)；</li><li>由于其子节点 (<code>RenderScoreStar</code>)需要响应用户事件，故重写了<code>hitTestChildren</code>方法；</li><li>在<code>performLayout</code>方法中，完成了所有子节点的排版、设置相应的 ParentData 并计算出了 size；</li><li>对于有子节点的 RenderObject 需要重写<code>computeDistanceToActualBaseline</code>方法，这里我们用了<code>RenderBoxContainerDefaultsMixin</code>提供的默认实现；</li><li><code>paint</code>方法的功能很简单，依次绘制每个子节点(<code>defaultPaint</code>由<code>RenderBoxContainerDefaultsMixin</code>提供)；</li><li><code>setupParentData</code>用于给子节点设置<code>parentData</code>。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderRichScore</span> <span class="keyword">extends</span> <span class="title">RenderBox</span> <span class="title">with</span> <span class="title">ContainerRenderObjectMixin</span>&lt;<span class="title">RenderBox</span>, <span class="title">RichScoreParentData</span>&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">RenderBoxContainerDefaultsMixin</span>&lt;<span class="title">RenderBox</span>, <span class="title">RichScoreParentData</span>&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">DebugOverflowIndicatorMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  RenderRichScore(&#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;RenderBox&gt; children,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    addAll(children);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> sizedByParent =&gt; <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> horizontalSpace = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> scoreTextWidthDifference = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> hitTestChildren(BoxHitTestResult result, &#123; Offset position &#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(childCount == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    RenderBox scoreChild = firstChild;</span><br><span class="line">    <span class="keyword">return</span> scoreChild?.hitTest(result, position: position) ?? <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(childCount == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    RenderBox scoreStarChild = firstChild;</span><br><span class="line">    RenderBox scoreTextChild = lastChild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scoreStarChild == <span class="keyword">null</span> || scoreTextChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">      size = constraints.smallest;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// infinity constraints</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    BoxConstraints descConstraints = BoxConstraints();</span><br><span class="line">    scoreTextChild.layout(descConstraints, parentUsesSize: <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RichScoreParentData descChildParentData = scoreTextChild.parentData <span class="keyword">as</span> RichScoreParentData;</span><br><span class="line">    <span class="built_in">double</span> descWidth = descChildParentData.scoreTextWidth;</span><br><span class="line">    <span class="keyword">if</span> (descWidth == <span class="keyword">null</span>) &#123;</span><br><span class="line">      descWidth = scoreTextChild.size.width + scoreTextWidthDifference;</span><br><span class="line">      descChildParentData.scoreTextWidth = descWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BoxConstraints scoreConstraints = BoxConstraints(</span><br><span class="line">      minWidth: <span class="number">0</span>,</span><br><span class="line">      maxWidth: max(constraints.maxWidth - descWidth - horizontalSpace, <span class="number">0</span>),</span><br><span class="line">      minHeight: <span class="number">0</span>,</span><br><span class="line">      maxHeight: constraints.maxHeight</span><br><span class="line">    );</span><br><span class="line">    scoreStarChild.layout(scoreConstraints, parentUsesSize: <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    descChildParentData.offset = Offset(</span><br><span class="line">      scoreStarChild.size.width + horizontalSpace,</span><br><span class="line">      (scoreStarChild.size.height - scoreTextChild.size.height) / <span class="number">2</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (constraints.isTight) &#123;</span><br><span class="line">      size = constraints.biggest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">double</span> width = min(constraints.biggest.width, scoreStarChild.size.width + descWidth + horizontalSpace);</span><br><span class="line">      width = max(constraints.smallest.width, width);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">double</span> height = max(scoreStarChild.size.height, scoreTextChild.size.height);</span><br><span class="line">      height = min(constraints.biggest.height, height);</span><br><span class="line">      height = max(constraints.smallest.height, height);</span><br><span class="line"></span><br><span class="line">      size = Size(width, height);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">double</span> computeDistanceToActualBaseline(TextBaseline baseline) &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultComputeDistanceToFirstActualBaseline(baseline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(childCount == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (childCount != <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    defaultPaint(context, offset);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> setupParentData(RenderObject child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.parentData <span class="keyword">is</span>! RichScoreParentData) &#123;</span><br><span class="line">      child.parentData = RichScoreParentData();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RichScoreParentData-scoreTextWidth"><a href="#RichScoreParentData-scoreTextWidth" class="headerlink" title="RichScoreParentData#scoreTextWidth"></a>RichScoreParentData#scoreTextWidth</h2><p>上面我们提到<code>RichScoreParentData</code>有唯一一个属性：<code>scoreTextWidth</code>。<br>那么它的作用是啥呢？<br>根据<code>RenderRichScore</code>的排版算法，先计算 text 的宽度，★★★★★ 的宽度等于 constraints.biggest.width - textWidth。<br>这个算法有点小问题：<br><img src="/img/bad_score.gif" alt=""><br>由于 textWidth 会因分数的不同，而有细微的差异，最终导致 ★★★★★ 有点闪烁。<br>为了解决这个问题，我们将 textWidth 的宽度固定为首次计算的 text 宽度+10，并将其存储在<code>RichScoreParentData</code>中(上述代码第<code>42~47</code>行)。</p><blockquote><p>这种解决方法不一定是最好的，这里主要是演示一下 ParentData 的作用。</p></blockquote><p>至此，自定义 MultiChild RenderObject 基本完成了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>本文通过实现评分组件，逐步实践了如何自定义 Leaf Render Widget 以及 MultiChild Render Widget。<br>在这过程中，自定义了 Widget 以及 Render Object，但并没有涉及 Element。<br>原因是 Element 作为 Widget 与 Render Object 间的桥梁，逻辑相对内聚、独立。<br>当自定义 Widget 继承自<code>LeafRenderObjectWidget</code>、<code>SingleChildRenderObjectWidget</code>或<code>MultiChildRenderObjectWidget</code>时，一般不用自定义 Element。</p><p>自定义 Leaf Render Widget，一般需要以下步骤：</p><ul><li>自定义 Widget 继承自<code>LeafRenderObjectWidget</code>，并重写<code>createRenderObject</code>、<code>updateRenderObject</code>方法；</li><li>自定义 Render Object 继承自<code>RenderBox</code>：<ul><li>确定<code>sizedByParent</code>为<code>true</code> or <code>false</code>；</li><li>为<code>false</code>，重写<code>performLayout</code>方法，执行 layout 并计算 size；</li><li>为<code>true</code>，重写<code>performResize</code>方法计算 size、重写<code>performLayout</code>方法执行 layout (若需要)；</li><li>如果重写了<code>performLayout</code>方法，则需进一步重写<code>computeMax/MinIntrinsicWidth/Height</code>系列方法；</li><li>如需处理用户事件，重写<code>hitTestSelf</code>方法；</li><li>重写<code>paint</code>方法，完成最终的绘制。</li></ul></li></ul><p>自定义 MultiChild Render Widget，一般需要以下步骤：</p><ul><li>自定义 Widget 继承自<code>MultiChildRenderObjectWidget</code>，并重写<code>createRenderObject</code>、<code>updateRenderObject</code>方法；</li><li>自定义 Render Object 继承自<code>RenderBox</code>，并 minix <code>ContainerRenderObjectMixin</code>、<code>RenderBoxContainerDefaultsMixin</code>：<ul><li>确定<code>sizedByParent</code>为<code>true</code> or <code>false</code>；</li><li>为<code>false</code>，重写<code>performLayout</code>方法，对子节点逐个执行 layout 操作并计算 size；</li><li>为<code>true</code>，重写<code>performResize</code>方法计算 size、重写<code>performLayout</code>方法执行 layout；</li><li>如果重写了<code>performLayout</code>方法，则需进一步重写<code>computeMax/MinIntrinsicWidth/Height</code>系列方法；</li><li>重写<code>computeDistanceToActualBaseline</code>方法计算 baseline;</li><li>如需处理用户事件，重写<code>hitTestSelf</code>或/和<code>hitTestChildren</code>方法；</li><li>自定义 ContainerBoxParentData 子类，用于存储 layout 过程中需要的辅助信息；</li><li>重写<code>setupParentData</code>方法，为子节点设置 ParentData；</li><li>重写<code>paint</code>方法，对子节点逐个执行 paint 操作。</li></ul></li></ul><p>『 深入浅出 Flutter Framework 』系列文章至此全部完成！<br>这一系列文章围绕 Widget、Element 以及 RenderObject 展开讨论，对 Flutter Framework 有了一个简单的认识。<br>在此过程中对相关的 BuildOwner、PaintingContext、Layer 以及 PipelineOwner 等也进行了一定的讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是『 深入浅出 Flutter Framework 』系列文章的第八篇，也是收官之作。通过自定义渲染型 Widget，我们一步步地实现了一个评分组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://zxfcumtcs.github.io/tags/flutter/"/>
    
      <category term="移动开发" scheme="http://zxfcumtcs.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨平台" scheme="http://zxfcumtcs.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Flutter Framework 之 RenderObject</title>
    <link href="http://zxfcumtcs.github.io/2021/03/27/deepinto-flutter-renderobject/"/>
    <id>http://zxfcumtcs.github.io/2021/03/27/deepinto-flutter-renderobject/</id>
    <published>2021-03-27T08:14:34.000Z</published>
    <updated>2021-09-04T15:19:33.719Z</updated>
    
    <content type="html"><![CDATA[<p>本文是『 深入浅出 Flutter Framework 』系列文章的第七篇。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><p>本系列文章将深入 Flutter Framework 内部逐步去分析其核心概念和流程，主要包括：<br><a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">『 深入浅出 Flutter Framework 之 Widget 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">『 深入浅出 Flutter Framework 之 BuildOwner 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">『 深入浅出 Flutter Framework 之 Element 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/">『 深入浅出 Flutter Framework 之 PaintingContext 』</a><br><a href="https://zxfcumtcs.github.io/2020/06/07/deepinto-flutter-layer/">『 深入浅出 Flutter Framework 之 Layer 』</a><br><a href="https://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/">『 深入浅出 Flutter Framework 之 PipelineOwner 』</a><br>『 深入浅出 Flutter Framework 之 RenderObejct 』<br><a href="https://zxfcumtcs.github.io/2021/08/28/deepinto-flutter-custom-renderobjectwidget/">『 深入浅出 Flutter Framework 之自定义渲染型 Widget 』</a></p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>可以说，RenderObject 在整个 Flutter Framework 中属于核心对象，其职责概括起来主要有三点：<br>『 Layout 』、『 Paint 』、『 Hit Testing 』。<br>然而，RenderObject 是抽象类，具体工作由子类去完成。<br><img src="/img/RenderObjectClassDiagram.png" width="80%" height="80%"><br>如上图，<code>RenderSliver</code>、<code>RenderBox</code>、<code>RenderView</code>以及<code>RenderAbstractViewport</code>是在 Flutter Framework 中定义的4个子类：</p><ul><li><code>RenderSliver</code>，『 Sliver-Widget 』对应的 Base RenderObject；</li><li><code>RenderBox</code>，除『 Sliver-Widget 』外几乎所有常见 Render-Widget 对应的 Base RenderObject；</li><li><code>RenderView</code>，是一种特殊的 Render Object，是『 RenderObect Tree 』的根节点；</li><li><code>RenderAbstractViewport</code>，主要用于『 Scroll-Widget 』。</li></ul><p><img src="/img/RenderObject_XMind.png" alt=""><br>如上图，概括了<code>RenderObject</code>中与 Layout、Paint 相关的主要属性与方法(也是本文将要讨论的主要内容)。<br>其中，用虚线框起来的是<code>RenderObject</code>子类需要重写的方法。<br>正如上面所说，<code>RenderObject</code>是抽象类，它即没有明确使用哪种坐标系 (Cartesian coordinates or Polar coordinates)，也没有指定使用哪种排版算法 (width-in-height-out or constraint-in-size-out)。</p><blockquote><p><code>RenderBox</code>采用笛卡尔坐标系、排版算法是 constraint-in-size-out，即根据父节点传递的排版约束来计算 Size。</p></blockquote><p>下面我们从<code>RenderObject</code>生命周期中几个关键节点展开介绍：创建、布局、渲染。</p><blockquote><p>本文所示代码基于 Flutter 1.12.13，同时对代码做了精简处理，以便突出所要讨论的重点。</p></blockquote><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><hr><p>在<a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">『深入浅出 Flutter Framework 之 Element』</a>一文中我们介绍过，当 RenderObjectElement 被挂载(mount) 到『 Element Tree 』上时，会创建对应的 Render Object 。<br>同时，会将其 attach 到『 RenderObject Tree 』上，也就是在『 Element Tree 』创建过程中『 RenderObject Tree 』也被逐步创建出来：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderObjectElement</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><hr><p>在<a href="https://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/">『深入浅出 Flutter Framework 之 PipelineOwner』</a>一文中介绍过，当 RenderObject 需要(重新)布局时调用<code>markNeedsLayout</code>方法，从而被<code>PipelineOwner</code>收集，并在下一帧刷新时触发 Layout 操作。</p><h2 id="markNeedsLayout调用场景"><a href="#markNeedsLayout调用场景" class="headerlink" title="markNeedsLayout调用场景"></a>markNeedsLayout调用场景</h2><ul><li>Render Object 被添加到『 RenderObject Tree 』;</li><li>子节点 adopt、drop、move；</li><li>由子节点的<code>markNeedsLayout</code>方法传递调用；</li><li>Render Object 自身与布局相关的属性发生变化，如<code>RenderFlex</code>的排版方向有变化时：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> direction(Axis value) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(value != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (_direction != value) &#123;</span><br><span class="line">    _direction = value;</span><br><span class="line">    markNeedsLayout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Relayout-Boundary"><a href="#Relayout-Boundary" class="headerlink" title="Relayout Boundary"></a>Relayout Boundary</h2><p>若某个 Render Object 的布局变化不会影响到其父节点的布局，则该 Render Object 就是『 Relayout Boundary 』。<br>Relayout Boundary 是一项重要的优化措施，可以避免不必要的 re-layout。</p><p>当某个 Render Object 是 Relayout Boundary 时，会切断 layout dirty 向父节点传播，即下一帧刷新时父节点无需 re-layout。<br><img src="/img/RelayoutBoundary.png" width="50%" height="50%"><br>如上图：</p><ul><li>若<code>RD</code>节点出现 layout dirty，由于其自身、其父节点<code>RA</code>、<code>RRoot</code>都不是 Relayout Boundary，最终 layout dirty 传播到根节点<code>RenderView</code>，导致整颗『 RenderObject Tree 』重新布局；</li><li>若<code>RF</code>节点出现 layout dirty，由于其父节点<code>RB</code>为 Relayout Boundary，layout dirty 传播到<code>RB</code>即结束，最终需要重新布局的只有<code>RB</code>、<code>RF</code>两个节点；</li><li>若<code>RG</code>节点出现 layout dirty，由于其自身就是 Relayout Boundary，最终需要重新布局的只有<code>RG</code>自己。</li></ul><p>那么，具体来说要成为 Relayout Boundary 需要满足什么条件呢？<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  RenderObject relayoutBoundary;</span><br><span class="line">  <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">    relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    relayoutBoundary = (parent <span class="keyword">as</span> RenderObject)._relayoutBoundary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class="line">    visitChildren(_cleanChildRelayoutBoundary);</span><br><span class="line">  &#125;</span><br><span class="line">  _relayoutBoundary = relayoutBoundary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上是<code>RenderObject#layout</code>中与 Relayout Boundary 有关的代码，<br>可知满足以下 4 个条件之一即可成为 Relayout Boundary：</p><ul><li><code>parentUsesSize</code>为<code>false</code>，即父节点在 layout 时不会使用当前节点的 size 信息(也就是当前节点的排版信息对父节点无影响)；</li><li><code>sizedByParent</code>为<code>true</code>，即当前节点的 size 完全由父节点的 constraints 决定，即若在两次 layout 中传递下来的 constraints 相同，则两次 layout 后当前节点的 size 也相同；</li><li>传给当前节点的 constraints 是紧凑型 (Tight)，其效果与<code>sizedByParent</code>为<code>true</code>是一样的，即当前节点的 layout 不会改变其 size，size 由 constraints 唯一确定；</li><li>父节点不是 RenderObject 类型(主要针对根节点，其父节点为nil)。</li></ul><blockquote><p>每个 Render Object 都有一个<code>relayoutBoundary</code>属性，其值要么等于自己，要么等于父节点的<code>relayoutBoundary</code>。</p></blockquote><h2 id="markNeedsLayout"><a href="#markNeedsLayout" class="headerlink" title="markNeedsLayout"></a>markNeedsLayout</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsLayout() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_needsLayout) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">this</span>) &#123;</span><br><span class="line">    markParentNeedsLayout();</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner._nodesNeedingLayout.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可以看到：</p><ul><li>若当前 Render Object 不是 Relayout Boundary，则 layout 请求向上传播给父节点(即 layout 范围扩大到父节点，这是一个递归过程，直到遇到 Relayout Boundary)；</li><li>若当前 Render Object 是 Relayout Boundary，则 layout 请求到该节点为此，不会传播到其父节点。</li></ul><blockquote><p>通过 PipelineOwner 收集所有 layout dirty 节点，并在下一帧刷新时批量处理，而不是实时更新 dirty layout，从而避免不必要的重复 re-layout。</p></blockquote><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  RenderObject relayoutBoundary;</span><br><span class="line">  <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">    relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    relayoutBoundary = (parent <span class="keyword">as</span> RenderObject)._relayoutBoundary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _constraints = constraints;</span><br><span class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class="line">    visitChildren(_cleanChildRelayoutBoundary);</span><br><span class="line">  &#125;</span><br><span class="line">  _relayoutBoundary = relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sizedByParent) &#123;</span><br><span class="line">    performResize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  performLayout();</span><br><span class="line">  markNeedsSemanticsUpdate();</span><br><span class="line">  </span><br><span class="line">  _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>layout</code>方法是触发 Render Object 更新布局信息的主要入口点。<br>一般情况下，由父节点调用子节点的<code>layout</code>方法来更新其整体布局。<br><code>RenderObject</code>的子类不应重写该方法，可按需重写<code>performResize</code>或/和<code>performLayout</code>方法。</p><p>当前 Render Object 的布局受到<code>layout</code>方法参数<code>constraints</code>的约束。<br><img src="/img/LayputDataFlow.png" width="60%" height="60%"><br>如上图，『 Render Object Tree 』的 layout 是一次深度优先遍历的过程。<br>优先 layout 子节点，之后 layout 父节点。<br>父节点向子节点传递 layout constraints，子节点在 layout 时需遵守这些约束。<br>作为子节点 layout 的结果，父节点在 layout 时可以使用子节点的 size。</p><p>在上述<code>layout</code>代码第<code>19~21</code>行，若<code>sizedByParent</code>为<code>true</code>，则调用<code>performResize</code>来计算该 Render Object 的 size。</p><p><code>sizedByParent</code>为<code>true</code>的 Render Object 需重写<code>performResize</code>方法，在该方法中仅根据<code>constraints</code>来计算 size。<br>如<code>RenderBox</code>中定义的<code>performResize</code>的默认行为：取<code>constraints</code>约束下的最小 size：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> performResize() &#123;</span><br><span class="line">  <span class="comment">// default behavior for subclasses that have sizedByParent = true</span></span><br><span class="line">  size = constraints.smallest;</span><br><span class="line">  <span class="keyword">assert</span>(size.isFinite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若父节点 layout 依赖子节点的 size，在调用<code>layout</code>方法时需将<code>parentUsesSize</code>参数设为<code>true</code>。<br>因为，在这种情况下若子节点 re-layout 导致其 size 发生变化，需要及时通知父节点，父节点也需要 re-layout (即 layout dirty 范围需要向上传播)。<br>这一切都是通过上节介绍过的 Relayout Boundary 来实现。</p><h2 id="performLayout"><a href="#performLayout" class="headerlink" title="performLayout"></a>performLayout</h2><p>本质上，<code>layout</code>是一个模板方法，具体的布局工作由<code>performLayout</code>方法完成。<br><code>RenderObject#performLayout</code>是一个抽象方法，子类需重写。</p><p>关于<code>performLayout</code>有几点需要注意：</p><ul><li>该方法由<code>layout</code>方法调用，在需要 re-layout 时应调用<code>layout</code>方法，而不是<code>performLayout</code>；</li><li>若<code>sizedByParent</code>为<code>true</code>，则该方法不应改变当前 Render Object 的 size ( 其 size 由<code>performResize</code>方法计算)；</li><li>若<code>sizedByParent</code>为<code>false</code>，则该方法不仅要执行 layout 操作，还要计算当前 Render Object 的 size；</li><li>在该方法中，需对其所有子节点调用<code>layout</code>方法以执行所有子节点的 layout 操作，如果当前 Render Object 依赖子节点的布局信息，需将<code>parentUsesSize</code>参数设为<code>true</code>。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderFlex</span></span><br><span class="line"><span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">  RenderBox child = firstChild;</span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> FlexParentData childParentData = child.parentData;</span><br><span class="line">    BoxConstraints innerConstraints = BoxConstraints(minHeight: constraints.maxHeight, maxHeight: constraints.maxHeight);</span><br><span class="line">    child.layout(innerConstraints, parentUsesSize: <span class="keyword">true</span>);</span><br><span class="line">    child = childParentData.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  size = constraints.constrain(Size(idealSize, crossSize));</span><br><span class="line">  </span><br><span class="line">  child = firstChild;</span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> FlexParentData childParentData = child.parentData;</span><br><span class="line">    <span class="built_in">double</span> childCrossPosition = crossSize / <span class="number">2.0</span> - _getCrossSize(child) / <span class="number">2.0</span>;</span><br><span class="line">    childParentData.offset = Offset(childMainPosition, childCrossPosition);</span><br><span class="line">    child = childParentData.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码片段截取自<code>RenderFlex</code>，可以看到它大概做了3件事：</p><ul><li>对所有子节点逐个调用<code>layout</code>方法；</li><li>计算当前 Render Object 的 size；</li><li>将与子节点布局有关的信息存储到相应子节点的<code>parentData</code>中。</li></ul><blockquote><p><code>RenderFlex</code>继承自<code>RenderBox</code>，是常用的<code>Row</code>、<code>Column</code>对应的 Render Object。</p></blockquote><h1 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h1><hr><p>与<code>markNeedsLayout</code>相似，当 Render Object 需要重新绘制 (paint dirty) 时通过<code>markNeedsPaint</code>方法上报给<code>PipelineOwner</code>。</p><h2 id="markNeedsPaint"><a href="#markNeedsPaint" class="headerlink" title="markNeedsPaint"></a>markNeedsPaint</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">  <span class="keyword">if</span> (isRepaintBoundary) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_layer <span class="keyword">is</span> OffsetLayer);</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner._nodesNeedingPaint.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    parent.markNeedsPaint();</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>markNeedsPaint</code>内部逻辑与<code>markNeedsLayout</code>都非常相似：</p><ul><li>若当前 Render Object 是 Repaint Boundary，则将其添加到<code>PipelineOwner#_nodesNeedingPaint</code>中，Paint request 也随之结束；</li><li>否则，Paint request 向父节点传播，即需要 re-paint 的范围扩大到父节点(这是一个递归的过程)；</li><li>有一个特例，那就是『 Render Object Tree 』的根节点，即 RenderView，它的父节点为 nil，此时只需调用<code>PipelineOwner#requestVisualUpdate</code>即可。</li></ul><blockquote><p><code>PipelineOwner#_nodesNeedingPaint</code>收集的所有 Render Object 都是 Repaint Boundary。</p></blockquote><h2 id="Repaint-Boundary"><a href="#Repaint-Boundary" class="headerlink" title="Repaint Boundary"></a>Repaint Boundary</h2><p>对 Repaint Boundary 从上面<code>markNeedsPaint</code>的实现可略知一二，<br>若某 Render Object 是 Repaint Boundary，其会切断 re-Paint request 向父节点传播。</p><p>更直白点，Repaint Boundary 使得 Render Object 可以独立于父节点进行绘制，<br>否则当前 Render Object 会与父节点绘制在同一个 layer 上。<br>总结一下，Repaint Boundary 有以下特点：</p><ul><li>每个 Repaint Boundary 都有一个独属于自己的 OffsetLayer (ContainerLayer)，其自身及子孙节点的绘制结果都将 attach 到以该 layer 为根节点的子树上；</li><li>每个 Repaint Boundary 都有一个独属于自己的 PaintingContext (包括背后的 Canvas)，从而使得其绘制与父节点完全隔离开。</li></ul><p><img src="/img/RepaintBoundary.png" width="100%" height="100%"><br>如上图，由于<code>Root</code>/<code>RA</code>/<code>RC</code>/<code>RG</code>/<code>RI</code>是 Repaint Boundary，所以它们都有对应的 OffsetLayer。<br>同时，由于每个 Repaint Boundary 都有属于自己的 PaintingContext，所以它们都有对应的 PictureLayer，用于呈现具体的绘制结果。<br>对于那些不是 Repaint Boundary 的节点，将会绘制到最近的 Repaint Boundary 祖先节点提供的 PictureLayer 上。</p><blockquote><p>Repaint Boundary 会影响兄弟节点的绘制，如由于<code>RC</code>是 Repaint Boundary，导致<code>RB</code>、<code>RD</code>被绘制到不同的 PictureLayer 上。</p></blockquote><blockquote><p>实现中，『 Layer Tree 』往往会比上图所示更复杂，由于每个 Render Object 在绘制过程中都可以自主引入更多的 layer。</p></blockquote><p>Repaint Boundary 的目标是优化性能，但从上面的讨论我们也可以看出 Repaint Boundary 会增加『 Layer Tree 』的复杂度。<br>因此，Repaint Boundary 并不是越多越好。<br>只适用于那些需要频繁重绘的场景，如视频。</p><blockquote><p>Flutter Framework 为开发者预定义了<code>RepaintBoundary</code> widget，其继承自<code>SingleChildRenderObjectWidget</code>，在有需要时我们可以通过<code>RepaintBoundary</code> widget 来添加 Repaint Boundary。</p></blockquote><h2 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</span><br></pre></td></tr></table></figure><p>抽象基类<code>RenderObject</code>中的<code>paint</code>是个空方法，需要子类重写。<br><code>paint</code>方法主要有2项任务：</p><ul><li><p>当前 Render Object 本身的绘制，如：<code>RenderImage</code>，其<code>paint</code>方法主要职责就是 image 的渲染</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  paintImage(</span><br><span class="line">    canvas: context.canvas,</span><br><span class="line">    rect: offset &amp; size,</span><br><span class="line">    image: _image,</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>绘制子节点，如：<code>RenderTable</code>，其<code>paint</code>方法主要职责是依次对每个子节点调用<code>PaintingContext#paintChild</code>方法进行绘制：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; _children.length; index += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderBox child = _children[index];</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> BoxParentData childParentData = child.parentData;</span><br><span class="line">      context.paintChild(child, childParentData.offset + offset);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="串起来"><a href="#串起来" class="headerlink" title="串起来"></a>串起来</h2><p><img src="/img/RenderObject-Paint-Line.png" alt=""><br>下面我们将整个绘制流程串一串，如上图：</p><h3 id="PipelineOwner-flushPaint"><a href="#PipelineOwner-flushPaint" class="headerlink" title="PipelineOwner#flushPaint"></a>PipelineOwner#flushPaint</h3><p>当新一帧开始时，会触发<code>PipelineOwner#flushPaint</code>方法，进而对收集的所有『 paint-dirty Render Obejcts 』进行 re-paint：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushPaint() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class="line">      _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class="line">      <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</span><br><span class="line">        <span class="keyword">assert</span>(node._layer != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (node._needsPaint &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">          PaintingContext.repaintCompositedChild(node);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="PaintingContext-repaintCompositedChild"><a href="#PaintingContext-repaintCompositedChild" class="headerlink" title="PaintingContext#repaintCompositedChild"></a>PaintingContext#repaintCompositedChild</h3><p><code>PaintingContext#repaintCompositedChild</code>是一个非常重要的方法，一是为『 paint-dirty Render Obejcts 』创建 Layer (若没有)、二是为 RenderObject 的绘制准备<code>context</code>并发起绘制流程：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _repaintCompositedChild(</span><br><span class="line">  RenderObject child, &#123;</span><br><span class="line">  <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span>,</span><br><span class="line">  PaintingContext childContext,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(child.isRepaintBoundary);</span><br><span class="line">  OffsetLayer childLayer = child._layer;</span><br><span class="line">  <span class="keyword">if</span> (childLayer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    child._layer = childLayer = OffsetLayer();</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span>(childLayer <span class="keyword">is</span> OffsetLayer);</span><br><span class="line">    childLayer.removeAllChildren();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在正常的绘制流程中通过参数传递过来的 childContext 都是 null</span></span><br><span class="line">  <span class="comment">// 因此，此处总是会创建新的 PaintingContext</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class="line">  child._paintWithContext(childContext, Offset.zero);</span><br><span class="line"></span><br><span class="line">  childContext.stopRecordingIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="RenderObject-paintWithContext"><a href="#RenderObject-paintWithContext" class="headerlink" title="RenderObject#_paintWithContext"></a>RenderObject#_paintWithContext</h3><p><code>RenderObject#_paintWithContext</code>逻辑比较简单，主要就是调用<code>paint</code>方法；<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_needsLayout)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  _needsPaint = <span class="keyword">false</span>;</span><br><span class="line">  paint(context, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>paint</code>方法正如上节所讲，通过<code>Canvas#draw***</code>系列方法进行具体的绘制操作，对于子节点(若有)调用<code>PaintingContext#paintChild</code>方法；</p><h3 id="PaintingContext-paintChild"><a href="#PaintingContext-paintChild" class="headerlink" title="PaintingContext#paintChild"></a>PaintingContext#paintChild</h3><p>对于当前绘制子节点，若是 Repaint Boundary，则需要在独立的 layer 上进行绘制，<br>否则直接调用子节点的<code>_paintWithContext</code>方法在当前上下文(paint context)中绘制：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paintChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child.isRepaintBoundary) &#123;</span><br><span class="line">    stopRecordingIfNeeded();</span><br><span class="line">    _compositeChild(child, offset);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    child._paintWithContext(<span class="keyword">this</span>, offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面重点分析对 Repaint Boundary 的处理，如上<code>paintChild</code>所示，首先会调用<code>PaintingContext#stopRecordingIfNeeded</code>来停止当前的绘制工作：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> stopRecordingIfNeeded() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_isRecording)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  _currentLayer.picture = _recorder.endRecording();</span><br><span class="line">  _currentLayer = <span class="keyword">null</span>;</span><br><span class="line">  _recorder = <span class="keyword">null</span>;</span><br><span class="line">  _canvas = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>stopRecordingIfNeeded</code>首先将当前绘制结果保存到<code>_currentLayer.picture</code>中，之后对上下文做一些清理。<br>将<code>_currentLayer</code>置为 null，初看感觉难于理解，保存在<code>_currentLayer.picture</code>中的绘制结果且不是就丢了？<br>其实，<code>_currentLayer</code>早在<code>_startRecording</code>方法中就被添加到『 Layer Tree 』上，这里只是将<code>PaintingContext</code>中的引用置为 null 而以。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _startRecording() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(!_isRecording);</span><br><span class="line">  _currentLayer = PictureLayer(estimatedBounds);</span><br><span class="line">  _recorder = ui.PictureRecorder();</span><br><span class="line">  _canvas = Canvas(_recorder);</span><br><span class="line">  _containerLayer.append(_currentLayer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于已经将<code>_canvas</code>置为 null 了，下次使用时会触发对<code>_startRecording</code>方法的调用：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Canvas <span class="keyword">get</span> canvas &#123;</span><br><span class="line">  <span class="keyword">if</span> (_canvas == <span class="keyword">null</span>)</span><br><span class="line">    _startRecording();</span><br><span class="line">  <span class="keyword">return</span> _canvas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="PaintingContext-compositeChild"><a href="#PaintingContext-compositeChild" class="headerlink" title="PaintingContext#_compositeChild"></a>PaintingContext#_compositeChild</h3><p>在<code>_compositeChild</code>中，通过<code>repaintCompositedChild</code>对子节点发起新一轮的绘制，并将绘制结果(<code>child._layer</code>)添加到『 Layer Tree 』中：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _compositeChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(!_isRecording);</span><br><span class="line">  <span class="keyword">assert</span>(child.isRepaintBoundary);</span><br><span class="line">  <span class="keyword">assert</span>(_canvas == <span class="keyword">null</span> || _canvas.getSaveCount() == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  repaintCompositedChild(child, debugAlsoPaintedParent: <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> OffsetLayer childOffsetLayer = child._layer;</span><br><span class="line">  childOffsetLayer.offset = offset;</span><br><span class="line">  appendLayer(child._layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>整个绘制过程其实就是对『 RenderObject Tree 』进行深度遍历的过程；<br>Repaint Boundary 会独立于父节点进行绘制，因此需要独立的 ContainerLayer(OffsetLayer) 以及 PaintingContext。</p><h1 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h1><hr><p>下面我们简单的分析一下，一个 Flutter App 是怎么跑起来的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..scheduleAttachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runApp</code>是 Flutter 项目的入口点，完成 Binding 的初始化、attach root widget、安排首帧的调度。</p><p><img src="/img/RenderView-create.png" alt=""><br>如上图，在<code>RendererBinding#initInstances</code>中会创建『 RenderObject Tree 』的根节点：<code>RenderView</code>。</p><p>如下代码，在<code>RenderView</code>初始化过程中为首帧渲染作准备，『 Layer Tree 』根节点也是在此过程中创建的。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderView</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> prepareInitialFrame() &#123;</span><br><span class="line">  scheduleInitialLayout();</span><br><span class="line">  scheduleInitialPaint(_updateMatricesAndCreateNewRootLayer());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Layer _updateMatricesAndCreateNewRootLayer() &#123;</span><br><span class="line">  _rootTransform = configuration.toMatrix();</span><br><span class="line">  <span class="keyword">final</span> ContainerLayer rootLayer = TransformLayer(transform: _rootTransform);</span><br><span class="line">  rootLayer.attach(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> rootLayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderObject</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> scheduleInitialLayout() &#123;</span><br><span class="line">  _relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">  owner._nodesNeedingLayout.add(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> scheduleInitialPaint(ContainerLayer rootLayer) &#123;</span><br><span class="line">  _layer = rootLayer;</span><br><span class="line">  owner._nodesNeedingPaint.add(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图，在<code>WidgetsFlutterBinding#scheduleAttachRootWidget</code>-&gt;<code>WidgetsFlutterBinding#attachRootWidget</code>调用链上会创建 Root Widget：<code>RenderObjectToWidgetAdapter</code>。</p><p><img src="/img/attachRootWidget.png" alt=""></p><p>在<code>RenderObjectToWidgetAdapter#attachToRenderTree</code>方法中『 Element Tree 』的根节点<code>RenderObjectToWidgetElement</code>被创建出来。<br>至此：</p><ul><li>Root Widget(<code>RenderObjectToWidgetAdapter</code>)</li><li>『 Element Tree 』的根节点(<code>RenderObjectToWidgetElement</code>)</li><li>『 RenderObject Tree 』的根节点(<code>RenderView</code>)</li><li>『 Layer Tree 』的根节点(<code>TransformLayer</code>)</li></ul><p>创建完成。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderObjectToWidgetAdapter</span></span><br><span class="line">RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt; element ]) &#123;</span><br><span class="line"> owner.lockState(() &#123;</span><br><span class="line">   element = createElement();</span><br><span class="line">   element.assignOwner(owner);</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> owner.buildScope(element, () &#123;</span><br><span class="line">   element.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// This is most likely the first time the framework is ready to produce</span></span><br><span class="line"> <span class="comment">// a frame. Ensure that we are asked for one.</span></span><br><span class="line"> SchedulerBinding.instance.ensureVisualUpdate();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RenderObjectToWidgetElement&lt;T&gt; createElement() =&gt; RenderObjectToWidgetElement&lt;T&gt;(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>上述代码第<code>9</code>行，对 Root Element 进行挂载(mount)。<br>随之，『 Element Tree 』被逐步创建出来。</p><blockquote><p>关于『 Element Tree 』创建过程更详细的分析可参看<a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">『深入浅出 Flutter Framework 之 Element』</a>一文</p></blockquote><p><img src="/img/RenderObjectToWidgetElement-mount.png" alt=""><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderObjectToWidgetAdapter</span></span><br><span class="line"><span class="keyword">void</span> _rebuild() &#123;</span><br><span class="line">  _child = updateChild(_child, widget.child, _rootChildSlot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>随着『 Element Tree 』的构建，『 RenderObject Tree 』也被创建出来。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderObjectElement</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><hr><p>本文对 RenderObject 生命周期中几个重要节点：创建、布局、绘制等作了简要介绍。<br>对一些重要概念，如：Relayout Boundary、Repaint Boundary 也进行了较详细的分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是『 深入浅出 Flutter Framework 』系列文章的第七篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://zxfcumtcs.github.io/tags/flutter/"/>
    
      <category term="移动开发" scheme="http://zxfcumtcs.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨平台" scheme="http://zxfcumtcs.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>『码』出高质量</title>
    <link href="http://zxfcumtcs.github.io/2021/01/02/HighQualityCode/"/>
    <id>http://zxfcumtcs.github.io/2021/01/02/HighQualityCode/</id>
    <published>2021-01-02T03:36:56.000Z</published>
    <updated>2021-01-17T10:16:58.414Z</updated>
    
    <content type="html"><![CDATA[<p>本文从易理解、可维护、可扩展三个维度简要介绍了对高质量代码的理解。<br>同时，提出了一种新的 GUI 模式：MVVS。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>个人认为，高质量的代码首先应该是『简单的』。<br>『简单』又可以从以下三个维度去度量：</p><ul><li>易理解</li><li>可维护</li><li>可扩展</li></ul><p>本文将从上述三点展开讨论，谈谈我个人的理解。</p><h1 id="易理解"><a href="#易理解" class="headerlink" title="易理解"></a>易理解</h1><hr><p>高质量的代码一定是易于理解的代码，读起来应该像言情小说，而不是诘诎的文言文。<br>高质量的代码可以是优雅的，但一定不是炫技的。<br>高质量的代码应该是深入浅出的，尽量用简单、朴实的方式去表达。</p><p>易理解面向的是整个团队，而不是写代码的那个人。<br>易理解是团队高效、无缝协作的基础。</p><p>影响代码可理解性的因素有很多，比如：</p><ul><li><h2 id="『良好命名』"><a href="#『良好命名』" class="headerlink" title="『良好命名』"></a><span style="border-bottom:3px double black;"><b>『良好命名』</b></span></h2><p>   好的命名即是成功的一半，也是最具挑战性的事情之一；<br>   总的原则就是体现『做什么』，而不是『怎么做』；<br>   在阅读优秀开源代码以及系统API时多留意、多思考。</p></li><li><h2 id="『清晰结构』"><a href="#『清晰结构』" class="headerlink" title="『清晰结构』"></a><span style="border-bottom:3px double black;">『清晰结构』</span></h2><p>  <i> ( 这里指的是代码的组织结构 ) </i><br>  相关代码组织在一起，如：<code>init</code>与<code>deinit</code>/<code>dealloc</code>、UIViewController 生命周期方法<code>viewDidLoad</code>、<code>viewWillAppear</code>、<code>viewDidAppear</code>等；<br>  不同组织间用空行隔开；<br>  或者通过 Category、Extension 的方式来组织。</p></li><li><h2 id="『合理抽象』"><a href="#『合理抽象』" class="headerlink" title="『合理抽象』"></a><span style="border-bottom:3px double black;">『合理抽象』</span></h2><p>  抽象的关键是隐藏细节(『细节是魔鬼』)；<br>  在我们不关心具体细节时能很容易地忽略细节、抓住重点、抓住主干；<br>  抽象存在于每个层级：变量、方法、类、模块。</p></li><li><h2 id="『线性逻辑』"><a href="#『线性逻辑』" class="headerlink" title="『线性逻辑』"></a><span style="border-bottom:3px double black;">『线性逻辑』</span></h2><p>  每个实体 (变量、方法、类、模块) 在不同的层级上都只围绕一件事展开 –『高内聚』;<br>  模块内部的类、类内部的方法、方法内部的语句尽量都能通过线性的方式串连起来；<br>  而如果它们间形成的是一张网或离散的点都是坏代码的味道 –『低内聚』；<br>  如，类内部存在大量不相关的方法，方法内部存在过多的<code>if</code>、<code>switch</code>语句。一个类动辄几千行、一个方法动辄几百行，此时就值得我们高度警惕；<br>  很明显，线性的逻辑比网状的逻辑更易于理解。</p></li><li><h2 id="『最小依赖』"><a href="#『最小依赖』" class="headerlink" title="『最小依赖』"></a><span style="border-bottom:3px double black;">『最小依赖』</span></h2><p>  <i>( 依赖可以从两个角度来度量：依赖的多少以及强弱 )</i><br>  依赖肯定是越少越好 –『低耦合』；<br>  过多的依赖无疑会增加代码的复杂性，往往也是代码设计出问题的一个信号；<br>  提高内聚、面向接口编程等都是降低依赖的有效方式；<br>  同时，依赖关系越弱越好，继承无疑是最先考虑到的代码复用方式，但是继承也是最强的一种依赖、耦合关系。<br>  代码复用，应优先考虑组合。</p></li><li><h2 id="『精简体积』"><a href="#『精简体积』" class="headerlink" title="『精简体积』"></a><span style="border-bottom:3px double black;">『精简体积』</span></h2><p>  简单讲，就是无用代码及时删除；<br>  在阅读代码时经常会遇到一些莫名其妙的逻辑，经过一番调查，发现已是废弃的代码；<br>  无形中增加了理解成本，并且随着时间推移，后浪们也不敢去删这些代码，最终越积越多。</p></li><li><h2 id="『朴实表述』"><a href="#『朴实表述』" class="headerlink" title="『朴实表述』"></a><span style="border-bottom:3px double black;">『朴实表述』</span></h2><p>  正如名言：代码首先是写给人看的，其次才是让机器执行的；<br>  因此，尽量用平易、朴实的方式去描述、去表达，让大家都能『看得懂』；<br>  总之，好的代码一定是简单的、清晰的。</p></li></ul><p>易理解是高质量代码最基础的要求，上述只是影响代码易理解性的几个小点，更多的需要我们在实际编码过程中不断思考总结。</p><blockquote><p>在<a href="https://zxfcumtcs.github.io/2016/03/26/HighQualityMobileDevelopment/">『 浅谈高质量移动开发 』</a>一文中对类的设计、方法的设计等有更具体的讨论，感兴趣的同学可以看看。</p></blockquote><h1 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h1><hr><p>移动端开发最主要的场景就是基于 GUI 的业务开发。<br>因此，本文谈到的可维护性也主要是围绕 GUI 流程展开。</p><p>关于 GUI 的设计模式 (MV*) 在近几年也是老生常谈的话题之一。<br>无论 GUI 模式如何演化，个人认为其核心原则未曾改变：</p><ul><li>单向数据流</li><li>数据完整性</li><li>数据驱动 UI</li></ul><h2 id="『单向数据流』"><a href="#『单向数据流』" class="headerlink" title="『单向数据流』"></a><span style="border-bottom:3px double black;">『单向数据流』</span></h2><p>无论哪种 GUI 模式，从大的方向上都可以分为两层：</p><ul><li>Domain Layer：数据层(业务逻辑)</li><li>Presentation Layer：表现层(UI)</li></ul><p>单向数据流是指『业务数据』一定是从『数据层』流向『表现层』，绝不允许反过来。<br>『表现层』可以响应 UI 事件并传递给『数据层』，<br>至于『数据层』如何处理这些事件纯属其『内政』，『表现层』无权干涉。<br><img src="/img/Domain_Presentation_Layer.png" width="70%" height="70%"></p><p>简单概括，『 单向数据流 』背后有两个『 流 』：</p><ul><li>数据流：从『 数据层 』流向『 表现层 』；</li><li>事件流：从『 表现层 』流向『 数据层 』。</li></ul><blockquote><p>关于事件，很多响应式框架会将其定义为独立的数据结构，如：<a href="https://github.com/reduxjs/redux" target="_blank" rel="noopener">Redux</a>中的<code>Action</code>、<a href="https://github.com/felangel/bloc" target="_blank" rel="noopener">BLoC</a>中的<code>Event</code>。<br>我个人认为这种设计有一个比较严重的问题：不能通过『 command + 单击 』的方式『 链式 』地阅读代码，需要通过全局搜索。<br>这严重影响了开发效率。<br>个人觉得事件可以直接是『 数据层 』暴露给『 表现层 』的接口，即有事件需要处理时，直接调用相应的接口即可。</p></blockquote><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a><strong>为什么？</strong></h3><p>我相信任何一位移动开发者对于『单向数据流』都耳熟能详，但其背后深层次的原因不见得都能说清楚。<br>首先，数据流不能从『表现层』流向『数据层』，说的到底是什么？<br>其真正的含义是『表现层』不能<strong>直接修改</strong>『数据层』的数据。为什么？</p><p>从设计的角度讲，数据管理是『数据层』的职责，『表现层』不应越俎代庖。<br>否则，『表现层』就违反了『单一职责』原则，也违反了『高内聚』的设计理念。</p><p>从现实的角度讲，『表现层』直接修改数据对于代码维护性来说是一个『灾难』。<br><strong>首先，直接后果就是可能造成『不同步』：</strong></p><ul><li>UI 刷新与数据修改不同步，数据修改后 UI 没有及时刷新；</li><li>多个 UI 场景间不同步，有的数据可能被多个业务模块所使用，如果由其中某一处直接修改，其他模块很可能无法感知到这一修改，造成不同步。<br>  如下图，Scenes1 直接修改了底层数据，但并未通知 Scenes2、Scenes3 (Scenes1 可能根本不知道 Scenes2、Scenes3 的存在)，造成数据不同步：<br><img src="/img/Domain_Mutil_Presentation_Layer.png" width="95%" height="95%"><br>『不同步』常见的后果就是在使用 TableView 时数组越界。<br>对于此类问题，我们经常是对数组访问加个保护，而很少也很难从根源上解决问题。<br>尤其是多业务场景共享数据时。因为你根本不知道是『 谁 』在『 什么时候 』修改了数据源。</li></ul><p><strong>其次，还可能引起多线程问题：</strong><br>『数据层』可能有专职的线程去管理数据，如果『表现层』擅自修改数据，很可能引发多线程问题。</p><h3 id="如何解"><a href="#如何解" class="headerlink" title="如何解"></a><strong>如何解</strong></h3><p><strong>『数据层』一定不能向『表现层』直接暴露可修改 (mutable) 的属性。</strong></p><blockquote><p>对于引用类型来说，情况可能更复杂一些。理想情况下，『数据层』返回给『表现层』的数据应该是<code>final</code>的或是深拷贝的。<br>总之，要做到『表现层』毫无直接修改底层数据的可能性。</p></blockquote><p>此时，大家可能有疑问了，即使是『表现层』通过事件触发『数据层』内部去修改数据，还是可能会引起不同步的问题。<br>对，这就需要通过『数据完整性』、『数据驱动 UI』来解决了。</p><h2 id="『数据完整性』"><a href="#『数据完整性』" class="headerlink" title="『数据完整性』"></a><span style="border-bottom:3px double black;">『数据完整性』</span></h2><p><img src="/img/MVVS_Data_Status.png" width="95%" height="95%"></p><p>数据完整性指的是数据不应该存在中间临时状态。<br>如上图左则所示，可能会导致意想不到的结果。</p><p>在需要修改时，应该对数据作整体替换，这也是我们常说的『数据不可变性』。</p><blockquote><p>在函数式编程中，所有数据都是不可变的，所有操作的结果都是生成新的数据，而不是在原有数据上作修改。</p></blockquote><p><strong>严格遵守『数据完整性』、『数据不可变性』原则，能很好地避免中间状态问题。</strong></p><h2 id="『数据驱动-UI』"><a href="#『数据驱动-UI』" class="headerlink" title="『数据驱动 UI』"></a><span style="border-bottom:3px double black;">『数据驱动 UI』</span></h2><p>底层数据发生变化后，上层 UI 如何感知并刷新？<br>总的原则就是『数据驱动 UI』<br>直白点，就是『数据层』有渠道、有方法在数据变化时能主动通知到所有关注该数据的『表现层』对象。</p><blockquote><p>看似很简单？实则很多项目都没能做到这一点。</p></blockquote><p>有没有闻到『响应式编程』的味道。<br>有同学一听到『响应式编程』就觉得很复杂，难于接受。<br>其实，我个人认为『响应式编程』并非一定要使用诸如<code>Rx*</code>、<code>ReactiveCocoa</code>或 iOS 原生的<code>KVO</code>这样的框架或技术。(它们只是一种实现手段而以)<br>其核心在于：</p><ul><li><strong>『数据层』主动通知，『表现层』被动响应；</strong></li><li><strong>数据的所有使用方都能及时感知到数据的变化。</strong></li></ul><p>因此，像 Delegate、Callback 甚至 Notification 都可以用来实现『响应式编程』。</p><blockquote><p>『响应式编程』其实就是『观察者』设计模式的一种应用场景。</p></blockquote><p>好了，我们来回顾总结一下：</p><ul><li><u><strong>『单向数据流』</strong>：保证数据的修改仅发生在『数据层』内部，这也是『数据完整性』、『数据驱动 UI』得以实现的前提；</u></li><li><u><strong>『数据完整性』</strong>：任何数据的修改都是整体替换，实现『数据不可变』的语义，避免出现数据的中间状态；</u></li><li><u><strong>『数据驱动 UI』</strong>：保证数据修改后能及时通知 UI，避免状态不同步。</u></li></ul><h2 id="MVVS"><a href="#MVVS" class="headerlink" title="MVVS"></a>MVVS</h2><p>基于『单向数据流』、『数据完整性』以及『数据驱动 UI』的原则，我们提出一种新的 GUI 模式：MVVS</p><ul><li>M：Manager，处理业务逻辑，管理业务数据，将数据转换为 ViewState 并通知上层 UI；</li><li>V：View，UIViewController/UIView，面向 ViewState 编程；</li><li>VS：ViewState，当前的 UI 状态，将『数据驱动 UI』进一步拆分：数据驱动状态、状态驱动 UI。</li></ul><blockquote><p>MVVS vs. MVVM，相当于将 MVVM 中的 VIewModel 拆分为 MVVS 中的 Manager 和 ViewState，使得各自的职责更加清晰。</p></blockquote><blockquote><p>MVVS 中的 ViewState 受 Flutter 响应式框架 <a href="https://github.com/felangel/bloc" target="_blank" rel="noopener">flutter_bloc</a> 中 state 启发。</p></blockquote><p>Manager、View、ViewState 间的关系如下图所示：<br><img src="/img/MVVS.png" width="90%" height="90%"> <img src="/img/MVVS_1.png" width="90%" height="90%"></p><h3 id="ViewState"><a href="#ViewState" class="headerlink" title="ViewState"></a>ViewState</h3><p>ViewState 代表当前的 UI 状态，为 UI 提供展示用的数据。<br>原则上，ViewState 与 View 一一对应。<br>对于过于简单的 UI 也可以没有与之对应的 ViewState。</p><p><img src="/img/ViewState.png" alt=""></p><p>如上图，与 ViewController 对应的是 Root ViewState，代表当前该模块的整体状态。<br>根据不同的状态，ViewState 可以是不同的子类型，如：LoadingViewState、ErrorViewState、EmptyViewState、LoadedViewState 等。ViewController 再根据不同的状态作出不同的响应。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>上面我们主要讲述了 GUI 架构上会影响代码可维护性的几个关键点<br>影响代码可维护性的因素还有很多，如：</p><ul><li><p><b><u>最少状态:</u></b> 在代码中经常会看到很多的状态变量，如：<code>is***</code>(<code>isFirstLoad</code>、<code>isNewUser</code>)、<code>has***</code>(<code>hasLoaded</code>)、<code>***Count</code>(<code>userCount</code>)等等。<br>  这些状态本身的维护以及其对代码整体的维护都是非常容易出问题的。<br>  是否在所有需要修改的地方都正确的修改了？<br>  修改后使用到这些状态的地方都及时通知到了？<br>  因此，状态要越少越好，能不加就不加。<br>  如，<code>***Count</code>是否可以从数据集上动态计算得到</p></li><li><p><b><u>最小权限:</u></b> 无论是模块还是类暴露的接口都应遵守最小权限原则<br>  在具体开发过程中可以通过『 依赖倒置 』原则，让接口需求方提出接口需求，避免由实现方直接提供接口而无意中暴露过多细节。<br>  具体可以参看<a href="https://zxfcumtcs.github.io/2018/10/04/solid/">『 面向对象设计原则『SOLID』在开发中的应用 』</a></p></li><li><p><b><u>写纯函数:</u></b>  纯函数几乎没有外界依赖，其在可维护性、易理解上有天然优势。<br>  一般类方法都有纯函数特性，因此，能写类方法的时候就不要写实例方法。<br>  在<a href="https://zxfcumtcs.github.io/2019/11/17/functional/">『 函数式思维 』</a>一文中对函数式编程有过简单讨论</p></li></ul><h1 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h1><hr><p>『唯一不变的就是变化』<br>面对变化，我们唯以积极心态对之。<br>因此，代码的可扩展性也是我们需要重点思考的问题之一。<br>『 SOLID 』中的『 O — OCP，开放-封闭原则 』，就是用于指导可扩展性的原则之一。</p><blockquote><p>OCP：『 对扩展开放，对修改封闭 』。</p></blockquote><p>强调『可扩展性』就是要求我们写『活代码』。<br>在平时 Code Review 时，我经常开玩笑地说『你这个代码写的太死』。</p><p>23 种设计模式中的『 策略模式 』、『 模板方法 』都是用于指导提升可扩展性的方法。</p><h2 id="『-策略模式-』"><a href="#『-策略模式-』" class="headerlink" title="『 策略模式 』"></a>『 策略模式 』</h2><p>提高代码可扩展性最有效的方式之一就是面向接口编程。<br>在<a href="https://zxfcumtcs.github.io/2019/12/04/InterfaceBasedProgramming/">『 论面向接口编程 』</a>一文中对此有详细介绍，在此不再赘述。</p><p>在具体开发时如何写出扩展性高的代码呢？<br>『扩展性』面向的是未来，<br>因此，首先要思考的是『 什么是可能会变的 』<br>再将『 可变部分 』隔离出来，并以接口的形式去抽象它。<br><img src="/img/Strategy_Interface.png" width="60%" height="60%"><br>熟悉设计模式的同学可能已经看出来了，这其实就是『策略模式，Strategy 』。</p><p>在之前的文章中，我们也提到过，如：登录模块、多 Tab 页面都是典型的可通过『 策略模式 』来提高扩展性的场景。</p><blockquote><p>登录模块的例子在<a href="https://zxfcumtcs.github.io/2018/10/04/solid/">『 面向对象设计原则『SOLID』在开发中的应用 』</a>一文中有详细介绍<br>多 Tab 页面的例子在<a href="https://zxfcumtcs.github.io/2019/12/04/InterfaceBasedProgramming/">『 论面向接口编程 』</a>一文中有详细介绍</p></blockquote><h2 id="『-模板方法-』"><a href="#『-模板方法-』" class="headerlink" title="『 模板方法 』"></a>『 模板方法 』</h2><p>『 策略模式 』的基础是面向接口编程。<br>而『 模板方法，Template Method 』的基础是继承。<br>同样，在<a href="https://zxfcumtcs.github.io/2018/10/04/solid/">『 面向对象设计原则『SOLID』在开发中的应用 』</a>一文中对『 模板方法 』模式有过简单的介绍。<br>在<a href="https://zxfcumtcs.github.io/2018/12/22/Efficient-Development-Solutions/">『 iOS 高效开发解决方案 』</a>一文中介绍过通过『 模板方法 』模式提高 UI 组件的扩展性。</p><p>提升代码可扩展性的方法绝不仅上述 2 种模式，但其背后的思想非常重要，在平时开发时可灵活应用。</p><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><hr><p>除了上述提到的『 易理解 』、『 可维护 』、『 可扩展 』之外，还有很多点是值得我们去思考和关注的，如：</p><ul><li><strong>错误处理：</strong>如何优雅地处理错误其实非常重要，但往往被忽略。在设计接口时需要关注出错的情况；</li><li><strong>关键路径打 log：</strong>错误是无法避免的，除了在出错时给用户一个较好地提示外，我们也需要去了解出错的原因，此时 log 就显得尤为重要，要养成在关键路径打 log 的习惯。否则，用户反馈问题后，两眼一抹黑，无从下手；</li><li><strong>适时重构：</strong>重构不一定是要对代码做出『 翻天覆地 』的改变，小到对变量重命名、抽取一个方法等『 微小 』的优化都算是重构。总之，在当前代码结构已不再适应新业务需要时，就需要及时重构，切不可在原有基础上打补丁，代码的恶化往往就是从此开始的。<br>对待代码我们同样要有敬畏之心：『 勿以善小而不为，勿以恶小而为之 』。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>写出高质量的代码可谓『 功在当时，利在未来 』<br>每一位开发者都应为开发出高质量的代码也努力<br>代码设计能力的提升非一日之功，需要我们长期不断地学习、实践、思考、总结<br>优秀的书籍、优秀的开源代码我们要学习<br>糟糕的代码我们也要去反思，去总结<br>在代码上同样要做到『 勿以善小而不为，勿以恶小而为之 』</p><p>诸君共勉！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从易理解、可维护、可扩展三个维度简要介绍了对高质量代码的理解。&lt;br&gt;同时，提出了一种新的 GUI 模式：MVVS。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="代码设计" scheme="http://zxfcumtcs.github.io/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="高质量" scheme="http://zxfcumtcs.github.io/tags/%E9%AB%98%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Flutter Framework 之 PipelineOwner</title>
    <link href="http://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/"/>
    <id>http://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/</id>
    <published>2020-12-05T13:10:51.000Z</published>
    <updated>2021-09-04T15:20:09.522Z</updated>
    
    <content type="html"><![CDATA[<p>本文是『 深入浅出 Flutter Framework 』系列文章的第六篇，详细介绍了 PipelineOwner 在整个 Rendering Pipeline 中是如何协助『 RenderObject Tree 』、『 RendererBinding』以及『 Window』完成 UI 刷新。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><p>本系列文章将深入 Flutter Framework 内部逐步去分析其核心概念和流程，主要包括：<br><a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">『 深入浅出 Flutter Framework 之 Widget 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">『 深入浅出 Flutter Framework 之 BuildOwner 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">『 深入浅出 Flutter Framework 之 Element 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/">『 深入浅出 Flutter Framework 之 PaintingContext 』</a><br><a href="https://zxfcumtcs.github.io/2020/06/07/deepinto-flutter-layer/">『 深入浅出 Flutter Framework 之 Layer 』</a><br>『 深入浅出 Flutter Framework 之 PipelineOwner 』<br><a href="https://zxfcumtcs.github.io/2021/03/27/deepinto-flutter-renderobject/">『 深入浅出 Flutter Framework 之 RenderObejct 』</a><br><a href="https://zxfcumtcs.github.io/2021/08/28/deepinto-flutter-custom-renderobjectwidget/">『 深入浅出 Flutter Framework 之自定义渲染型 Widget 』</a></p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p><code>PipelineOwner</code>在 Rendering Pipeline 中起到重要作用：</p><ul><li>随着 UI 的变化而不断收集『 Dirty Render Objects 』</li><li>随之驱动 Rendering Pipeline 刷新 UI</li></ul><p>简单讲，<code>PipelineOwner</code>是『RenderObject Tree』与『RendererBinding』间的桥梁，在两者间起到沟通协调的作用。</p><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><hr><p><img src="/img/PipelineOwner.PNG" alt=""><br>如上图：</p><ul><li><code>RendererBinding</code>创建并持有<code>PipelineOwner</code>实例，Code1-第<code>8~12</code>行</li><li>同时，<code>RendererBinding</code>会创建『RenderObject Tree』的根节点，即：RenderView，并将其赋值给<code>PipelineOwner#rootNode</code>，Code1-第<code>13~24</code>行</li><li>在『RenderObject Tree』构建过程中，每插入一个新节点，就会将<code>PipelineOwner</code>实例 attach 到该节点上，即『RenderObject Tree』上所有结点共享同一个<code>PipelineOwner</code>实例，Code2-第<code>4</code>行</li></ul><figure class="highlight dart"><figcaption><span>Code1-RendererBinding#init</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码有删减，下同</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">mixin RendererBinding &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    _pipelineOwner = PipelineOwner(</span><br><span class="line">      onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">    );</span><br><span class="line">    initRenderView();</span><br><span class="line">    addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> initRenderView() &#123;</span><br><span class="line">    renderView = RenderView(configuration: createViewConfiguration(), <span class="built_in">window</span>: <span class="built_in">window</span>);</span><br><span class="line">    renderView.prepareInitialFrame();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> renderView(RenderView value) &#123;</span><br><span class="line">    _pipelineOwner.rootNode = value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><figcaption><span>Code2-RenderObject#adoptChild</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> adoptChild(covariant AbstractNode child) &#123;</span><br><span class="line">  child._parent = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (attached)</span><br><span class="line">    child.attach(_owner);</span><br><span class="line">  redepthChild(child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> attach(covariant <span class="built_in">Object</span> owner) &#123;</span><br><span class="line">  _owner = owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>RendererBinding</code>是 mixin，其背后真实的类是<code>WidgetsFlutterBinding</code></p></blockquote><p>如上所述，正常情况下在 Flutter 运行过程中只有一个<code>PipelineOwner</code>实例，并由<code>RendererBinding</code>持有，用于管理所有『 on-screen RenderObjects 』。<br>然而，如果有『 off-screen RenderObjects 』，则可以创建新的<code>PipelineOwner</code>实例来管理它们。<br>『on-screen PipelineOwner』与 『 off-screen PipelineOwner 』完全独立，后者需要创建者自己维护、驱动。</p><blockquote><p><code>mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable</code><br>如上，<code>RendererBinding</code>要求其附属类 mixin <code>BindingBase</code>、<code>ServicesBinding</code>、<code>SchedulerBinding</code>、<code>GestureBinding</code>、<code>SemanticsBinding</code>以及<code>HitTestable</code>，为了描述方便，文本提到的<code>RendererBinding</code>上的方法也可能来自于其他几个 Binding。</p></blockquote><h1 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h1><hr><h2 id="Dirty-RenderObjects"><a href="#Dirty-RenderObjects" class="headerlink" title="Dirty RenderObjects"></a>Dirty RenderObjects</h2><p>Render Object 有4种『 Dirty  State』 需要 PipelineOwner 去维护：</p><ul><li>Needing Layout：Render Obejct 需要重新 layout</li><li>Needing Compositing Bits Update：Render Obejct 合成标志位(Compositing)有变化</li><li>Needing Paint：Render Obejct 需要重新绘制</li><li>Needing Semantics：Render Object 辅助信息有变化</li></ul><p><img src="/img/RenderObject_PipelineOwner_RendererBinding.png" alt=""></p><p>如上图：</p><ul><li>当 RenderObject 需要重新 layout 时，调用<code>markNeedsLayout</code>方法，该方法会将当前 RenderObject 加入 <code>PipelineOwner#_nodesNeedingLayout</code>或传给父节点去处理；</li><li>当 RenderObject 的 Compositing Bits 有变化时，调用<code>markNeedsCompositingBitsUpdate</code>方法，该方法会将当前 RenderObject 加入 <code>PipelineOwner#_nodesNeedingCompositingBitsUpdate</code>或传给父节点去处理；</li><li>当 RenderObject 需要重新 paint 时，调用<code>markNeedsPaint</code>方法，该方法会将当前 RenderObject 加入<code>PipelineOwner#_nodesNeedingPaint</code>或传给父节点处理；</li><li>当 RenderObject 的辅助信息(Semantics)有变化时，调用<code>markNeedsSemanticsUpdate</code>方法，该方法会将当前 RenderObject 加入 <code>PipelineOwner#_nodesNeedingSemantics</code>或传给父节点去处理</li></ul><p>上述就是 PipelineOwner 不断收集『 Dirty RenderObjects 』的过程。</p><blockquote><p>RenderObject 内部的逻辑会在后续文章中详细分析。</p></blockquote><h2 id="Request-Visual-Update"><a href="#Request-Visual-Update" class="headerlink" title="Request Visual Update"></a>Request Visual Update</h2><p>上述4个<code>markNeeds*</code>方法，除了<code>markNeedsCompositingBitsUpdate</code>，其他方法最后都会调用<code>PipelineOwner#requestVisualUpdate</code>。<br>之所以<code>markNeedsCompositingBitsUpdate</code>不会调用<code>PipelineOwner#requestVisualUpdate</code>，是因为其不会单独出现，一定是伴随其他3个之一一起出现的。</p><p>如上图，随着<code>PipelineOwner#requestVisualUpdate</code>-&gt;<code>RendererBinding#scheduleFrame</code>-&gt;<code>Window#scheduleFrame</code>调用链，UI 需要刷新的信息最终传递到了 Engine 层。<br>具体讲，<code>Window#scheduleFrame</code>主要是向 Engine 请求在下一帧刷新时调用<code>Window#onBeginFrame</code>以及<code>Window#onDrawFrame</code>方法。</p><blockquote><p><code>Window#onBeginFrame</code>、<code>Window#onDrawFrame</code>本质上是 RendererBinding 向其注入的两个回调(<code>_handleBeginFrame</code>、<code>_handleDrawFrame</code>)：<br><figure class="highlight dart"><figcaption><span>Code3-SchedulerBinding</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span> ensureFrameCallbacksRegistered() &#123;</span><br><span class="line">  <span class="built_in">window</span>.onBeginFrame ??= _handleBeginFrame;</span><br><span class="line">  <span class="built_in">window</span>.onDrawFrame ??= _handleDrawFrame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="Handle-Draw-Frame"><a href="#Handle-Draw-Frame" class="headerlink" title="Handle Draw Frame"></a>Handle Draw Frame</h2><p><img src="/img/RendererBinding_handleDrawFrame.png" alt=""><br>如上图，Engine 在接收到 UI 需要更新后，在下一帧刷新时会调用<code>Window#onDrawFrame</code>，通过提前注册好的<code>PersistentFrameCallback</code>，最终调用到<code>RendererBinding#drawFrame</code>方法：<br><figure class="highlight dart"><figcaption><span>Code4-RendererBinding#drawFrame</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">  pipelineOwner.flushLayout();</span><br><span class="line">  pipelineOwner.flushCompositingBits();</span><br><span class="line">  pipelineOwner.flushPaint();</span><br><span class="line">  renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">  pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，<code>RendererBinding#drawFrame</code>依次调用<code>PipelineOwner</code>的<code>flushLayout</code>、<code>flushCompositingBits</code>、<code>flushPaint</code>以及<code>flushSemantics</code>方法，来处理对应状态下的 RenderObject。</p><h3 id="Flush-Layout"><a href="#Flush-Layout" class="headerlink" title="Flush Layout"></a>Flush Layout</h3><figure class="highlight dart"><figcaption><span>Code5-PipelineOwner#flushLayout</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushLayout() &#123;</span><br><span class="line">  <span class="keyword">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line">    _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class="line">    <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._needsLayout &amp;&amp; node.owner == <span class="keyword">this</span>)</span><br><span class="line">        node._layoutWithoutResize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，<code>PipelineOwner</code>对于收集到的『 Needing Layout RenderObjects 』按其在『 RenderObject Tree 』上的深度升序排序，主要是为了避免子节点重复 Layout (因为父节点 layout 时，也会递归地对子树进行 layout)；<br>其次，对排好序的且满足条件的 RenderObjects 依次调用<code>_layoutWithoutResize</code>来执行 layout 操作。</p><blockquote><p>在父节点 layout 完成时，其所有子节点也 layout 完成，它们的<code>_needsLayout</code>标志会被置为<code>flase</code>，因此在 Code5 中需要第<code>6</code>行的判断，避免重复 layout。</p></blockquote><h3 id="Flush-Compositing-Bits"><a href="#Flush-Compositing-Bits" class="headerlink" title="Flush Compositing Bits"></a>Flush Compositing Bits</h3><figure class="highlight dart"><figcaption><span>Code6-PipelineOwner#flushCompositingBits</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushCompositingBits() &#123;</span><br><span class="line">  _nodesNeedingCompositingBitsUpdate.sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth);</span><br><span class="line">  <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> _nodesNeedingCompositingBitsUpdate) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node._needsCompositingBitsUpdate &amp;&amp; node.owner == <span class="keyword">this</span>)</span><br><span class="line">      node._updateCompositingBits();</span><br><span class="line">  &#125;</span><br><span class="line">  _nodesNeedingCompositingBitsUpdate.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，先对『 Needing Compositing Bits RenderObjects 』排序，再调用<code>RenderObjects#_updateCompositingBits</code></p><h3 id="Flush-Paint"><a href="#Flush-Paint" class="headerlink" title="Flush Paint"></a>Flush Paint</h3><figure class="highlight dart"><figcaption><span>Code7-PipelineOwner#flushPaint</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushPaint() &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class="line">  _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class="line">  <span class="comment">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class="line">  <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node._needsPaint &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._layer.attached) &#123;</span><br><span class="line">          PaintingContext.repaintCompositedChild(node);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Paint 操作来说，父节点需要用到子节点绘制的结果，故子节点需要先于父节点被绘制。<br>因此，不同于前两个 flush 操作，此时需要对『 Needing Paint RenderObjects 』按深度降序排序。<br>如下图，在<a href="https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/">深入浅出 Flutter Framework 之 PaintingContext</a>一文中详细分析了从<code>PipelineOwner#flushPaint</code>到<code>PaintingContext</code>内部操作的过程，在此不再赘述。<br><img src="/img/PaintingPipeline.png" alt=""></p><h3 id="Flush-Semantics"><a href="#Flush-Semantics" class="headerlink" title="Flush Semantics"></a>Flush Semantics</h3><figure class="highlight dart"><figcaption><span>Code8-PipelineOwner#flushSemantics</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushSemantics() &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; nodesToProcess = _nodesNeedingSemantics.toList()</span><br><span class="line">    ..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth);</span><br><span class="line">  _nodesNeedingSemantics.clear();</span><br><span class="line">  <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> nodesToProcess) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node._needsSemanticsUpdate &amp;&amp; node.owner == <span class="keyword">this</span>)</span><br><span class="line">      node._updateSemantics();</span><br><span class="line">  &#125;</span><br><span class="line">  _semanticsOwner.sendSemanticsUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Flush Semantics 所做操作与 Flush Layout 完全相似，不再赘述。</p><p>至此，PipelineOwner 相关的内容就介绍完了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>PipelineOwner 作为『 RenderObject Tree』与『 RendererBinding/Window』间的沟通协调桥梁，在整个 Rendering Pipeline 中起到重要作用。<br>在 Flutter 应用生命周期内，不断收集『 Dirty RenderObjects 』并及时通知 Engine。<br>在帧刷新时，通过来自 RendererBinding 的回调依次处理收集到的：</p><ul><li>『 Needing Layout RenderObjects 』</li><li>『 Needing Compositing Bits Update RenderObjects 』</li><li>『 Needing Paint RenderObjects 』</li><li>『 Needing Semantics RenderObjects 』</li></ul><p>最终完成 UI 的刷新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是『 深入浅出 Flutter Framework 』系列文章的第六篇，详细介绍了 PipelineOwner 在整个 Rendering Pipeline 中是如何协助『 RenderObject Tree 』、『 RendererBinding』以及『 Window』完成 UI 刷新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://zxfcumtcs.github.io/tags/flutter/"/>
    
      <category term="移动开发" scheme="http://zxfcumtcs.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨平台" scheme="http://zxfcumtcs.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Flutter Framework 之 Layer</title>
    <link href="http://zxfcumtcs.github.io/2020/06/07/deepinto-flutter-layer/"/>
    <id>http://zxfcumtcs.github.io/2020/06/07/deepinto-flutter-layer/</id>
    <published>2020-06-07T04:01:28.000Z</published>
    <updated>2021-09-04T15:20:38.858Z</updated>
    
    <content type="html"><![CDATA[<p>本文是『 深入浅出 Flutter Framework 』系列文章的第五篇，对 Layer 的类层级结构以及 Layer 的状态管理进行了简要的分析介绍。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><p>本系列文章将深入 Flutter Framework 内部逐步去分析其核心概念和流程，主要包括：<br><a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">『 深入浅出 Flutter Framework 之 Widget 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">『 深入浅出 Flutter Framework 之 BuildOwner 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">『 深入浅出 Flutter Framework 之 Element 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/">『 深入浅出 Flutter Framework 之 PaintingContext 』</a><br>『 深入浅出 Flutter Framework 之 Layer 』<br><a href="https://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/">『 深入浅出 Flutter Framework 之 PipelineOwner 』</a><br><a href="https://zxfcumtcs.github.io/2021/03/27/deepinto-flutter-renderobject/">『 深入浅出 Flutter Framework 之 RenderObejct 』</a><br><a href="https://zxfcumtcs.github.io/2021/08/28/deepinto-flutter-custom-renderobjectwidget/">『 深入浅出 Flutter Framework 之自定义渲染型 Widget 』</a></p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>前面的文章中我们介绍过在 Flutter build、layout、render 过程中会生成 3 棵树：</p><ul><li>Element Tree</li><li>RenderObject Tree</li><li>Layer Tree</li></ul><p>可以说 Layer Tree 是 Flutter Framework 最终的输出产物，之后的流程就进入到 Flutter Engine 了。<br><img src="/img/Element_RenderObject_LayerTree.png" alt=""><br>如上图：</p><ul><li>在<code>build</code>过程中，由 Element Tree 生成 RenderObject Tree (在 <a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">深入浅出 Flutter Framework 之 Element</a> 一文中介绍过只有 RenderObject_Element 才会有对应的 RenderObject)</li><li>在<code>paint</code>阶段，由 RenderObject Tree 生成 Layer Tree (在 <a href="https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/">深入浅出 Flutter Framework 之 PaintingContext</a> 一文中介绍过只有当<code>RenderObject#isRepaintBoundary</code>为<code>true</code>时才会生成独立的 Layer 节点)</li></ul><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><hr><p><img src="/img/Layer.png" alt=""></p><p>如上图，<code>Layer</code>是抽象基类，其内部实现了基本的 Layer Tree 的管理逻辑以及对渲染结果复用的控制逻辑。<br>具体的 Layer 大致可以分为2类：</p><ul><li>Container Layer：正如其名，作为 Layer 容器，用于管理一组 Layers，是唯一可以拥有 child layer 的 Layer；</li><li>非 Container Layer：真正用于承载渲染结果的 layer，在 Layer Tree 中属于叶结点，如：<code>PictureLayer</code>承载的是图片的渲染结果，<code>TextureLayer</code>承载的是纹理的渲染结果。</li></ul><h1 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h1><hr><p>抽象基类<code>Layer</code>一个非常重要的职责就是管理 Layer Tree 的状态<br>简单讲，就是控制什么情况下可以复用 engine 在前一帧渲染的结果，什么情况下需要刷新，即需要 engine 重新渲染。当然，这是出于性能考虑，避免因不必要的渲染操作而浪费资源。</p><h2 id="EngineLayer"><a href="#EngineLayer" class="headerlink" title="EngineLayer"></a>EngineLayer</h2><p>每个 Layer 实例都有一个与之对应的<code>EngineLayer</code>实例，其属于 engine 层范畴，对 framework 来说是个黑盒。可以简单理解 EngineLayer 为 engine 渲染的结果。<br><img src="/img/EngineLayer.png" alt=""></p><p>在 <a href="https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/">深入浅出 Flutter Framework 之 PaintingContext</a> 一文中介绍过的<code>SceneBuilder</code>类有一系列的<code>push</code>方法 (如：<code>pushOffset</code>、<code>pushClipRect</code>等)，这些方法的返回值即为<code>EngineLayer</code>实例。</p><p>如：<code>ColorFilterLayer#addToScene</code>方法在调用<code>SceneBuilder#pushColorFilter</code>方法时就保存了其返回的<code>engineLayer</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) &#123;</span><br><span class="line">  engineLayer = builder.pushColorFilter(colorFilter, oldLayer: _engineLayer);</span><br><span class="line">  addChildrenToScene(builder, layerOffset);</span><br><span class="line">  builder.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="needsAddToScene"><a href="#needsAddToScene" class="headerlink" title="needsAddToScene"></a>needsAddToScene</h2><p>我们知道，Layer上的内容需要借助<code>SceneBuilder</code>生成<code>Scene</code>，之后才能被渲染在屏幕上。<br>这一过程被称之为<code>addToScene</code>。</p><p>在<code>Layer</code>内有一个非常重要的变量：<code>_needsAddToScene</code>，用于记录该 Layer 自上次渲染后(<code>addToScene</code>)是否发生了变化。<br>即，该 layer 背后的 EngineLayer 是否可以复用。</p><blockquote><p>Whether this layer has any changes since its last call to [addToScene].</p></blockquote><p>在<code>Layer</code>刚初始化时，<code>_needsAddToScene</code>为<code>true</code>，在第一次调用<code>addToScene</code>后置为<code>false</code>，之后有几种情况可能会被再次置为<code>true</code>，表明该 layer需要 engine 重新渲染，如下图所示：</p><ul><li>自身发生了变化，如<code>PictureLayer#picture</code>、<code>TransformLayer#transform</code>被重新赋值；</li><li>子节点有增删；</li><li>子节点的<code>needsAddToScene</code>变为<code>true</code>；</li></ul><p><img src="/img/needsAddToScene.png" alt=""></p><blockquote><p><code>Layer#alwaysNeedsAddToScene</code>为<code>true</code>时，表示该 layer 在每帧刷新时都需要重新渲染。其对<code>_needsAddToScene</code>的影响如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="meta">@visibleForTesting</span></span><br><span class="line"><span class="keyword">void</span> updateSubtreeNeedsAddToScene() &#123;</span><br><span class="line">  _needsAddToScene = _needsAddToScene || alwaysNeedsAddToScene;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="addToScene"><a href="#addToScene" class="headerlink" title="addToScene"></a>addToScene</h2><p><img src="/img/addToScene.png" alt=""><br><code>addToScene</code>方法可以说是<code>Layer</code>中最重要的方法之一，用于将 layer 送入 engin 进行渲染。<br>由具体的子类去实现该方法，Container 类型的 Layer 与非 Container 类型的 Layer 在实现上还是有较大区别，细节在此不再赘述，感兴趣的同学可以看看源码。</p><h1 id="串起来"><a href="#串起来" class="headerlink" title="串起来"></a>串起来</h1><hr><p><img src="/img/LayerBuild.png" alt=""></p><p>如上面这张长长的图，现在要描述的一切都始于<code>RenderView.compositeFrame()</code>：</p><blockquote><p>RenderView 是 RenderObject Tree 的根节点，在每帧刷新时都会调用其<code>compositeFrame</code>方法去合成新的帧<br>RenderView 对应的 Layer 是ContainerLayer</p></blockquote><p>几个关键点：</p><ul><li><code>ContainerLayer.buildScene()</code>方法首先去更新<code>needsAddToScene</code>标志位 (对 Layer Tree 进行深度遍历)，子节点的值会影响父节点 (子节点有更新时，父节点肯定也要刷新)；</li><li>之后，调用<code>ContainerLayer.addToScene()</code>方法，该方法会对子节点进行递归操作；</li><li>注意，在<code>ContainerLayer._addToSceneWithRetainedRendering()</code>方法中，当<code>_ needsAddToScene</code>为<code>false</code>且<code>_engineLayer!=nil</code>时直接复用上次的渲染结果。</li></ul><p>好了，今天就先到这里了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是『 深入浅出 Flutter Framework 』系列文章的第五篇，对 Layer 的类层级结构以及 Layer 的状态管理进行了简要的分析介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://zxfcumtcs.github.io/tags/flutter/"/>
    
      <category term="移动开发" scheme="http://zxfcumtcs.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨平台" scheme="http://zxfcumtcs.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Flutter Framework 之 PaintingContext</title>
    <link href="http://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/"/>
    <id>http://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/</id>
    <published>2020-05-23T13:06:13.000Z</published>
    <updated>2021-09-04T15:20:25.639Z</updated>
    
    <content type="html"><![CDATA[<p>本文是『 深入浅出 Flutter Framework 』系列文章的第四篇，主要目的是为后面介绍 RenderObject 作准备。<br>文章对 PaintingContext 进行了较详细的分析，主要包括在 Rendering Pipeline 中 PaintingContext 是如何配合 RenderObject 进行绘制的，同时对一些基础概念进行了简要的介绍(如：Canvas、Picture、PictureRecorder、SceneBuilder 以及 Scene 等)。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><p>本系列文章将深入 Flutter Framework 内部逐步去分析其核心概念和流程，主要包括：<br><a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">『 深入浅出 Flutter Framework 之 Widget 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">『 深入浅出 Flutter Framework 之 BuildOwner 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">『 深入浅出 Flutter Framework 之 Element 』</a><br>『 深入浅出 Flutter Framework 之 PaintingContext 』<br><a href="https://zxfcumtcs.github.io/2020/06/07/deepinto-flutter-layer/">『 深入浅出 Flutter Framework 之 Layer 』</a><br><a href="https://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/">『 深入浅出 Flutter Framework 之 PipelineOwner 』</a><br><a href="https://zxfcumtcs.github.io/2021/03/27/deepinto-flutter-renderobject/">『 深入浅出 Flutter Framework 之 RenderObejct 』</a><br><a href="https://zxfcumtcs.github.io/2021/08/28/deepinto-flutter-custom-renderobjectwidget/">『 深入浅出 Flutter Framework 之自定义渲染型 Widget 』</a></p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>『 Widget 』—『 Element 』—『 RenderObject 』可称之为 Flutter Framework『三剑客』，其中 <a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">Widget</a>、<a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">Element</a> 都已介绍过，而 RenderObject 在这三者中属于最核心、最复杂的，涉及 Layout、Paint 等核心流程。<br>为了更好、更流畅地去理解 RenderObject，在正式介绍之前，需要做些准备工作，本文介绍的 PaintingContext 在 RenderObject 的绘制流程上扮演了重要角色。</p><p>『Painting Context』，其名称已说明了一些事情：绘制上下文，最简单的理解就是为绘制操作 (Paint) 提供了场所或者说环境 (上下文)。<br>其主要职责包括：</p><ul><li>在绘制流程中按需引入新的 Layer(主要依据 Repaint Boundary、need compositing)；</li><li>维护「Layer Tree」，每个 PaintingContext 实例都会生成一棵 Layer Sub Tree；</li><li>管理 Canvas，对底层细节进行抽象、封装。</li></ul><p><img src="/img/PaintContextClassDiagram.png" alt=""><br>如上图：</p><ul><li><code>PaintingContext</code>继承自<code>ClipContext</code>，<code>ClipContext</code>是抽象类，主要提供了几个与裁剪 (Clip) 有关的辅助方法；</li><li><code>PictureLayer _currentLayer</code>、<code>ui.PictureRecorder _recorder</code>以及<code>Canvas _canvas</code>用于具体的绘制操作；</li><li><code>ContainerLayer _containerLayer</code>，「Layer Subtree」的根节点，由<code>PaintingContext</code>构造函数传入，一般传入的是<code>RenderObject._layer</code>。<blockquote><p>RenderObject 与 Layer 是多对一的关系，即多个 RenderObject 绘制在一个 Layer 上。</p></blockquote></li></ul><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><hr><p>在上一小节中提及一些基础的概念，本小节对它们逐一进行简要介绍。</p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p><code>Canvas</code>是 Engine(C++) 层到 Framework(Dart) 层的桥接，真正的功能在 Engine 层实现。</p><blockquote><p>下文将要出现的<code>Picture</code>、<code>PictureRecorder</code>、<code>SceneBuilder</code>以及<code>SceneBuilder</code>都属于Engine(C++) 层到 Framework(Dart) 层的桥接。</p></blockquote><p>Canvas 向 Framework 层曝露了与绘制相关的基础接口，如：<code>draw*</code>、<code>clip*</code>、<code>transform</code>以及<code>scale</code>等，RenderObject 正是通过这些基础接口完成绘制任务的。</p><blockquote><p>通过这套接口进行的所有操作都将被<code>PictureRecorder</code>记录下来。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Canvas(PictureRecorder recorder, [ Rect cullRect ])&#123;&#125;</span><br></pre></td></tr></table></figure><p>如上，在<code>Canvas</code>初始化时需要指定<code>PictureRecorder</code>，用于记录所有的「graphical operations」。</p><p>除了正常的绘制操作(<code>draw*</code>)，Canvas 还支持矩阵变换(transformation matrix)、区域裁剪(clip region)，它们将作用于其后在该 Canvas 上进行的所有绘制操作。<br>下面列举部分方法，以便有更直观的感受：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scale(<span class="built_in">double</span> sx, [<span class="built_in">double</span> sy]);</span><br><span class="line"><span class="keyword">void</span> rotate(<span class="built_in">double</span> radians) native;</span><br><span class="line"><span class="keyword">void</span> transform(Float64List matrix4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> clipRect(Rect rect, &#123; ClipOp clipOp = ClipOp.intersect, <span class="built_in">bool</span> doAntiAlias = <span class="keyword">true</span> &#125;);</span><br><span class="line"><span class="keyword">void</span> clipPath(Path path, &#123;<span class="built_in">bool</span> doAntiAlias = <span class="keyword">true</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> drawColor(Color color, BlendMode blendMode);</span><br><span class="line"><span class="keyword">void</span> drawLine(Offset p1, Offset p2, Paint paint);</span><br><span class="line"><span class="keyword">void</span> drawRect(Rect rect, Paint paint);</span><br><span class="line"><span class="keyword">void</span> drawCircle(Offset c, <span class="built_in">double</span> radius, Paint paint);</span><br><span class="line"><span class="keyword">void</span> drawImage(Image image, Offset p, Paint paint);</span><br><span class="line"><span class="keyword">void</span> drawParagraph(Paragraph paragraph, Offset offset);</span><br></pre></td></tr></table></figure></p><h2 id="Picture"><a href="#Picture" class="headerlink" title="Picture"></a>Picture</h2><p>其本质是一系列「graphical operations」的集合，对 Framework 层透明。<br><code>Future&lt;Image&gt; toImage(int width, int height)</code>，通过<code>toImage</code>方法可以将其记录的所有操作经光栅化后生成<code>Image</code>对象。</p><h2 id="PictureRecorder"><a href="#PictureRecorder" class="headerlink" title="PictureRecorder"></a>PictureRecorder</h2><p>其主要作用是记录在<code>Canvas</code>上执行的「graphical operations」，通过<code>Picture#endRecording</code>最终生成<code>Picture</code>。</p><h2 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h2><p>同样对 Framework 层透明，是一系列 Picture、Texture 合成的结果。</p><blockquote><p>An opaque object representing a composited scene.</p></blockquote><p>UI 帧刷新时，在 Rendering Pipeline 中 Flutter UI 经 build、layout、paint 等步骤后最终生成 Scene。<br>其后通过<code>window.render</code>将该 Scene 送入 Engine 层，最终经 GPU 光栅化后显示在屏幕上。</p><h2 id="SceneBuilder"><a href="#SceneBuilder" class="headerlink" title="SceneBuilder"></a>SceneBuilder</h2><p>用于将多个图层(Layer)、Picture、Texture 合成为 Scene。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> addPicture(Offset offset, Picture picture, &#123; <span class="built_in">bool</span> isComplexHint = <span class="keyword">false</span>, <span class="built_in">bool</span> willChangeHint = <span class="keyword">false</span> &#125;);</span><br><span class="line"><span class="keyword">void</span> addTexture(<span class="built_in">int</span> textureId, &#123; Offset offset = Offset.zero, <span class="built_in">double</span> width = <span class="number">0.0</span>, <span class="built_in">double</span> height = <span class="number">0.0</span> , <span class="built_in">bool</span> freeze = <span class="keyword">false</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>通过<code>addPicture</code>、<code>addTexture</code>可以引入要合成的 Picture、Texture。</p><p>同时，SceneBuilder 还会维护一个图形操作 stack：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushTransform</span><br><span class="line">pushOffset</span><br><span class="line">pushClipRect</span><br><span class="line">...</span><br><span class="line">pop</span><br></pre></td></tr></table></figure></p><p>这些操作主要用于<code>OffsetLayer</code>、<code>ClipRectLayer</code>等。</p><p>是不是觉得很抽象，晕乎乎的！<br>下面通过一个小例子将它们串起来，真实感受一下。</p><h2 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  PictureRecorder recorder = PictureRecorder();</span><br><span class="line">  <span class="comment">// 初始化 Canvas 时，传入 PictureRecorder 实例</span></span><br><span class="line">  <span class="comment">// 用于记录发生在该 canvas 上的所有操作</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  Canvas canvas = Canvas(recorder);</span><br><span class="line"></span><br><span class="line">  Paint circlePaint= Paint();</span><br><span class="line">  circlePaint.color = Colors.blueAccent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 Canvas 的绘制接口，画一个圆形</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  canvas.drawCircle(Offset(<span class="number">400</span>, <span class="number">400</span>), <span class="number">300</span>, circlePaint);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绘制结束，生成Picture</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  Picture picture = recorder.endRecording();</span><br><span class="line"></span><br><span class="line">  SceneBuilder sceneBuilder = SceneBuilder();</span><br><span class="line">  sceneBuilder.pushOffset(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 将 picture 送入 SceneBuilder</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  sceneBuilder.addPicture(Offset(<span class="number">0</span>, <span class="number">0</span>), picture);</span><br><span class="line">  sceneBuilder.pop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成 Scene</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  Scene scene = sceneBuilder.build();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.onDrawFrame = () &#123;</span><br><span class="line">    <span class="comment">// 将 scene 送入 Engine 层进行渲染显示</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">window</span>.render(scene);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">window</span>.scheduleFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/drawcircle.png" alt=""></p><p>通过直接操作 Canvas，我们在屏幕上画了一个⭕️。</p><blockquote><p>仅仅是为了演示，在日常开发中并不需要直接操作这些基础 API。</p></blockquote><h1 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h1><hr><blockquote><p>本小节介绍的绘制流程，仅局限于 PaintingContext 周围，更完整的流程将在介绍 RenderObject 时进行分析。</p></blockquote><p>PaintingContext 与 RenderObject 是什么关系？<br>从『类间关系』角度看，它们之间是<strong>依赖关系</strong>，即 RenderObject 依赖于 PaintingContext —— PaintingContext 作为参数出现在 RenderObject 的绘制方法中。<br>也就是说，PaintingContext 是一次性的，每次执行 Paint 时都会生成对应的 PaintingContext，当绘制完成时其生命周期也随之结束。<br>PaintingContext 在 RenderObject 的绘制过程中的作用如下图所示：<br><img src="/img/PaintingPipeline.png" alt=""></p><ul><li>在 UI Frame 刷新时，通过<code>RendererBinding#drawFrame</code>-&gt;<code>PipelineOwner#flushPaint</code>触发<code>RenderObject#paint</code>；</li><li><code>RenderObject#paint</code>调用<code>PaintingContext.canvas</code>提供的图形操作接口(<code>draw*</code>、<code>clip*</code>、<code>transform</code>等)完成绘制任务；</li><li>上述绘制操作被 PictureRecorder 记录下来，在绘制结束时生成 picture，并被添加到 PictureLayer (_currentLayer)上；</li><li>随后，RenderObject 通过<code>PaintingContext#paintChild</code>递归地绘制子节点(child renderobject，如有)；</li><li>在绘制子节点时，根据子节点是否是「Repaint Boundary」而采用不同的策略：<ul><li>是「Repaint Boundary」— 为子节点生成新的 PaintingContext，从而子节点可以独立进行绘制，绘制结果就是一颗「Layer subTree」，最后将该子树 append 到父节点生成的「Layer Tree」上；</li><li>不是「Repaint Boundary」— 子节点直接绘制在当前<code>PaintingContext.canvas</code>上，即 RenderObject 与 Layer 是多对一的关系。</li></ul></li><li>整个绘制流程结束时就得到了一棵「Layer Tree」，其后通过 SceneBuilder 生成 Scene，再经<code>window.render</code>送入 Engine 层，最终 GPU 对其进行光栅化处理，显示在屏幕上。<blockquote><p>Repaint Boundary 的概念将在介绍 RenderObject 时重点分析。</p></blockquote></li></ul><p>上述流程中，起到关键作用的几个方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Canvas <span class="keyword">get</span> canvas &#123;</span><br><span class="line">  <span class="keyword">if</span> (_canvas == <span class="keyword">null</span>)</span><br><span class="line">    _startRecording();</span><br><span class="line">  <span class="keyword">return</span> _canvas;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _startRecording() &#123;</span><br><span class="line">  <span class="comment">// 在当前 Canvas 上进行的图形操作生成的 Picture 将添加到该 layer 上</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  _currentLayer = PictureLayer(estimatedBounds);</span><br><span class="line">  _recorder = ui.PictureRecorder();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化 Canvas，传入_recorder</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  _canvas = Canvas(_recorder);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将_currentLayer插入以_containerLayer为根节点的子树上</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  _containerLayer.append(_currentLayer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> stopRecordingIfNeeded() &#123;</span><br><span class="line">  <span class="comment">// 在停止记录时，将结果 picture 加到 _currentLayer 上</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  _currentLayer.picture = _recorder.endRecording();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注意！</span></span><br><span class="line">  <span class="comment">// 此时，_currentLayer、_recorder、_canvas 被释放，</span></span><br><span class="line">  <span class="comment">// 此后，若还要通过当前 PaintingContext 进行绘制，则会生成新的 _currentLayer、_recorder、_canvas</span></span><br><span class="line">  <span class="comment">// 即在 PaintingContext 的生命周期内 _canvas 可能会变</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  _currentLayer = <span class="keyword">null</span>;</span><br><span class="line">  _recorder = <span class="keyword">null</span>;</span><br><span class="line">  _canvas = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Compositing"><a href="#Compositing" class="headerlink" title="Compositing"></a>Compositing</h1><hr><p>Compositing，合成，属于 Rendering Pipeline 中的一环，表示是否要生成新的 Layer 来实现某些特定的图形效果。</p><blockquote><p><code>RenderObject.needCompositing</code>表示该 RenderObject 是否需要合成，即在<code>paint</code>方法中是否需要生成新的 Layer。<br>更详细的信息将在介绍 RenderObject 是进行分析。</p></blockquote><p>通常 RenderObject 会通过<code>PaintingContext#push*</code>来处理 Compositing：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> pushLayer(ContainerLayer childLayer, PaintingContextCallback painter, Offset offset, &#123; Rect childPaintBounds &#125;) &#123;</span><br><span class="line">  <span class="comment">// 注意！</span></span><br><span class="line">  <span class="comment">// 在 append sub layer 前先终止现有的绘制操作</span></span><br><span class="line">  <span class="comment">// stopRecordingIfNeeded 所执行的操作见上文</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  stopRecordingIfNeeded();</span><br><span class="line">  appendLayer(childLayer);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 为 childLayer 创建新的 PaintingContext，以便独立进行绘制操作</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> PaintingContext childContext = createChildContext(childLayer, childPaintBounds ?? estimatedBounds);</span><br><span class="line">  painter(childContext, offset);</span><br><span class="line">  childContext.stopRecordingIfNeeded();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PaintingContext createChildContext(ContainerLayer childLayer, Rect bounds) &#123;</span><br><span class="line">  <span class="keyword">return</span> PaintingContext(childLayer, bounds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// needsCompositing 参数一般来自 RenderObject.needCompositing</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">ClipRectLayer pushClipRect(<span class="built_in">bool</span> needsCompositing, Offset offset, Rect clipRect, PaintingContextCallback painter, &#123; Clip clipBehavior = Clip.hardEdge, ClipRectLayer oldLayer &#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> Rect offsetClipRect = clipRect.shift(offset);</span><br><span class="line">  <span class="keyword">if</span> (needsCompositing) &#123;</span><br><span class="line">    <span class="comment">// 在需要合成时，创建新 Layer</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">final</span> ClipRectLayer layer = oldLayer ?? ClipRectLayer();</span><br><span class="line">    layer</span><br><span class="line">      ..clipRect = offsetClipRect</span><br><span class="line">      ..clipBehavior = clipBehavior;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 将新 layer 添加到 layer tree 上，并在其上完成绘制</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    pushLayer(layer, painter, offset, childPaintBounds: offsetClipRect);</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则在当前 Canvas 上进行裁剪、绘制</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    clipRectAndPaint(offsetClipRect, clipBehavior, offsetClipRect, () =&gt; painter(<span class="keyword">this</span>, offset));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，<code>pushClipRect</code>在<code>needsCompositing</code>为<code>true</code>时，创建了新 Layer 并在其上进行裁剪、绘制，否则在当前 Canvas 上进行裁剪、绘制。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面，我们再通过一个简单的例子将上面的内容串一下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  ContainerLayer containerLayer = ContainerLayer();</span><br><span class="line">  PaintingContext paintingContext = PaintingContext(containerLayer, Rect.zero);</span><br><span class="line"></span><br><span class="line">  Paint circle1Paint= Paint();</span><br><span class="line">  circle1Paint.color = Colors.blue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注释1</span></span><br><span class="line">  <span class="comment">// paintingContext.canvas.save();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对画布进行裁剪</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  paintingContext.canvas.clipRect(Rect.fromCenter(center: Offset(<span class="number">400</span>, <span class="number">400</span>), width: <span class="number">280</span>, height: <span class="number">600</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在裁剪后的画布上画一个⭕️</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  paintingContext.canvas.drawCircle(Offset(<span class="number">400</span>, <span class="number">400</span>), <span class="number">300</span>, circle1Paint);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注释2</span></span><br><span class="line">  <span class="comment">// paintingContext.canvas.restore();</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _painter(PaintingContext context, Offset offset) &#123;</span><br><span class="line">    Paint circle2Paint = Paint();</span><br><span class="line">    circle2Paint.color = Colors.red;</span><br><span class="line">    context.canvas.drawCircle(Offset(<span class="number">400</span>, <span class="number">400</span>), <span class="number">250</span>, circle2Paint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 pushClipRect 方法再次执行裁剪</span></span><br><span class="line">  <span class="comment">// 注意此处 needsCompositing 参数为 true</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  paintingContext.pushClipRect(<span class="keyword">true</span>, Offset.zero, Rect.fromCenter(center: Offset(<span class="number">500</span>, <span class="number">400</span>), width: <span class="number">200</span>, height: <span class="number">200</span>), _painter,);</span><br><span class="line"></span><br><span class="line">  Paint circle3Paint= Paint();</span><br><span class="line">  circle3Paint.color = Colors.yellow;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再次画一个⭕️</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  paintingContext.canvas.drawCircle(Offset(<span class="number">400</span>, <span class="number">800</span>), <span class="number">300</span>, circle3Paint);</span><br><span class="line">  paintingContext.stopRecordingIfNeeded();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了减少篇幅，生成 Scene 相关的代码已省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>绘制结果如下图所示：</p><p><div style="width: 200px; margin: auto"><img src="/img/PaintContext_needCompositing.png" alt=""></div><br>若上述代码中在调用<code>paintingContext.pushClipRect</code>时，<code>needsCompositing</code>参数为<code>false</code>，则结果如下：</p><p><div style="width: 150px; margin: auto"><img src="/img/PaintContext_no_needCompositing.png" alt=""></div><br>那么，在<code>needsCompositing</code>参数为<code>false</code>时，如何实现图1的效果呢？<br>很简单，将代码中1、2处的注释去掉即可。<br>过程就不分析了，兴趣的同学可以自己分析一下。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>PaintingContext 在协助 RenderObject 绘制过程中起到重要作用，如：对 Layer Tree 的管理、对 Repaint Boundary、need Compositing 的处理、对基础 api 的封装等。了解了这些对后面理解 RenderObject 有很大的帮助。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.flutterinternals.org/rendering/compositing" target="_blank" rel="noopener">Flutter Internals</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是『 深入浅出 Flutter Framework 』系列文章的第四篇，主要目的是为后面介绍 RenderObject 作准备。&lt;br&gt;文章对 PaintingContext 进行了较详细的分析，主要包括在 Rendering Pipeline 中 PaintingContext 是如何配合 RenderObject 进行绘制的，同时对一些基础概念进行了简要的介绍(如：Canvas、Picture、PictureRecorder、SceneBuilder 以及 Scene 等)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://zxfcumtcs.github.io/tags/flutter/"/>
    
      <category term="移动开发" scheme="http://zxfcumtcs.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨平台" scheme="http://zxfcumtcs.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Flutter Framework 之 Element</title>
    <link href="http://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/"/>
    <id>http://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/</id>
    <published>2020-05-17T02:08:21.000Z</published>
    <updated>2021-09-04T15:20:50.789Z</updated>
    
    <content type="html"><![CDATA[<p>本文是『 深入浅出 Flutter Framework 』系列文章的第三篇，主要围绕 Element 相关内容进行分析介绍，包括 Element 分类、Element 与其他几个核心元素的关系、Element 生命周期以及核心方法解读等。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><p>本系列文章将深入 Flutter Framework 内部逐步去分析其核心概念和流程，主要包括：<br><a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">『 深入浅出 Flutter Framework 之 Widget 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">『 深入浅出 Flutter Framework 之 BuildOwner 』</a><br>『 深入浅出 Flutter Framework 之 Element 』<br><a href="https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/">『 深入浅出 Flutter Framework 之 PaintingContext 』</a><br><a href="https://zxfcumtcs.github.io/2020/06/07/deepinto-flutter-layer/">『 深入浅出 Flutter Framework 之 Layer 』</a><br><a href="https://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/">『 深入浅出 Flutter Framework 之 PipelineOwner 』</a><br><a href="https://zxfcumtcs.github.io/2021/03/27/deepinto-flutter-renderobject/">『 深入浅出 Flutter Framework 之 RenderObejct 』</a><br><a href="https://zxfcumtcs.github.io/2021/08/28/deepinto-flutter-custom-renderobjectwidget/">『 深入浅出 Flutter Framework 之自定义渲染型 Widget 』</a></p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>通过<a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">『 深入浅出 Flutter Framework 之 Widget 』</a>的介绍，我们知道 Widget 本质上是 UI 的配置数据 (静态、不可变)，Element 则是通过 Widget 生成的『实例』，两者间的关系就像是 json 与 object。</p><blockquote><p>同一份配置 (Widget) 可以生成多个实例 (Element)，这些实例可能会被安插在树上不同的位置。</p></blockquote><p>UI 的层级结构在 Element 间形成一棵真实存在的树「Element Tree」，Element 有 2 个主要职责：</p><ul><li>根据 UI (「Widget Tree」) 的变化来维护「Element Tree」，包括：节点的插入、更新、删除、移动等；</li><li>Widget 与 RenderObject 间的协调者。</li></ul><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><hr><p><img src="/img/Element.png" alt=""><br>如图所示，Element 根据特点可以分为 2 类：</p><ul><li><em>「Component Element」</em> —— 组合型 Element，「Component Widget」、「Proxy Widget」对应的 Element 都属于这一类型，其特点是子节点对应的 Widget 需要通过<code>build</code>方法去创建。同时，该类型 Element 都只有一个子节点 (single child)；</li><li><em>「Renderer Element」</em> —— 渲染型 Element，对应「Renderer Widget」，其不同的子类型包含的子节点个数也不一样，如：LeafRenderObjectElement 没有子节点，RootRenderObjectElement、SingleChildRenderObjectElement 有一个子节点，MultiChildRenderObjectElement 有多个子节点。<blockquote><p>原生型 Element，只有 MultiChildRenderObjectElement 是多子节点的，其他都是单子节点。</p></blockquote></li></ul><p>同时，可以看到，<code>Element</code>实现了<code>BuildContext</code>接口 —— 我们在 Widget 中遇到的<code>context</code>，其实就是该 Widget 对应的 Element。</p><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><hr><p>在继续之前有必要先了解一下 Element 与其他几个核心元素间的关系，以便在全局上有个认识。<br><img src="/img/Element_Relationship.png" alt=""></p><p>如图：</p><ul><li>Element 通过 parent、child 指针形成「Element Tree」；</li><li>Element 持有 Widget、「Render Object」；</li><li>State 是绑定在 Element 上的，而不是绑在「Stateful Widget」上(这点很重要)。<blockquote><p>上述这些关系并不是所有类型的 Element 都有，如：「Render Object」只有「RenderObject Element」才有，State 只有「Stateful Element」才有。</p></blockquote></li></ul><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><hr><p>Element 作为『实例』，随着 UI 的变化，有较复杂的生命周期：</p><ul><li><p>parent 通过<code>Element.inflateWidget</code>-&gt;<code>Widget.createElement</code>创建 child element，触发场景有：UI 的初次创建、UI 刷新时新老 Widget 不匹配(old element 被移除，new element 被插入)；</p></li><li><p>parent 通过<code>Element.mount</code>将新创建的 child 插入「Element Tree」中指定的插槽处 (slot);</p><blockquote><p><code>dynamic Element.slot</code>——其含意对子节点透明，父节点用于确定其下子节点的排列顺序 (兄弟节点间的排序)。因此，对于单子节点的节点 (single child)，child.slot 通常为 null。<br>另外，slot 的类型是动态的，不同类型的 Element 可能会使用不同类型的 slot，如：Sliver 系列使用的是 int 型的 index，MultiChildRenderObjectElement 用兄弟节点作为后一个节点的 slot。<br>对于「component element」，<code>mount</code>方法还要负责所有子节点的 build (这是一个递归的过程)，对于「render element」，<code>mount</code>方法需要负责将「render object」添加到「render tree」上。其过程在介绍到相应类型的 Element 时会详情分析。</p></blockquote></li><li><p>此时，(child) element 处于 <strong>active</strong> 状态，其内容随时可能显示在屏幕上；</p></li><li><p>此后，由于状态更新、UI 结构变化等，element 所在位置对应的 Widget 可能发生了变化，此时 parent 会调用<code>Element.update</code>去更新子节点，update 操作会在以当前节点为根节点的子树上递归进行，直到叶子节点；(执行该步骤的前提是新老 Widget.[key &amp;&amp; runtimeType] 相等，否则创建新 element，而不是更新现有 element)；</p></li><li><p>状态更新时，element 也可能会被移除 (如：新老 Widget.[key || runtimeType] 不相等)，此时，parent 将调用<code>deactivateChild</code>方法，该方法主要做了 3 件事：</p><ul><li>从「Element Tree」中移除该 element (将 parent 置为 null)；</li><li>将相应的「render object」从「render tree」上移除；</li><li>将 element 添加到<code>owner._inactiveElements</code>中，在添加过程中会对『以该 element 为根节点的子树上所有节点』调用<code>deactivate</code>方法 (移除的是整棵子树)。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> deactivateChild(<span class="built_in">Element</span> child) &#123;</span><br><span class="line">  child._parent = <span class="keyword">null</span>;</span><br><span class="line">  child.detachRenderObject();</span><br><span class="line">  owner._inactiveElements.add(child); <span class="comment">// this eventually calls child.deactivate()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>此时，element 处于 “inactive” 状态，并从屏幕上消失，该状态一直持续到当前帧动画结束；</p></li><li><p>从 element 进入 “inactive” 状态到当前帧动画结束期间，其还有被『抢救』的机会，前提是『带有「global key」&amp;&amp; 被重新插入树中』，此时：</p><ul><li>该 element 将会从<code>owner._inactiveElements</code>中移除；</li><li>对该 element subtree 上所有节点调用<code>activate</code>方法 (它们又复活了！)；</li><li>将相应的「render object」重新插入「render tree」中；</li><li>该 element subtree 又进入 “active” 状态，并将再次出现在屏幕上。<blockquote><p>上述过程经历这几个方法：<code>Parent Element.inflateWidget</code>–&gt;<code>Parent Element._retakeInactiveElement</code>–&gt;<code>BuildOwner._inactiveElements.remove</code>–&gt;<code>Child Element._activateWithParent</code>…</p></blockquote></li></ul></li><li><p>对于所有在当前帧动画结束时未能成功『抢救』回来的「Inactive Elements」都将被 unmount；</p></li><li>至此，element 生命周期圆满结束。<br><img src="/img/Element_Lifecycle.jpg" alt=""></li></ul><h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><hr><p>下面对 Element 中的几个核心方法进行简单介绍：</p><h2 id="updateChild"><a href="#updateChild" class="headerlink" title="updateChild"></a>updateChild</h2><p><code>updateChild</code>是 flutter framework 中的核心方法之一：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span> updateChild(<span class="built_in">Element</span> child, Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">      deactivateChild(child);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.widget == newWidget) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">        updateSlotForChild(child, newSlot);</span><br><span class="line">      <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">        updateSlotForChild(child, newSlot);</span><br><span class="line">      child.update(newWidget);</span><br><span class="line">      <span class="keyword">assert</span>(child.widget == newWidget);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deactivateChild(child);</span><br><span class="line">    <span class="keyword">assert</span>(child._parent == <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> inflateWidget(newWidget, newSlot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在「Element Tree」上，<strong>父节点通过该方法来修改子节点对应的 Widget</strong>。<br><img src="/img/updateChild.jpg" alt=""></p><p>根据传入参数的不同，有以下几种不同的行为：</p><ul><li><code>newWidget</code> == <code>null</code> —— 说明子节点对应的 Widget 已被移除，直接 remove child element (如有)；</li><li><code>child</code> == <code>null</code> —— 说明 newWidget 是新插入的，创建子节点 (inflateWidget)；</li><li><code>child</code> != <code>null</code> —— 此时，分为 3 种情况：<ul><li>若 child.widget == newWidget，说明 child.widget 前后没有变化，若 child.slot != newSlot 表明子节点在兄弟结点间移动了位置，通过<code>updateSlotForChild</code>修改 child.slot 即可；</li><li>通过<code>Widget.canUpdate</code>判断是否可以用 newWidget 修改 child element，若可以，则调用<code>update</code>方法；</li><li>否则先将 child element 移除，并通 newWidget 创建新的 element 子节点。</li></ul></li></ul><blockquote><p>子类一般不需要重写该方法，该方法有点类似设计模式中的『模板方法』。</p></blockquote><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>在更新流程中，若新老 Widget.[runtimeType &amp;&amp; key] 相等，则会走到该方法。<br>子类需要重写该方法以处理具体的更新逻辑：</p><h3 id="Element-基类"><a href="#Element-基类" class="headerlink" title="Element 基类"></a>Element 基类</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@mustCallSuper</span></span><br><span class="line"><span class="keyword">void</span> update(covariant Widget newWidget) &#123;</span><br><span class="line">  _widget = newWidget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类中的<code>update</code>很简单，只是对<code>_widget</code>赋值。</p><blockquote><p>子类重写该方法时必须调用 super.</p></blockquote><h3 id="StatelessElement"><a href="#StatelessElement" class="headerlink" title="StatelessElement"></a>StatelessElement</h3><blockquote><p>父类<code>ComponentElement</code>没有重写该方法</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(StatelessWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  rebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>rebuild</code>方法触发重建 child widget (第 4 行)，并以此来 update child element，期间会调用到<code>StatelessWidget.build</code>方法 (也就是我们写的 Flutter 代码)。</p><blockquote><p>组合型 Element 都会在<code>update</code>方法中触发<code>rebuild</code>操作，以便重新 build child widget。</p></blockquote><h3 id="StatefulElement"><a href="#StatefulElement" class="headerlink" title="StatefulElement"></a>StatefulElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(StatefulWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  <span class="keyword">final</span> StatefulWidget oldWidget = _state._widget;</span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  _state._widget = widget;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _state.didUpdateWidget(oldWidget) <span class="keyword">as</span> <span class="keyword">dynamic</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  rebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比<code>StatelessElement</code>，<code>StatefulElement.update</code>稍微复杂一些，需要处理<code>State</code>，如：</p><ul><li>修改 State 的 <code>_widget</code>属性；</li><li>调用<code>State.didUpdateWidget</code> (熟悉么)。</li></ul><p>最后，同样会触发<code>rebuild</code>操作，期间会调用到<code>State.build</code>方法。</p><h3 id="ProxyElement"><a href="#ProxyElement" class="headerlink" title="ProxyElement"></a>ProxyElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(ProxyWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">final</span> ProxyWidget oldWidget = widget;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  updated(oldWidget);</span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  rebuild();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> updated(covariant ProxyWidget oldWidget) &#123;</span><br><span class="line">  notifyClients(oldWidget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget build() =&gt; widget.child;</span><br></pre></td></tr></table></figure><p><code>ProxyElement.update</code>方法需要关注的是对<code>updated</code>的调用，其主要用于通知关联对象 Widget 有更新。<br>具体通知逻辑在子类中处理，如：<code>InheritedElement</code>会触发所有依赖者 rebuild (对于 StatefulElement 类型的依赖者，会调用<code>State.didChangeDependencies</code>)。</p><p>ProxyElement 的<code>build</code>操作很简单：直接返回<code>widget.child</code>。</p><h3 id="RenderObjectElement"><a href="#RenderObjectElement" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(covariant RenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RenderObjectElement.update</code>方法调用了<code>widget.updateRenderObject</code>来更新「Render Object」(熟悉么)。</p><h3 id="SingleChildRenderObjectElement"><a href="#SingleChildRenderObjectElement" class="headerlink" title="SingleChildRenderObjectElement"></a>SingleChildRenderObjectElement</h3><blockquote><p><code>SingleChildRenderObjectElement</code>、<code>MultiChildRenderObjectElement</code>是<code>RenderObjectElement</code>的子类。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(SingleChildRenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  _child = updateChild(_child, widget.child, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 3 行，通过<code>newWidget.child</code>调用<code>updateChild</code>方法递归修改子节点。</p><h3 id="MultiChildRenderObjectElement"><a href="#MultiChildRenderObjectElement" class="headerlink" title="MultiChildRenderObjectElement"></a>MultiChildRenderObjectElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(MultiChildRenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  _children = updateChildren(_children, widget.children, forgottenChildren: _forgottenChildren);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现看似简单，实则非常复杂，在<code>updateChildren</code>方法中处理了子节点的插入、移动、更新、删除等所有情况。</p><h2 id="inflateWidget"><a href="#inflateWidget" class="headerlink" title="inflateWidget"></a>inflateWidget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">final</span> Key key = newWidget.key;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = _retakeInactiveElement(key, newWidget);</span><br><span class="line">    <span class="keyword">if</span> (newChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">      newChild._activateWithParent(<span class="keyword">this</span>, newSlot);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Element</span> updatedChild = updateChild(newChild, newWidget, newSlot);</span><br><span class="line">      <span class="keyword">return</span> updatedChild;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</span><br><span class="line">  newChild.mount(<span class="keyword">this</span>, newSlot);</span><br><span class="line">  <span class="keyword">return</span> newChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>inflateWidget</code> 属于模板方法，故一般情况下子类不用重写。</p></blockquote><p>该方法的主要职责：通过 Widget 创建对应的 Element，并将其挂载 (mount) 到「Element Tree」上。</p><blockquote><p>如果 Widget 带有 GlobalKey，首先在 Inactive Elements 列表中查找是否有处于 inactive 状态的节点 (即刚从树上移除)，如找到就直接复活该节点。</p></blockquote><p>主要调用路径来自上面介绍的<code>updateChild</code>方法。</p><h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>当 Element 第一次被插入「Element Tree」上时，调用该方法。由于此时 parent 已确定，故在该方法中可以做依赖 parent 的初始化操作。经过该方法后，element 的状态从 “initial” 转到了 “active”。</p><h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@mustCallSuper</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  _parent = parent;</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _depth = _parent != <span class="keyword">null</span> ? _parent.depth + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  _active = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) <span class="comment">// Only assign ownership if the parent is non-null</span></span><br><span class="line">    _owner = parent.owner;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (widget.key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">    <span class="keyword">final</span> GlobalKey key = widget.key;</span><br><span class="line">    key._register(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _updateInheritance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得<code>BuildOwner</code>吗，正是在该方法中父节点的 owner 传给了子节点。<br>如果，对应的 Widget 带有 GlobalKey，进行相关的注册。<br>最后，继承来自父节点的「Inherited Widgets」。</p><blockquote><p>子类重写该方法时，必须调用 super。<br>关于「Inherited Widgets」，后文会详细分析</p></blockquote><h3 id="ComponentElement"><a href="#ComponentElement" class="headerlink" title="ComponentElement"></a>ComponentElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _firstBuild();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _firstBuild() &#123;</span><br><span class="line">  rebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合型 Element 在挂载时会执行<code>_firstBuild-&gt;rebuild</code>操作。</p><h3 id="RenderObjectElement-1"><a href="#RenderObjectElement-1" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>RenderObjectElement.mount</code>中做的最重要的事就是通过 Widget 创建了「Render Object」(第 3 行)，并将其插入到「RenderObject Tree」上 (第 4 行)。</p><h3 id="SingleChildRenderObjectElement-1"><a href="#SingleChildRenderObjectElement-1" class="headerlink" title="SingleChildRenderObjectElement"></a>SingleChildRenderObjectElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _child = updateChild(_child, widget.child, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SingleChildRenderObjectElement</code>在 super (<code>RenderObjectElement</code>) 的基础上，调用<code>updateChild</code>方法处理子节点，其实此时<code>_child</code>为<code>nil</code>，前面介绍过当 child 为<code>nil</code>时，<code>updateChild</code>会调用<code>inflateWidget</code>方法创建 Element 实例。</p><h3 id="MultiChildRenderObjectElement-1"><a href="#MultiChildRenderObjectElement-1" class="headerlink" title="MultiChildRenderObjectElement"></a>MultiChildRenderObjectElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _children = <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt;(widget.children.length);</span><br><span class="line">  <span class="built_in">Element</span> previousChild;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _children.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = inflateWidget(widget.children[i], previousChild);</span><br><span class="line">    _children[i] = newChild;</span><br><span class="line">    previousChild = newChild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MultiChildRenderObjectElement</code>在 super (<code>RenderObjectElement</code>) 的基础上，对每个子节点直接调用<code>inflateWidget</code>方法。</p><h2 id="markNeedsBuild"><a href="#markNeedsBuild" class="headerlink" title="markNeedsBuild"></a>markNeedsBuild</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_active)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dirty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  owner.scheduleBuildFor(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>markNeedsBuild</code>方法其实在介绍<a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">BuildOwer</a>时已经分析过，其作用就是将当前 Element 加入<code>_dirtyElements</code>中，以便在下一帧可以rebuild。<br>那么，哪些场景会调用<code>markNeedsBuild</code>呢？</p><ul><li><code>State.setState</code> —— 这个在介绍 <a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">Widget</a> 时已分析过了；</li><li><code>Element.reassemble</code> —— debug hot reload；</li><li><code>Element.didChangeDependencies</code> —— 前面介绍过当依赖的「Inherited Widget」有变化时会导致依赖者 rebuild，就是从这里触发的；</li><li><code>StatefulElement.activate</code> —— 还记得<code>activate</code>吗？前文介绍过当 Element 从 “inactive” 到 “active” 时，会调用该方法。为什么<code>StatefulElement</code>要重写<code>activate</code>？因为<code>StatefulElement</code>有附带的 State，需要给它一个<code>activate</code>的机会。</li></ul><blockquote><p>子类一般不必重写该方法。</p></blockquote><h2 id="rebuild"><a href="#rebuild" class="headerlink" title="rebuild"></a>rebuild</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_active || !_dirty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  performRebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法逻辑非常简单，对于活跃的、脏节点调用<code>performRebuild</code>，在 3 种场景下被调用：</p><ul><li>对于 dirty element，在新一帧绘制过程中由<code>BuildOwner.buildScope</code>；</li><li>在 element 挂载时，由<code>Element.mount</code>调用；</li><li>在<code>update</code>方法内被调用。</li></ul><blockquote><p>上述第 2、3 点仅「Component Element」需要</p></blockquote><h2 id="performRebuild"><a href="#performRebuild" class="headerlink" title="performRebuild"></a>performRebuild</h2><p>Element 基类中该方法是<code>no-op</code>。</p><h3 id="ComponentElement-1"><a href="#ComponentElement-1" class="headerlink" title="ComponentElement"></a>ComponentElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">  Widget built;</span><br><span class="line">  built = build();</span><br><span class="line"></span><br><span class="line">  _child = updateChild(_child, built, slot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于组合型 Element，rebuild 过程其实就是调用<code>build</code>方法生成「child widget」，再由其更新「child element」。</p><blockquote><p>StatelessElement.build: <code>Widget build() =&gt; widget.build(this);</code><br>StatefulElement.build: <code>Widget build() =&gt; state.build(this);</code><br>ProxyElement.build: <code>Widget build() =&gt; widget.child;</code></p></blockquote><h3 id="RenderObjectElement-2"><a href="#RenderObjectElement-2" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">  widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在渲染型 Element 基类中只是用 Widget 更新了对应的「Render Object」。<br>在相关子类中可以执行更具体的逻辑。</p><h2 id="生命周期视角"><a href="#生命周期视角" class="headerlink" title="生命周期视角"></a>生命周期视角</h2><p>至此，Element 的核心方法基本已介绍完，是不是有点晕乎乎的感觉？<code>inflateWidget</code>、<code>updateChild</code>、<code>update</code>、<code>mount</code>、<code>rebuild</code>以及<code>performRebuild</code>等你中有我、我中有你，再加上不同类型的子类对这些方法的重写。</p><p>下面，我们以 Element 生命周期为切入点将这些方法串起来。<br>对于一个 Element 节点来说在其生命周期内可能会历经几次『重大事件』：</p><ul><li><p>被创建 —— 起源于父节点调用<code>inflateWidget</code>，随之被挂载到「Element Tree」上， 此后递归创建子节点；<br><img src="/img/element0to1.jpg" alt=""></p></li><li><p>被更新 —— 由「Element Tree」上祖先节点递归传递下来的更新操作，<code>parent.updateChild</code>-&gt;<code>child.update</code>；<br><img src="/img/element1to1.1.jpg" alt=""></p></li><li><p>被重建 —— 被调用<code>rebuild</code>方法(调用场景上面已分析)；<br><img src="/img/element1ton.jpg" alt=""></p></li><li><p>被销毁 —— element 节点所在的子树随着 UI 的变化被移除。<br><img src="/img/element-deactivate.jpg" alt=""></p></li></ul><h1 id="依赖-Dependencies"><a href="#依赖-Dependencies" class="headerlink" title="依赖 (Dependencies)"></a>依赖 (Dependencies)</h1><hr><p>在 Element 基类中有这样两个成员：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, InheritedElement&gt; _inheritedWidgets;</span><br><span class="line"><span class="built_in">Set</span>&lt;InheritedElement&gt; _dependencies;</span><br></pre></td></tr></table></figure></p><p>它们是干嘛用的呢？</p><ul><li><code>_inheritedWidgets</code> —— 用于收集从「Element Tree」根节点到当前节点路径上所有的「Inherited Elements」；<br>前文提到过在<code>mount</code>方法结束处会调用<code>_updateInheritance</code>：<br>以下是 Element 基类的实现，可以看到子节点直接获得父节点的<code>_inheritedWidgets</code>：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">  _inheritedWidgets = _parent?._inheritedWidgets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以下是<code>InheritedElement</code>类的实现，其在父节点的基础上将自己加入到<code>_inheritedWidgets</code>中，以便其子孙节点的<code>_inheritedWidgets</code>包含它 (第 8 行)：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, InheritedElement&gt; incomingWidgets = _parent?._inheritedWidgets;</span><br><span class="line">  <span class="keyword">if</span> (incomingWidgets != <span class="keyword">null</span>)</span><br><span class="line">    _inheritedWidgets = HashMap&lt;<span class="built_in">Type</span>, InheritedElement&gt;.from(incomingWidgets);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    _inheritedWidgets = HashMap&lt;<span class="built_in">Type</span>, InheritedElement&gt;();</span><br><span class="line"></span><br><span class="line">  _inheritedWidgets[widget.runtimeType] = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>_dependencies</code> —— 用于记录当前节点依赖了哪些「Inherited Elements」，通常我们调用<code>context.dependOnInheritedWidgetOfExactType&lt;T&gt;</code>时就会在当前节点与目标 Inherited 节点间形成依赖关系。<blockquote><p>在 Element 上提供的便利方法<code>of</code>，一般殾会调用<code>dependOnInheritedWidgetOfExactType</code>。</p></blockquote></li></ul><p>同时，在<code>InheritedElement</code>中还有用于记录所有依赖于它的节点：<code>final Map&lt;Element, Object&gt; _dependents</code>。<br>最终，在「Inherited Element」发生变化，需要通知依赖者时，会利用依赖者的<code>_dependencies</code>信息做一下 (debug) check (第 4 行)：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> notifyClients(InheritedWidget oldWidget) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">Element</span> dependent <span class="keyword">in</span> _dependents.keys) &#123;</span><br><span class="line">    <span class="comment">// check that it really depends on us</span></span><br><span class="line">    <span class="keyword">assert</span>(dependent._dependencies.contains(<span class="keyword">this</span>));</span><br><span class="line">    notifyDependent(oldWidget, dependent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至此，Element 相关的内容基本已介绍完。总结提炼一下：</p><ul><li>Element 与 Widget 一一对应，它们间的关系就像 object 与 json；</li><li>只有「Render Element」才有对应的「Render Object」；</li><li>Element 作为 Widget 与 RenderObejct 间协调者，会根据 UI(「Widget Tree」) 的变化对「Element Tree」作出相应的调整，同时对「RenderObject Tree」进行必要的修改；</li><li>Widget 是不可变的、无状态的，而 Element 是有状态的。</li></ul><p>最后，强烈推荐<a href="https://medium.com/flutter/keys-what-are-they-good-for-13cb51742e7d" target="_blank" rel="noopener">Keys! What are they good for?</a>这篇文章，对于理解本文相关的内容有很大的帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是『 深入浅出 Flutter Framework 』系列文章的第三篇，主要围绕 Element 相关内容进行分析介绍，包括 Element 分类、Element 与其他几个核心元素的关系、Element 生命周期以及核心方法解读等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://zxfcumtcs.github.io/tags/flutter/"/>
    
      <category term="移动开发" scheme="http://zxfcumtcs.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨平台" scheme="http://zxfcumtcs.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Flutter Framework 之 BuildOwner</title>
    <link href="http://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/"/>
    <id>http://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/</id>
    <published>2020-05-16T07:39:12.000Z</published>
    <updated>2021-09-04T15:21:04.096Z</updated>
    
    <content type="html"><![CDATA[<p>本文是『 深入浅出 Flutter Framework 』系列文章的第二篇，对 BuildOwner 相关内容进行简要地分析介绍，为下一篇文章介绍 Element 作准备 (由于篇幅原因将其单独提出来)。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><p>本系列文章将深入 Flutter Framework 内部逐步去分析其核心概念和流程，主要包括：<br><a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">『 深入浅出 Flutter Framework 之 Widget 』</a><br>『 深入浅出 Flutter Framework 之 BuildOwner 』<br><a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">『 深入浅出 Flutter Framework 之 Element 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/">『 深入浅出 Flutter Framework 之 PaintingContext 』</a><br><a href="https://zxfcumtcs.github.io/2020/06/07/deepinto-flutter-layer/">『 深入浅出 Flutter Framework 之 Layer 』</a><br><a href="https://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/">『 深入浅出 Flutter Framework 之 PipelineOwner 』</a><br><a href="https://zxfcumtcs.github.io/2021/03/27/deepinto-flutter-renderobject/">『 深入浅出 Flutter Framework 之 RenderObejct 』</a><br><a href="https://zxfcumtcs.github.io/2021/08/28/deepinto-flutter-custom-renderobjectwidget/">『 深入浅出 Flutter Framework 之自定义渲染型 Widget 』</a></p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p><code>BuildOwner</code>在 Element 状态管理上起到重要作用：</p><ul><li>在 UI 更新过程中跟踪、管理需要 rebuild 的 Element (「dirty elements」);</li><li>在有「dirty elements」时，及时通知引擎，以便在下一帧安排上对「dirty elements」的 rebuild，从而去刷新 UI；</li><li>管理处于 “inactive” 状态的 Element。</li></ul><blockquote><p>这是我们遇到的第一个 Owner，后面还有<code>PipeOwner</code>。</p></blockquote><p>整棵「Element Tree」共享同一个<code>BuildOwner</code>实例 (全局的)，在 Element 挂载过程中由 parent 传递给 child element。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@mustCallSuper</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  _parent = parent;</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _depth = _parent != <span class="keyword">null</span> ? _parent.depth + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  _active = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) <span class="comment">// Only assign ownership if the parent is non-null</span></span><br><span class="line">    _owner = parent.owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上是<code>Element</code>基类的<code>mount</code>方法，第 8 行将 parent.owner 赋给了 child。</p><blockquote><p><code>BuildOwner</code>实例由<code>WidgetsBinding</code>负责创建，并赋值给「Element Tree」的根节点<code>RenderObjectToWidgetElement</code>，此后随着「Element Tree」的创建逐级传递给子节点。(具体流程后续文章会详细分析)<br>一般情况下并不需要我们手动实例化<code>BuildOwner</code>，除非需要离屏沉浸 (此时需要构建 off-screen element tree)</p></blockquote><p><code>BuildOwner</code>两个关键成员变量：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> _InactiveElements _inactiveElements = _InactiveElements();</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt; _dirtyElements = &lt;<span class="built_in">Element</span>&gt;[];</span><br></pre></td></tr></table></figure></p><p>其命名已清晰表达了他们的用途：分别用于存储收集到的「Inactive Elements」、「Dirty Elements」。</p><h1 id="Dirty-Elements"><a href="#Dirty-Elements" class="headerlink" title="Dirty Elements"></a>Dirty Elements</h1><hr><p>那么<code>BuildOwner</code>是如何收集「Dirty Elements」的呢？<br>对于需要更新的 element，首先会调用<code>Element.markNeedsBuild</code>方法，如<a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">前文</a>讲到的<code>State.setState</code>方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">dynamic</span> result = fn() <span class="keyword">as</span> <span class="keyword">dynamic</span>;</span><br><span class="line">  _element.markNeedsBuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如下，<code>Element.markNeedsBuild</code>调用了<code>BuildOwner.scheduleBuildFor</code>方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_active)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dirty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  owner.scheduleBuildFor(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>BuildOwner.scheduleBuildFor</code>方法做了 2 件事：</p><ul><li>调用<code>onBuildScheduled</code>，该方法(其实是个callback)会通知 Engine 在下一帧需要做更新操作；</li><li>将「Dirty Elements」加入到<code>_dirtyElements</code>中。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleBuildFor(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(element.owner == <span class="keyword">this</span>);</span><br><span class="line">  onBuildScheduled();</span><br><span class="line"></span><br><span class="line">  _dirtyElements.add(element);</span><br><span class="line">  element._inDirtyList = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此后，在新一帧绘制到来时，<code>WidgetsBinding.drawFrame</code>会调用<code>BuildOwner.buildScope</code>方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [ VoidCallback callback ]) &#123;</span><br><span class="line">  <span class="keyword">if</span> (callback == <span class="keyword">null</span> &amp;&amp; _dirtyElements.isEmpty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dirtyElements.sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">    <span class="built_in">int</span> dirtyCount = _dirtyElements.length;</span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; dirtyCount) &#123;</span><br><span class="line">      _dirtyElements[index].rebuild();</span><br><span class="line">      index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">Element</span> element <span class="keyword">in</span> _dirtyElements) &#123;</span><br><span class="line">      element._inDirtyList = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _dirtyElements.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如有回调，先执行回调 (第 7 行)；</li><li><p>对「dirty elements」按在「Element Tree」上的深度排序 (即 parent 排在 child 前面) (第 10 行)；</p><blockquote><p>为啥要这样排？确保 parent 先于 child 被 rebuild，以免 child 被重复 rebuild (因为 parent 在 rebuild 时会递归地 update child)。</p></blockquote></li><li><p>对<code>_dirtyElements</code>中的元素依次调用<code>rebuild</code> (第 14 行)；</p></li><li>清理<code>_dirtyElements</code> (第 21 行)。</li></ul><h1 id="Inactive-Elements"><a href="#Inactive-Elements" class="headerlink" title="Inactive Elements"></a>Inactive Elements</h1><hr><p>所谓「Inactive Element」，是指 element 从「Element Tree」上被移除到 dispose 或被重新插入「Element Tree」间的一个中间状态。<br><strong>设计 inactive 状态的主要目的是实现『带有「global key」的 element』可以带着『状态』在树上任意移动。</strong></p><p>BuildOwner 负责对「Inactive Element」进行管理，包括添加、删除以及对过期的「Inactive Element」执行 unmount 操作。<br>关于「Inactive Element」的更多信息将在介绍 Element 时一起介绍。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>BuildOwner 主要是用于收集那些需要 rebuild 的「Dirty Elements」以及处于 Inactive 状态的 Elements。</p><p>结束了！就是这么简单，下篇再见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是『 深入浅出 Flutter Framework 』系列文章的第二篇，对 BuildOwner 相关内容进行简要地分析介绍，为下一篇文章介绍 Element 作准备 (由于篇幅原因将其单独提出来)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://zxfcumtcs.github.io/tags/flutter/"/>
    
      <category term="移动开发" scheme="http://zxfcumtcs.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨平台" scheme="http://zxfcumtcs.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Flutter Framework 之 Widget</title>
    <link href="http://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/"/>
    <id>http://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/</id>
    <published>2020-05-01T13:29:16.000Z</published>
    <updated>2021-09-04T15:25:03.932Z</updated>
    
    <content type="html"><![CDATA[<p>本文是『 深入浅出 Flutter Framework 』系列文章的第一篇，主要以不同类型 Widget 的核心方法为切入点，对其展开详细分析。</p><a id="more"></a><p>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>Flutter 作为一种新兴跨平台解决方案，自 2017 年 Google 在 I/O 大会上推出后，尤其是在 2018 年 I/O 大会上发布第一个预览版后，迅速引起移动开发者的广泛关注，并成为时下最热门的跨平台解决方案 ( 没有之一 ) ！</p><p>本系列文章将深入 Flutter Framework 内部逐步去分析其核心概念和流程，主要包括：<br>『 深入浅出 Flutter Framework 之 Widget 』<br><a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">『 深入浅出 Flutter Framework 之 BuildOwner 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">『 深入浅出 Flutter Framework 之 Element 』</a><br><a href="https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/">『 深入浅出 Flutter Framework 之 PaintingContext 』</a><br><a href="https://zxfcumtcs.github.io/2020/06/07/deepinto-flutter-layer/">『 深入浅出 Flutter Framework 之 Layer 』</a><br><a href="https://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/">『 深入浅出 Flutter Framework 之 PipelineOwner 』</a><br><a href="https://zxfcumtcs.github.io/2021/03/27/deepinto-flutter-renderobject/">『 深入浅出 Flutter Framework 之 RenderObejct 』</a><br><a href="https://zxfcumtcs.github.io/2021/08/28/deepinto-flutter-custom-renderobjectwidget/">『 深入浅出 Flutter Framework 之自定义渲染型 Widget 』</a></p><p>其中，前 7 篇属于理论分析篇，分别介绍 Flutter 中几个最核心的概念。最后一篇，自定义 Render Widget 属于回顾、实践篇，分析自定义一个 Render Widget 至少需要哪些步骤。</p><blockquote><p>如<a href="https://flutter.dev/docs/resources/technical-overview#layer-cakes-are-delicious" target="_blank" rel="noopener">下图</a>所示，Flutter 整体分为三层：Framework (dart)、Engine (C/C++)、Embedder (Platform)，上述文章主要集中在 Framework 这一层。<br><img src="/img/flutter-layercake.png" alt=""></p></blockquote><h1 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h1><hr><blockquote><p>Everything’s a widget.</p></blockquote><p>在开发 Flutter 应用过程中，接触最多的无疑就是<code>Widget</code>，是『描述』 Flutter UI 的基本单元，通过<code>Widget</code>可以做到：</p><ul><li>描述 UI 的层级结构 (通过<code>Widget</code>嵌套)；</li><li>定制 UI 的具体样式 (如：<code>font</code>、<code>color</code>等)；</li><li>指导 UI 的布局过程 (如：<code>padding</code>、<code>center</code>等)；</li><li>…</li></ul><p>Google 在设计<code>Widget</code>时，还赋予它一些鲜明的特点：</p><ul><li><p>声明式 UI —— 相对于传统 Native 开发中的命令式 UI，声明式 UI 有不少优势，如：开发效率显著提升、UI 可维护性明显加强等；</p></li><li><p>不可变性 —— Flutter 中所有<code>Widget</code>都是不可变的(immutable)，即其内部成员都是不可变的(<code>final</code>)，对于变化的部分需要通过「Stateful Widget-State」的方式实现；</p></li><li><p>组合大于继承 —— <code>Widget</code>设计遵循组合大于继承这一优秀的设计理念，通过将多个功能相对单一的<code>Widget</code>组合起来便可得到功能相对复杂的<code>Widget</code>。</p></li></ul><p>在<code>Widget</code>类定义处有这样一段注释：<br><img src="/img/Widget_Comment.png" alt=""><br>这段注释阐明了<code>Widget</code>的本质：<strong>用于配置<code>Element</code>的，<code>Widget</code>本质上是 UI 的配置信息 (附带部分业务逻辑)。</strong></p><blockquote><p>我们通常会将通过<code>Widget</code>描述的 UI 层级结构称之为「Widget Tree」，但与「Element Tree」、「RenderObject Tree」以及「Layer Tree」相比，实质上并不存在「Widget Tree」。为了描述方便，将 Widget 组合描述的 UI 层级结构称之为「Widget Tree」，也未尝不可。</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><img src="/img/Widget.png" alt=""><br>如上图所示，按照功能划分<code>Widget</code>大致可以分为 3 类：</p><ul><li><p><em>「Component Widget」</em> —— 组合类 Widget，这类 Widget 都直接或间接继承于<code>StatelessWidget</code>或<code>StatefulWidget</code>，上一小节提到过在 Widget 设计上遵循组合大于继承的原则，通过组合功能相对单一的 Widget 可以得到功能更为复杂的 Widget。平常的业务开发主要是在开发这一类型的 Widget；</p></li><li><p><em>「Proxy Widget」</em> —— 代理类 Widget，正如其名，「Proxy Widget」本身并不涉及 Widget 内部逻辑，只是为「Child Widget」提供一些附加的中间功能。典型的如：<code>InheritedWidget</code>用于在「Descendant Widgets」间传递共享信息、<code>ParentDataWidget</code>用于配置「Descendant Renderer Widget」的布局信息；</p></li><li><p><em>「Renderer Widget」</em> —— 渲染类 Widget，是最核心的<code>Widget</code>类型，会直接参与后面的「Layout」、「Paint」流程，无论是「Component Widget」还是「Proxy Widget」最终都会映射到「Renderer Widget」上，否则将无法被绘制到屏幕上。这 3 类 Widget 中，<strong>只有「Renderer Widget」有与之一一对应的「Render Object」</strong>。</p></li></ul><h2 id="核心方法源码分析"><a href="#核心方法源码分析" class="headerlink" title="核心方法源码分析"></a>核心方法源码分析</h2><p>下面，我们重点介绍各类型 Widget 的核心方法，以便更好地理解 Widget 是如何参与整个 UI 的构建过程。</p><h3 id="Widget-1"><a href="#Widget-1" class="headerlink" title="Widget"></a>Widget</h3><p><code>Widget</code>，所有 Widget 的基类。</p><div style="width: 400px; margin: auto"><img src="/img/Widget_Method.png" alt=""></div><p>如上图所示，在 <code>Widget</code>基类中有 3 个重要的方法 (属性)：</p><ul><li><p><em>Key key</em> —— 在同一父节点下，用作兄弟节点间的唯一标识，主要用于控制当 Widget 更新时，对应的 Element 如何处理 (是更新还是新建)。若某 Widget 是其「Parent Widget」唯一的子节点时，一般不用设置 key；</p><blockquote><p>GlobalKey 是一类较特殊的 key，在介绍 Element 时会附带介绍。</p></blockquote></li><li><p><em>Element createElement()</em> —— 每个<code>Widget</code>都有一个与之对应的<code>Element</code>，由该方法负责创建，<code>createElement</code>可以理解为设计模式中的<em>工厂方法</em>，具体的<code>Element</code>类型由对应的<code>Widget</code>子类负责创建；</p></li><li><p><em>static bool canUpdate(Widget oldWidget, Widget newWidget)</em> —— 是否可以用 new widget 修改前一帧用 old widget 生成的 Element，而不是创建新的 Element，<code>Widget</code>类的默认实现为：2个<code>Widget</code>的<code>runtimeType</code>与<code>key</code>都相等时，返回<code>true</code>，即可以直接更新 (key 为 null 时，认为相等)。</p><blockquote><p>上述更新流程，同样在介绍 Element 时会重点分析。</p></blockquote></li></ul><h3 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h3><p>无状态-组合型 Widget，由其<code>build</code>方法描述组合 UI 的层级结构。在其生命周期内状态不可变。<br><img src="/img/StatelessWidget_Comment.png" alt=""></p><div style="width: 400px; margin: auto"><img src="/img/StatelessWidget_Method.png" alt=""></div><blockquote><p>ps: 对于有父子关系的类，在子类中只会介绍新增或有变化的方法</p></blockquote><ul><li><p><em>StatelessElement createElement()</em> ——「Stateless Widget」对应的 Element 为<code>StatelessElement</code>，一般情况下<code>StatelessWidget</code>子类不必重写该方法，即子类对应的 Element 也是<code>StatelessElement</code>；</p></li><li><p><em>Widget build(BuildContext context)</em> —— 算是 Flutter 体系中的核心方法之一，以『声明式 UI』的形式描述了该组合式 Widget 的 UI 层级结构及样式信息，也是开发 Flutter 应用的主要工作『场所』。该方法在 3 种情况下被调用：</p><ul><li>Widget 第一次被加入到 Widget Tree 中 (更准确地说是其对应的 Element 被加入到 Element Tree 时，即 Element 被挂载『mount』时)；</li><li>「Parent Widget」修改了其配置信息；</li><li>该 Widget 依赖的「Inherited Widget」发生变化时。</li></ul></li></ul><p>当「Parent Widget」或 依赖的「Inherited Widget」频繁变化时，<code>build</code>方法也会频繁被调用。因此，提升<code>build</code>方法的性能就显得十分重要，Flutter 官方给出了几点建议：</p><ul><li><p><em>减少不必要的中间节点，即减少 UI 的层级，</em>如：对于「Single Child Widget」，没必要通过组合「Row」、「Column」、「Padding」、「SizedBox」等复杂的 Widget 达到某种布局的目标，或许通过简单的「Align」、「CustomSingleChildLayout」即可实现。又或者，为了实现某种复杂精细的 UI 效果，不一定要通过组合多个「Container」，再附加「Decoration」来实现，通过 「CustomPaint」自定义或许是更好的选择；</p></li><li><p><em>尽可能使用<code>const</code> Widget，</em>为 Widget 提供<code>const</code>构造方法；</p><blockquote><p>关于 const constructor 推荐 <a href="https://japhr.blogspot.com/2012/12/dart-constant-constructors.html" target="_blank" rel="noopener">Dart Constant Constructors</a> 看看这篇文章的评论。</p></blockquote></li><li><p>必要时，<em>可以将「Stateless Widget」重构成「Stateful Widget」，</em>以便可以使用「Stateful Widget」中一些特定的优化手法，如：缓存「sub trees」的公共部分，并在改变树结构时使用<code>GlobalKey</code>；</p></li><li><p><em>尽量减小 rebuilt 范围，</em>如：某个 Widget 因使用了「Inherited Widget」，导致频繁 rebuilt，可以将真正依赖「Inherited Widget」的部分提取出来，封装成更小的独立 Widget，并尽量将该独立 Widget 推向树的叶子节点，以便减小 rebuilt 时受影响的范围。</p></li></ul><h3 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h3><p>有状态-组合型 Widget，但要注意的是<code>StatefulWidget</code>本身还是不可变的，其可变状态存在于<code>State</code>中。<br><img src="/img/Stateful_Comment.png" alt=""></p><div style="width: 400px; margin: auto"><img src="/img/StatefulWidget_Method.png" alt=""></div><ul><li><p><em>StatefulElement createElement()</em> ——「Stateful Widget」对应的 Element 为<code>StatefulElement</code>，一般情况下<code>StatefulWidget</code>子类不用重写该方法，即子类对应的Element 也是<code>StatefulElement</code>；</p></li><li><p><em>State createState()</em> —— 创建对应的 State，该方法在<code>StatefulElement</code>的构造方法中被调用。可以简单地理解为当「Stateful Widget」被添加到 Widget Tree 时会调用该方法。</p>  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码已精简处理(本文中其他代码会做同样的简化处理)</span></span><br><span class="line">StatefulElement(StatefulWidget widget)</span><br><span class="line">     : _state = widget.createState(),</span><br><span class="line">       <span class="keyword">super</span>(widget) &#123;</span><br><span class="line">   _state._element = <span class="keyword">this</span>;</span><br><span class="line">   _state._widget = widget;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>实际上是「Stateful Widget」对应的「Stateful Element」被添加到 Element Tree 时，伴随「Stateful Element」的初始化，<code>createState</code>方法被调用。从后文可知一个 Widget 实例可以对应多个 Element 实例 (也就是同一份配置信息 (Widget) 可以在 Element Tree 上不同位置配置多个 Element 节点)，因此，<code>createState</code>方法在「Stateful Widget」生命周期内可能会被调用多次。<br>另外，需要注意的是配有<code>GlobalKey</code>的 Widget 对应的 Element 在整个 Element Tree 中只有一个实例。</p></blockquote><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><blockquote><p>The logic and internal state for a 「Stateful Widget」.</p></blockquote><p>State 用于处理「Stateful Widget」的业务逻辑以及可变状态。<br>由于其内部状态是可变的，故 State 有较复杂的生命周期：<br><img src="/img/StateLifecycle.png" alt=""><br>如上图，State 的生命周期大致可以分为 8 个阶段：</p><ul><li><p>在对应的「Stateful Element」被挂载 (mount) 到树上时，通过<code>StatefulElement.constructor</code> –&gt; <code>StatefulWidget.createState</code>创建 State 实例；</p><blockquote><p>从<code>StatefulElement.constructor</code>中的<code>_state._element = this;</code>可知，<code>State._emelent</code>指向了对应的 Element 实例，而我们熟知的<code>State.context</code>引用的就是这个<code>_element</code>：<code>BuildContext get context =&gt; _element;</code>。<br><code>State</code>实例与<code>Element</code>实例间的绑定关系一经确定，在整个生命周期内不会再变了 (<strong>Element 对应的 Widget 可能会变，但对应的 State 永远不会变</strong>)，期间，<code>Element</code>可以在树上移动，但上述关系不会变 (即「Stateful Element」是带着状态移动的)。</p></blockquote></li><li><p>StatefulElement 在挂载过程中接着会调用<code>State.initState</code>，子类可以重写该方法执行相关的初始化操作 (此时可以引用<code>context</code>、<code>widget</code>属性)；</p></li><li><p>同样在挂载过程中会调用<code>State.didChangeDependencies</code>，该方法在 State 依赖的对象 (如：「Inherited Widget」) 状态发生变化时也会被调用，<em>子类很少需要重写该方法，</em>除非有非常耗时不宜在<code>build</code>中进行的操作，因为在依赖有变化时<code>build</code>方法也会被调用；</p></li><li><p>此时，State 初始化已完成，其<code>build</code>方法此后可能会被多次调用，在状态变化时 State 可通过<code>setState</code>方法来触发其子树的重建；</p></li><li><p>此时，「element tree」、「renderobject tree」、「layer tree」已构建完成，完整的 UI 应该已呈现出来。此后因为变化，「element tree」中「parent element」可能会对树上该位置的节点用新配置 (Widget) 进行重建，当新老配置 (oldWidget、newWidget)具有相同的「runtimeType」&amp;&amp;「key」时，framework 会用 newWidget 替换 oldWidget，并触发一系列的更新操作 (在子树上递归进行)。同时，<code>State.didUpdateWidget</code>方法被调用，子类重写该方法去响应 Widget 的变化；</p><blockquote><p>上述 3 棵树以及更新流程在后续文章中会有详细介绍</p></blockquote></li><li><p>在 UI 更新过程中，任何节点都有被移除的可能，State 也会随之移除，(如上一步中「runtimeType」||「key」不相等时)。此时会调用<code>State.deactivate</code>方法，由于被移除的节点可能会被重新插入树中某个新的位置上，故子类重写该方法以清理与节点位置相关的信息 (如：该 State 对其他 element 的引用)、同时，不应在该方法中做资源清理；</p><blockquote><p>重新插入操作必须在当前帧动画结束之前</p></blockquote></li><li><p>当节点被重新插入树中时，<code>State.build</code>方法被再次调用；</p></li><li><p>对于在当前帧动画结束时尚未被重新插入的节点，<code>State.dispose</code>方法被执行，State 生命周期随之结束，此后再调用<code>State.setState</code>方法将报错。子类重写该方法以释放任何占用的资源。</p></li></ul><p><img src="/img/State_Method.png" alt=""><br>至此，State 中的核心方法基本都已在上述过程中介绍了，下面重点看一下<code>setState</code>方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(fn != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_debugLifecycleState == _StateLifecycle.defunct) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_debugLifecycleState == _StateLifecycle.created &amp;&amp; !mounted) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">dynamic</span> result = fn() <span class="keyword">as</span> <span class="keyword">dynamic</span>;</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">is</span> Future) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">  _element.markNeedsBuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述源码可以看到，关于<code>setState</code>方法有几点值得关注：</p><ul><li><p>在<code>State.dispose</code>后不能调用<code>setState</code> (第 4 行)；</p></li><li><p>在 State 的构造方法中不能调用<code>setState</code> (第 7 行)；</p></li><li><p><code>setState</code>方法的回调函数 (<code>fn</code>) 不能是异步的 (返回值为<code>Future</code>)，原因很简单，因为从流程设计上 framework 需要根据回调函数产生的新状态去刷新 UI (第 14 行)；</p></li><li><p>通过<code>setState</code>方法之所以能更新 UI，是在其内部调用<code>_element.markNeedsBuild()</code>实现的 (具体过程在介绍 Element 时再详细分析)。</p></li></ul><p>关于 State 最后再强调 2 点：</p><ul><li>若<code>State.build</code>方法依赖了自身状态会变化的对象，如：<code>ChangeNotifier</code>、<code>Stream</code>或其他可以被订阅的对象，需要确保在<code>initState</code>、<code>didUpdateWidget</code>、<code>dispose</code>等 3 方法间有正确的订阅 (subscribe) 与取消订阅 (unsubscribe) 的操作：<ul><li>在<code>initState</code>中执行 subscribe；</li><li>如果关联的「Stateful Widget」与订阅有关，在<code>didUpdateWidget</code>中先取消旧的订阅，再执行新的订阅；</li><li>在<code>dispose</code>中执行 unsubscribe。</li></ul></li></ul><ul><li>在<code>State.initState</code>方法中不能调用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>，但<code>State.didChangeDependencies</code>会随之执行，在该方法中可以调用。</li></ul><h3 id="ParentDataWidget"><a href="#ParentDataWidget" class="headerlink" title="ParentDataWidget"></a>ParentDataWidget</h3><p><code>ParentDataWidget</code>以及下面要介绍的<code>InheritedElement</code>都继承自<code>ProxyWidget</code>，由于<code>ProxyWidget</code>作为抽象基类本身没有任何功能，故下面直接介绍<code>ParentDataWidget</code>、<code>InheritedElement</code>。<br><img src="/img/ParentDataWidget_Comment.png" alt=""><br><code>ParentDataWidget</code>作为 Proxy 型 Widget，其功能主要是为其他 Widget 提供<code>ParentData</code>信息。虽然其 child widget 不一定是 RenderObejctWidget 类型，但其提供的<code>ParentData</code>信息最终都会落地到 RenderObejctWidget 类型子孙 Widget 上。</p><blockquote><p>ParentData 是『parent renderobject』在 layout『child renderobject』时使用的辅助定位信息，详细信息会在介绍 RenderObject 时介绍。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRenderObject(<span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_ancestorRenderObjectElement == <span class="keyword">null</span>);</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class="line">  _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);</span><br><span class="line">  <span class="keyword">final</span> ParentDataElement&lt;RenderObjectWidget&gt; parentDataElement = _findAncestorParentDataElement();</span><br><span class="line">  <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</span><br><span class="line">    _updateParentData(parentDataElement.widget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ParentDataElement&lt;RenderObjectWidget&gt; _findAncestorParentDataElement() &#123;</span><br><span class="line">  <span class="built_in">Element</span> ancestor = _parent;</span><br><span class="line">  <span class="keyword">while</span> (ancestor != <span class="keyword">null</span> &amp;&amp; ancestor <span class="keyword">is</span>! RenderObjectElement) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ancestor <span class="keyword">is</span> ParentDataElement&lt;RenderObjectWidget&gt;)</span><br><span class="line">      <span class="keyword">return</span> ancestor;</span><br><span class="line">    ancestor = ancestor._parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _updateParentData(ParentDataWidget&lt;RenderObjectWidget&gt; parentData) &#123;</span><br><span class="line">  parentData.applyParentData(renderObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码来自<code>RenderObjectElement</code>，可以看到在其<code>attachRenderObject</code>方法第 6 行从祖先节点找<code>ParentDataElement</code>，如果找到就用其 Widget(ParentDataWidget) 中的 parentData 信息去设置 Render Obejct。在查找过程中如查到<code>RenderObjectElement</code> (第 13 行)，说明当前 RenderObject 没有 Parent Data 信息。<br>最终会调用到<code>ParentDataWidget.applyParentData(RenderObject renderObject)</code>，子类需要重写该方法，以便设置对应<code>RenderObject.parentData</code>。</p><div style="width: 400px; margin: auto"><img src="/img/ParentDataWidget_Method.png" alt=""></div><p>来看个例子，通常配合<code>Stack</code>使用的<code>Positioned</code>(继承自ParentDataWidget)：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> applyParentData(RenderObject renderObject) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(renderObject.parentData <span class="keyword">is</span> StackParentData);</span><br><span class="line">  <span class="keyword">final</span> StackParentData parentData = renderObject.parentData;</span><br><span class="line">  <span class="built_in">bool</span> needsLayout = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parentData.left != left) &#123;</span><br><span class="line">    parentData.left = left;</span><br><span class="line">    needsLayout = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (parentData.width != width) &#123;</span><br><span class="line">    parentData.width = width;</span><br><span class="line">    needsLayout = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (needsLayout) &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNode targetParent = renderObject.parent;</span><br><span class="line">    <span class="keyword">if</span> (targetParent <span class="keyword">is</span> RenderObject)</span><br><span class="line">      targetParent.markNeedsLayout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<code>Positioned</code>在必要时将自己的属性赋值给了对应的<code>RenderObject.parentData</code> (此处是<code>StackParentData</code>)，并对「parent render object」调用<code>markNeedsLayout</code>(第 19 行)，以便重新 layout，毕竟修改了布局相关的信息。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentDataWidget</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span>&gt; <span class="keyword">extends</span> <span class="title">ProxyWidget</span></span></span><br></pre></td></tr></table></figure><p>如上所示，<code>ParentDataWidget</code>在定义上使用了泛型<code>&lt;T extends RenderObjectWidget&gt;</code>，其背后的含义是：<br><em>从当前<code>ParentDataWidget</code>节点向上追溯形成的祖先节点链(『parent widget chain』)上，在 2 个<code>ParentDataWidget</code>类型的节点形成的链上至少要有一个『RenderObject Widget』类型的节点。因为一个『RenderObject Widget』不能接受来自 2 个及以上『ParentData Widget』的信息。</em></p><div style="width: 400px; margin: auto"><img src="/img/ParentDataWidget_Chain.png" alt=""></div><h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p><img src="/img/InheritedWidget_Comment.jpg" alt=""><br>InheritedWidget 用于在树上向下传递数据。<br>通过<code>BuildContext.dependOnInheritedWidgetOfExactType</code>可以获取最近的「Inherited Widget」，需要注意的是通过这种方式获取「Inherited Widget」时，当「Inherited Widget」状态有变化时，会导致该引用方 rebuild。</p><blockquote><p>具体原理在介绍 Element 时会详细分析。</p></blockquote><p>通常，为了使用方便会「Inherited Widget」会提供静态方法<code>of</code>，在该方法中调用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>。<code>of</code>方法可以直接返回「Inherited Widget」，也可以是具体的数据。</p><p>有时，「Inherited Widget」是作为另一个类的实现细节而存在的，其本身是私有的(外部不可见)，此时<code>of</code>方法就会放到对外公开的类上。最典型的例子就是<code>Theme</code>，其本身是<code>StatelessWidget</code>类型，但其内部创建了一个「Inherited Widget」：<code>_InheritedTheme</code>，<code>of</code>方法就定义在上<code>Theme</code>上：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThemeData of(BuildContext context, &#123; <span class="built_in">bool</span> shadowThemeOnly = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> _InheritedTheme inheritedTheme = context.dependOnInheritedWidgetOfExactType&lt;_InheritedTheme&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ThemeData.localize(theme, theme.typography.geometryThemeFor(category));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该<code>of</code>方法返回的是<code>ThemeData</code>类型的具体数据，并在其内部首先调用了<code>BuildContext.dependOnInheritedWidgetOfExactType</code>。</p><p>我们经常使用的「Inherited Widget」莫过于<code>MediaQuery</code>，同样提供了<code>of</code>方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MediaQueryData of(BuildContext context, &#123; <span class="built_in">bool</span> nullOk = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> MediaQuery query = context.dependOnInheritedWidgetOfExactType&lt;MediaQuery&gt;();</span><br><span class="line">  <span class="keyword">if</span> (query != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> query.data;</span><br><span class="line">  <span class="keyword">if</span> (nullOk)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="width: 400px; margin: auto"><img src="/img/InheritedWidget_Method.png" alt=""></div><ul><li><p><em>InheritedElement createElement()</em> ——「Inherited Widget」对应的 Element 为<code>InheritedElement</code>，一般情况下<code>InheritedElement</code>子类不用重写该方法；</p></li><li><p><em>bool updateShouldNotify(covariant InheritedWidget oldWidget)</em> —— 在「Inherited Widget」rebuilt 时判断是否需要 rebuilt 那些依赖它的 Widget；</p></li></ul><p>如下是<code>MediaQuery.updateShouldNotify</code>的实现，在新老<code>Widget.data</code> 不相等时才 rebuilt 那依赖的 Widget。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> updateShouldNotify(MediaQuery oldWidget) =&gt; data != oldWidget.data;</span><br></pre></td></tr></table></figure></p><h3 id="RenderObjectWidget"><a href="#RenderObjectWidget" class="headerlink" title="RenderObjectWidget"></a>RenderObjectWidget</h3><p>真正与渲染相关的 Widget，属于最核心的类型，一切其他类型的 Widget 要渲染到屏幕上，最终都要回归到该类型的 Widget 上。</p><div style="width: 400px; margin: auto"><img src="/img/RenderObjectWidget_Method.png" alt=""></div><ul><li><p><em>RenderObjectElement createElement()</em> ——「RenderObject Widget」对应的 Element 为<code>RenderObjectElement</code>，由于<code>RenderObjectElement</code>也是抽象类，故子类需要重写该方法；</p></li><li><p><em>RenderObject createRenderObject(BuildContext context)</em> —— 核心方法，创建 Render Widget 对应的 Render Object，同样子类需要重写该方法。该方法在对应的 Element 被挂载到树上时调用(<code>Element.mount</code>)，即在 Element 挂载过程中同步构建了「Render Tree」(详细过程后续文章会详细分析)；</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">RenderFlex createRenderObject(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> RenderFlex(</span><br><span class="line">    direction: direction,</span><br><span class="line">    mainAxisAlignment: mainAxisAlignment,</span><br><span class="line">    mainAxisSize: mainAxisSize,</span><br><span class="line">    crossAxisAlignment: crossAxisAlignment,</span><br><span class="line">    textDirection: getEffectiveTextDirection(context),</span><br><span class="line">    verticalDirection: verticalDirection,</span><br><span class="line">    textBaseline: textBaseline,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面是<code>Flex.createRenderObject</code>的源码，真实感受一下 (还是代码更有感觉)。可以看到，用<code>Flex</code>的信息(配置)初始化了<code>RenderFlex</code>。</p><blockquote><p><code>Flex</code>是<code>Row</code>、<code>Column</code>的基类，<code>RenderFlex</code>继承自<code>RenderBox</code>，后者继续自<code>RenderObject</code>。</p></blockquote></li><li><p><em>void updateRenderObject(BuildContext context, covariant RenderObject renderObject)</em> —— 核心方法，在 Widget 更新后，修改对应的 Render Object。该方法在首次 build 以及需要更新 Widget 时都会调用；</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> updateRenderObject(BuildContext context, covariant RenderFlex renderObject) &#123;</span><br><span class="line">  renderObject</span><br><span class="line">    ..direction = direction</span><br><span class="line">    ..mainAxisAlignment = mainAxisAlignment</span><br><span class="line">    ..mainAxisSize = mainAxisSize</span><br><span class="line">    ..crossAxisAlignment = crossAxisAlignment</span><br><span class="line">    ..textDirection = getEffectiveTextDirection(context)</span><br><span class="line">    ..verticalDirection = verticalDirection</span><br><span class="line">    ..textBaseline = textBaseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>Flex.updateRenderObject</code>的源码也很简单，与<code>Flex.createRenderObject</code>几乎一一对应，用当前<code>Flex</code>的信息修改<code>renderObject</code>。</p></li><li><p><em>void didUnmountRenderObject(covariant RenderObject renderObject)</em> —— 对应的「Render Object」从「Render Tree」上移除时调用该方法。</p></li></ul><blockquote><p><code>RenderObjectWidget</code>的几个子类：<code>LeafRenderObjectWidget</code>、<code>SingleChildRenderObjectWidget</code>、<code>MultiChildRenderObjectWidget</code>只是重写了<code>createElement</code>方法以便返回各自对应的具体的 Element 类实例。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>至此，重要的基础型 Widget 基本介绍完了，总结一下：</p><ul><li><p>Widget 本质上是 UI 的配置信息 (附加部分业务逻辑)，并不存在一颗真实的「Widget Tree」(与「Element Tree」、「RenderObject Tree」以及「Layer Tree」相比)；</p></li><li><p>Widget 从功能上可以分为 3 类：「Component Widget」、「Proxy Widget」以及「Renderer Widget」；</p></li><li><p>Widget 与 Element 一一对应，Widget 提供创建 Element 的方法 (<code>createElement</code>，本质上是一个工厂方法)；</p></li><li><p>只有「Renderer Widget」才会参与最终的 UI 生成过程(Layout、Paint)，只有该类型的 Widget 才有与之对应的「Render Object」，同样由其提供创建方法(<code>createRenderObject</code>)。</p></li></ul><p>下篇再见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是『 深入浅出 Flutter Framework 』系列文章的第一篇，主要以不同类型 Widget 的核心方法为切入点，对其展开详细分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://zxfcumtcs.github.io/tags/flutter/"/>
    
      <category term="移动开发" scheme="http://zxfcumtcs.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨平台" scheme="http://zxfcumtcs.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>论面向接口编程</title>
    <link href="http://zxfcumtcs.github.io/2019/12/04/InterfaceBasedProgramming/"/>
    <id>http://zxfcumtcs.github.io/2019/12/04/InterfaceBasedProgramming/</id>
    <published>2019-12-04T14:25:55.000Z</published>
    <updated>2021-01-09T12:55:39.049Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先从接口的实现方、使用方角度阐述了什么是接口，其次分析了面向接口编程的意义。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="我眼中的接口"><a href="#我眼中的接口" class="headerlink" title="我眼中的接口"></a>我眼中的接口</h1><hr><p>面向接口编程作为口号可以说是妇孺皆知，臭大街了！<br>但在日常开发、交流过程中发现很多同学对面向接口编程的理解还是有所偏差。<br>因此，想通过这篇小短文，谈谈我对面向接口编程的理解，希望对大家有所帮助。</p><p>首先要回答的问题就是：<br>接口是什么？</p><ul><li><code>C++</code>、<code>JavaScript</code>、<code>dart</code>的 (abstract)<code>class</code>——『形式上的接口』</li><li><code>Objective-C</code>的<code>delegate</code>、<code>Swift</code>的<code>protocol</code>、<code>Java</code>的<code>interface</code>——『语义上的接口』</li></ul><blockquote><p>接口属于面向对象编程(OOP)的范畴</p></blockquote><p>这样的答案无疑是『政治正确』的，但并非我们想要的，我想从另外一个角度来看待这个问题：</p><blockquote><p>接口是一种抽象</p></blockquote><ul><li>接口使用方：<strong>对外界『依赖』的抽象，表明其依赖哪些能力</strong>；</li><li>接口实现方：<strong>对自我『能力』的抽象，宣称其具备哪些能力</strong>。</li></ul><p>正是由于接口的抽象性，接口使用方与实现方才得以解耦。<br>下面，我们以<code>UITableViewDataSource</code>为例，来具体感受一下：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITableViewDataSource</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section;</span><br><span class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>UITableView</code>对 iOS 开发同学来说再熟悉不过了，其有一个需要实现<code>UITableViewDataSource</code>接口的属性<code>dataSource</code>。<br><code>UITableView</code>作为<code>UITableViewDataSource</code>接口的<strong>使用方</strong>，很清楚的表明了其对外界的依赖：</p><ul><li><code>numberOfRowsInSection:</code>——依赖外界告诉它，某个 section 有几行；</li><li><code>cellForRowAtIndexPath:</code>——依赖外界提供某个 indexPath 处的cell；</li><li>…</li></ul><p>总之，通过<code>UITableViewDataSource</code>清楚地表明了<code>UITableView</code>需要哪些能力的支持，也就清楚地说明了该如何去使用<code>UITableView</code>。</p><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ABCViewController</span> () &lt;<span class="title">UITableViewDelegate</span>,<span class="title">UITableViewDataSource</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>通过上面这行代码，我们就能清晰地知道，<code>ABCViewController</code>具有<code>numberOfRowsInSection</code>、<code>cellForRowAtIndexPath</code>等能力，因为其实现了<code>UITableViewDataSource</code>接口！也就是其可以供<code>UITableView</code>使用。</p><blockquote><p><code>UITableView</code>之所以有如此好的通用性，就是采用了面向接口编程，将其对外界的依赖抽象成2个接口：<code>UITableViewDelegate</code>、<code>UITableViewDataSource</code>，即只要是实现了这两个接口的都可以为其所用。</p></blockquote><h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><hr><ul><li><strong>简洁、易维护</strong>——如上节所提到的<code>UITableView</code>，其内部实现想必非常复杂，但由于有<code>UITableViewDelegate</code>、<code>UITableViewDataSource</code>两个抽象接口，表明了其对使用方的依赖，我们非常容易地就可以使用<code>UITableView</code>，无须关心其内部细节，只要实现这两个接口即可；</li><li><strong>解耦</strong>——接口作为一个抽象层，很好地将使用方与实现方隔离开来，使得两者不再有直接依赖关系，双方的复用性、扩展性(尤其是接口使用方)得到极大提高，具体例子可以参考<a href="https://zxfcumtcs.github.io/2017/03/04/CustomUIControls/">自定义 UI 组件库</a>这篇文章；</li><li><strong>分工协作</strong>——通过接口使得原本相互依赖的双方得以很好的解耦，分工协作更加顺畅，双方可以并行开发，互不干扰；</li><li><strong>可测性更好</strong>——这里主要指接口使用方的测试，因为通过接口可以更方便地 mock 数据供接口使用方测试用；</li><li><strong>拥抱变化</strong>——对开发同学来说最憎恨的莫过于已经开发好的或开发中的需求又变了，除了『撕』之外，我们还可以采取积极的防御措施，通过接口『隔离变化』，将变化带来的影响降到最低。</li></ul><p><img src="/img/tab_page.png" alt=""><br>这是一个前不久在项目中真实遇到的例子，某个页面，当初只有 A、B 两个 tab，但在开发过程中又变成 A、B、C 三个 tab，之后又变成了 D、E 两个 tab。(每个 tab 的数据开源、UI 样式完成不一样)</p><p>刚开始时，A、B 两个 tab 的逻辑是直接放在主页面里面的<br>当产品需要增加 C tab 时，隐约感到情况不妙<br>为了，防止后续还有改动带来的影响，决定将 tab 相关的逻辑抽离出来，主页面不再依赖于某个特定的 tab，而是依赖于抽象后的接口。<br>需要放到该主页面的 tab 自行实现这套接口即可。<br>从此，tab 的增删改就与主页面无关了，即实现了 『OCP』，这也是23种经典设计模式之一的：『策略模式』。</p><p>总之，面向接口，即面向简洁、面向变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先从接口的实现方、使用方角度阐述了什么是接口，其次分析了面向接口编程的意义。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计" scheme="http://zxfcumtcs.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>函数式思维</title>
    <link href="http://zxfcumtcs.github.io/2019/11/17/functional/"/>
    <id>http://zxfcumtcs.github.io/2019/11/17/functional/</id>
    <published>2019-11-17T14:04:04.000Z</published>
    <updated>2019-11-24T09:23:40.887Z</updated>
    
    <content type="html"><![CDATA[<p>函数式编程中有很多优秀的设计理念值得我们去学习，本文对函数式编程中的基础理念进行了简要的介绍，但更重要的是思考、总结如何将它们应用到我们日常开发中，帮助我们去提升代码的可读性、可维护性等。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>对函数式编程一直有所耳闻，但并未深入研究过，在日常开发中也很少去思考这方面的问题。<br>直到最近，在开发 flutter 应用时，由于 dart 对函数式编程有较好地支持，对函数式编程有了更新的认识。<br>纯函数式的编程对我们正常的业务开发来说是一种『乌托邦』式的存在，但其中有很多的设计理念值得我们去学习。<br>函数式编程相关的文章也有不少，本文的不同之处在于其立足点是：<br>如何利用函数式编程理念帮助我们写出更好的代码，这也是本文标题叫做函数式思维而不是函数式编程的原因。</p><blockquote><p>函数式编程的理论基础是<code>λ</code>演算(lambda calculus)，但本文并不打算在理论层面上做过多的讨论。</p></blockquote><p>首先，总结一下我个人的观点：函数式编程能给我们带来什么？<br>简单、清晰、易维护、可复用的代码。</p><blockquote><p>简单、清晰、易维护、可复用可以说是各种架构设计、设计规范追求的第一目标。</p></blockquote><p>那函数式编程又是通过什么方式实现这样的收益的：</p><ul><li>状态不可变、纯函数；</li><li>避免引入状态，Pointfree；</li><li>强调组合、提高复用性；</li><li>更高层次的抽象，丰富的集合操作。</li></ul><p>本文将主要围绕以上几方面对函数式编程展开讨论。</p><h1 id="Functional-vs-Imperative"><a href="#Functional-vs-Imperative" class="headerlink" title="Functional vs. Imperative"></a>Functional vs. Imperative</h1><hr><p>函数式编程作为编程范式(Programming Paradigm)之一，与之对应的，也是我们最熟悉的命令式编程(Imperative programming，面向对象编程也属于该范式)。</p><p>从思维模式上说：</p><ul><li>命令式编程：『过程导向』，<strong>强调怎么做</strong>——关注点在执行步骤，如何一步一步地去完成任务；</li><li>函数式编程：『结果导向』，<strong>强调做什么</strong>——关注点在执行结果，相比属于更高层次的抽象，并不关心实现细节。</li></ul><p>从理论依据上说：</p><ul><li>命令式编程：面向计算机的模型，变量、赋值、控制语句等分别对应计算机的物理存储、读写指令、跳转指令；</li><li>函数式编程：面向数学的模型，将任务以表达式求值的形式表现。</li></ul><p>从实现手法上说：<br>函数式编程是对命令式编程进一步的抽象，屏蔽具体细节，以更加抽象、更加接近自然语言的方式去描述程序的意图，将实现细节交由语言运行时或三方扩展去完成。<br>从而，开发人员可以从实现细节中解脱出来，站在更高的抽象层次上去思考业务问题。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>纯函数、高阶函数、函数一等公民身份、集合操作三板斧等理念极大地提高了语言的创造力、表现力。<br>虽然无法做到纯函数式，但越来越多的高级语言开始向函数式方向发展，将函数式中的若干重要理念引入自身语法中，如：JavaScript、Swift、Java、dart 等。</p><h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><hr><p>函数式编程中的『函数』并非我们日常开发中所说的函数(方法)，而是数学意义上的函数——映射。<br>我们知道数学上函数(映射)对相同的输入必定有相同的输出(映射关系是一一对应的)。<br>因此，函数式编程中纯函数也要满足同样的特征：</p><ul><li>相同的输入，必定得到相同的输出；</li><li>函数调用没有任何副作用。</li></ul><h2 id="相同的输入，相同的输出"><a href="#相同的输入，相同的输出" class="headerlink" title="相同的输入，相同的输出"></a>相同的输入，相同的输出</h2><p>要满足这一点，意味着函数不能依赖除入参以外的任何外部状态。<br>面向对象中类的成员函数隐式地包含<code>this</code>指针，通过它可以很方便地在成员函数中引用成员变量，这就是纯函数的典型反面教材。</p><p>为什么？<br>实现了函数级的解耦，除了入参没有复杂的依赖关系，这样的函数可读性、可维护性就变得很高。<br>相信大家在平常开发中，也能有这样的感受：<br>在理解、维护一个函数时，若其依赖了大量的外部状态，必定会造成不小的认知压力。<br>除了要理解函数本身的逻辑外，还要去关心其引用的外部状态信息。<br>有时不得不跳出函数本身去查看这些依赖的外部信息，阅读流程也因此被打断。</p><h2 id="无副作用"><a href="#无副作用" class="headerlink" title="无副作用"></a>无副作用</h2><p>副作用是指除期望的函数输出值外的任何产出。</p><p>常见的副作用包括，但不限于：</p><ul><li>改变外部数据(如类的成员变量、全局变量)；</li><li>发送网络请求；</li><li>读写文件；</li><li>执行DB操作；</li><li>获取用户交互信息(用户输入)；</li><li>读取系统状态信息；</li><li>打日志；</li><li>…</li></ul><p>总之，纯函数就是不能与外部有任何的耦合关系，包括对外界的依赖以及对外界的影响。</p><p>很明显，纯函数的收益主要有：</p><ul><li>可维护性更高；</li><li>可测性更强；</li><li>可复用性更好；</li><li>高并发更容易，没有多线程问题；</li><li>可缓存，由于相同的输入，必定有相同的输出，因此对于高频、昂贵的操作可以缓存结果，避免重复计算。</li></ul><p>在实际开发中，虽然无法做到所有函数都是纯函数，但纯函数意识应该要深植我们脑海中，尽可能地写更多的纯函数。</p><h1 id="高阶函数-Higher-order-function"><a href="#高阶函数-Higher-order-function" class="headerlink" title="高阶函数(Higher-order function)"></a>高阶函数(Higher-order function)</h1><hr><p>函数式编程还有一个重要理念：<strong>函数是值</strong>，即一等函数(first-class)，或者说函数有一等公民身份。<br>这意味着任何可以使用值的地方都可以使用函数，如参数、返回值等。</p><p>所谓高阶函数就是其参数或返回值至少有一个是函数类型。<br>高阶函数使得复用粒度降到了函数级别，在面向对象中复用粒度一般在类级别。</p><blockquote><p>闭包(closure)是高阶函数得以实现的底层支撑能力。</p></blockquote><p>从另一个角度讲，高阶函数也实现了更高层级的抽象，因为实现细节可以通过参数的形式传入，即在函数级别上实现了依赖注入机制。因此，多种GoF设计模式可以通过高阶函数的形式来实现，如：Template Method模式、Strategy模式等。</p><h1 id="柯里化-Currying"><a href="#柯里化-Currying" class="headerlink" title="柯里化(Currying)"></a>柯里化(Currying)</h1><hr><p>简单讲，柯里化就是将『多参数函数』转换成『一系列单参数函数』的过程。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addCurrying = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，<code>add</code>是进行加法运算的函数，其接收2个参数，如<code>add(1, 2)</code>。<br>而<code>addCurrying</code>是经过柯里化处理过的，本质上<code>addCurrying</code>是单参数函数，其返回值也是一个单参数函数。<br><code>add(1, 2)</code>，等价于<code>addCurrying(1)(2)</code>。</p><p>柯里化有什么作用？</p><ul><li>在函数式集合操作上，如：<code>filter</code>、<code>map</code>、<code>reduce</code>、<code>expand</code>等只接收单参数函数，因此如果现有的函数是多参数，可通过柯里化转换成单参数；</li><li>当某个函数需要多次调用，且部分参数相同时，通过柯里化可以减少重复参数样板代码。</li></ul><p>如，有多次调用加法运算的需求，且每次都是加<code>10</code>时，用普通<code>add</code>函数实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(10, 1);</span><br><span class="line">add(10, 2);</span><br><span class="line">add(10, 3);</span><br></pre></td></tr></table></figure></p><p>而通过柯里化的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var addTen = addCurrying(10);</span><br><span class="line">addTen(1);</span><br><span class="line">addTen(2);</span><br><span class="line">addTen(3);</span><br></pre></td></tr></table></figure></p><p>著名的 JavaScript 三方库<code>lodash</code>提供了<code>curry</code>封装函数，使得柯里化更加方便，如上面的<code>addCurrying</code>用<code>lodash#curry</code>函数实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var curry = require(&apos;lodash&apos;).curry;</span><br><span class="line">var addCurrying = curry(function(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>对函数式编程来说，柯里化是一项不可或缺的技能。<br>对我们而言，即使不写函数式的代码，在解决重复参数等问题上柯里化也提供了一种全新的思路。</p><h1 id="集合操作三板斧"><a href="#集合操作三板斧" class="headerlink" title="集合操作三板斧"></a>集合操作三板斧</h1><hr><blockquote><p>函数式编程语言和面向对象语言对待代码重用的方式不一样。面向对象语言喜欢大量地建立有很多操作的各种数据结构，函数式语言也有很多的操作，但对应的数据结构却很少。面向对象语言鼓励我们建立专门针对某个类的方法，我们从类的关系中发现重复出现的模式并加以重用。函数式语言的重用表现在函数的通用性上，它们鼓励在数据结构上使用各种共通的变换，并通过高阶函数来调整操作以满足具体事项的要求。</p></blockquote><blockquote><p>在面向对象的命令式编程语言里面，重用的单元是类和用作类间通信的消息，通常可以表述成一幅类图(class diagram)。例如这个领域的开拓性著作《设计模式：可复用面向对象软件的基础》就给每一个模式都至少绘制了一幅类图。在OOP的世界里，开发者被鼓励针对具体的问题建立专门的数据结构，并以方法的形式，将专门的操作关联在数据结构上。函数式编程语言选择了另一种重用思路。它们用很少的一组关键数据结构(如list 、set 、map)来搭配专为这些数据结构深度优化过的操作。我们在这些关键数据结构和操作组成的一套运转机构上面，按需要“插入”另外的数据结构和高阶函数来调整机器，以适应具体的问题。例如我们已经在几种语言中操练过的filter函数，传给它的代码块就是这么一个“插入”的部件，筛选的条件由传入的高阶函数确定，而运转机构则负责高效率地实施筛选，并返回筛选后的列表。<br>——<a href="https://book.douban.com/subject/26587213/" target="_blank" rel="noopener">摘录来自: [美] 福特（Neal Ford）. “函数式编程思维 (图灵程序设计丛书)。”</a></p></blockquote><p>正如上述摘录所说，函数式编程的又一重要理念：<strong>在有限的集合(Collection)上提供丰富的操作</strong>。<br>现在，很多高级语言都提供了大量对集合操作的支持，如Swift、Java 8、JavaScript、dart等。<br>通过这些高度抽象的操作，可以写出非常简洁、易读的代码。</p><p>下面对一些常见集合操作作一个简要介绍。</p><h2 id="过滤-filter"><a href="#过滤-filter" class="headerlink" title="过滤(filter)"></a>过滤(filter)</h2><p>过滤就是将列表中不满足指定条件的元素过滤掉，满足条件的元素以新列表的形式返回。<br>在不同的语言中，该操作的名称有所不同：JavaScript、Swift、Java 8中是<code>filter</code>，dart是<code>where</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">filter(callback(element[, index[, array]])[, thisArg]);</span><br></pre></td></tr></table></figure></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;E&gt; where(<span class="built_in">bool</span> test(E element));</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(<span class="number">_</span> isIncluded: <span class="params">(<span class="keyword">Self</span>.Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">Self</span>.<span class="type">Element</span>];</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到，各语言表现形式上虽有所不同，但本质是一样的，即为<code>filter</code>注入一个回调，用于判断其中的元素是否满足指定条件。</p><p>如下例，将年龄未满18的过滤掉：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> ages = [<span class="number">19</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">30</span>, <span class="number">11</span>, <span class="number">18</span>];</span><br><span class="line"><span class="keyword">const</span> result = ages.filter(<span class="function"><span class="params">age</span> =&gt;</span> age &gt;= <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);    <span class="comment">// 19, 30, 18</span></span><br></pre></td></tr></table></figure></p><p>通过循环语句实现就不在这列了，两者的对比应该是很明显的。</p><h2 id="映射-map"><a href="#映射-map" class="headerlink" title="映射(map)"></a>映射(map)</h2><p>map就是将集合中的每个元素进行一次转换，得到一个新的值，其类型可以相同也可以不同。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>);</span></span><br></pre></td></tr></table></figure></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;T&gt; map&lt;T&gt;(T f(E e));</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>];</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure><p>map是日常开发中使用频率最高的操作之一，如将json转换成dart对象实例：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsons.map((json) =&gt; BusinessModel.fromJson(json)).toList();</span><br></pre></td></tr></table></figure></p><h2 id="折叠-化约-reduce、fold"><a href="#折叠-化约-reduce、fold" class="headerlink" title="折叠/化约(reduce、fold)"></a>折叠/化约(reduce、fold)</h2><p>折叠简单讲就是将指定操作依次作用于集合每个元素上，操作结果按操作规则依次叠加，并最终返回该叠加结果(结果类型一般是一个具体的值，而不是Iterable，因此经常出现在链式调用的末端。)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]);</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">E reduce(E combine(E value, E element))</span><br><span class="line">T fold&lt;T&gt;(T initialValue, T combine(T previousValue, E element));</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;Result&gt;<span class="params">(<span class="number">_</span> initialResult: Result, <span class="number">_</span> nextPartialResult: <span class="params">(Result, Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，dart提供了两个操作方法<code>reduce</code>、<code>fold</code>，主要区别在于后者可以提供折叠时的初始值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>,];</span><br><span class="line"><span class="comment">// reduceResult: 25</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">int</span> reduceResult = nums.reduce((value, elemnt) =&gt; value + elemnt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foldResult: 35</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">int</span> foldResult = nums.fold(<span class="number">10</span>, (value, elemnt) =&gt; value + elemnt);</span><br></pre></td></tr></table></figure><p>如上例，<code>reduce</code>是直接对列表元素求和(结果是25)，而<code>fold</code>在求和时提供了初始值10(结果是35).</p><p><img src="/img/reduce.png" alt=""><br><img src="/img/fold.png" alt=""><br>以上<code>reduce</code>、<code>fold</code>都是从左往右进行折叠，有的语言还提供了从右往左折叠的版本，如JavaScript:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure></p><blockquote><p>集合操作还有很多，在此不一一列举。当开始使用这些操作后，会惊奇地发现根本停不下来！</p></blockquote><p>集合上的操作还有一个重要特性：<strong>不可变性(immutable)</strong>，即这些操作不会改变它们正在作用的集合，而是生成新集合来提供操作结果。</p><blockquote><p>有很多的模式或框架都有类似的思想，如：flux、redux、bloc等，它们都强调(强制)任何操作都不能直接修改现有数据，而是在现有数据的基础上生成新数据，最终整体替换掉老数据。</p></blockquote><blockquote><p>在实际开发中我们也遇到过类似的问题，网络请求在子线程返回数据后直接修改了数据源，导致出现数据不同步的多线程问题。最好的解决方案是网络请求返回后在子线程组装好完整的数据，再到主线程进行一次性替换。</p></blockquote><p>不可变性很好地避免了中间状态、状态不同步等问题，也较好地规避了多线程问题。<br>同时，不变性语义使得代码可读性、维护推理性变得更好。</p><p>因为，通过<code>filter</code>、<code>map</code>、<code>reduce</code>等操作，而不是<code>for</code>、<code>while</code>循环语句操作集合，可以清楚地表达将会生成一个新集合，而不是修改现有集合的意图，代码更加简洁明了。</p><p>另外，由于集合上的这些操作的返回值类型大都是集合，因此，当有多个操作作用于集合时，就可以以链式调用的方式实现。这也进一步简化了代码。<br>看一个 flutter 的例子：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imperative flutter</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">memberIconURLs</span><br><span class="line">  .where(_isValidURL)</span><br><span class="line">  .take(<span class="number">4</span>)</span><br><span class="line">  .map(_memberWidgetBuilder)</span><br><span class="line">  .fold(stack, _addMemberWidget2Stack);</span><br></pre></td></tr></table></figure></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional flutter</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">String</span> url <span class="keyword">in</span> memberIconURLs) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_isValidURL(url)) &#123;</span><br><span class="line">    Widget memberWidget = _memberWidgetBuilder(url);</span><br><span class="line">    _addMemberWidget2Stack(stack, memberWidget);</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (count &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个代码片段分别用函数式集合操作、普通<code>for</code>循环语句实现相同的功能：将从后台获取的用户头像<code>url</code>转换成头像<code>widget</code>显示在界面上(最多显示4个，同时过滤掉无效<code>url</code>)。</p><p><img src="/img/stackusericon.jpeg" alt=""></p><p>再看个例子，进一步感受一下两者的差异：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imperative JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> excellentStudentEmails_I = <span class="function"><span class="keyword">function</span>(<span class="params">students</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> emails = [];</span><br><span class="line">  students.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">      emails.push(item.email);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> emails;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional JavaScript</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> excellentStudentEmails_F = <span class="function"><span class="params">students</span> =&gt;</span></span><br><span class="line">  students</span><br><span class="line">    .filter(<span class="function"><span class="params">_</span> =&gt;</span> _.score &gt;= <span class="number">90</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">_</span> =&gt;</span> _.email);</span><br></pre></td></tr></table></figure><p>上面这两段代码都是获取成绩&gt;=90分学生的 email。</p><p>很明显，函数式实现的代码简洁、易读、逻辑清晰、不易出错<br><code>for</code>循环版本需要很小心地维护实现上的细节问题，还引入了不必要的中间状态：<code>count</code>、<code>url</code>、<code>memberWidget</code>、<code>emails</code>等，这些都是滋生 bug 的温床！</p><p>好了，说到减少中间状态就不得不提 Pointfree。</p><h1 id="Pointfree"><a href="#Pointfree" class="headerlink" title="Pointfree"></a>Pointfree</h1><hr><p>仔细分析上节获取成绩&gt;=90分学生 email 的函数式版本，发现整个过程其实可以分为2个独立的步骤：</p><ul><li>过滤出成绩&gt;=90分的学生；</li><li>取学生的 email。</li></ul><p>将这两个步骤独立成2个小函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">excellentStudents</span>(<span class="params">students</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> students</span><br><span class="line">    .filter(<span class="function"><span class="params">_</span> =&gt;</span> _.score &gt;= <span class="number">90</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emails</span>(<span class="params">students</span>) </span>&#123;</span><br><span class="line">  students</span><br><span class="line">    .map(<span class="function"><span class="params">_</span> =&gt;</span> _.email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时<code>excellentStudentEmails</code>就可以写成下面这样了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> excellentStudentEmails_N = </span><br><span class="line">  students =&gt; emails(excellentStudents(students));</span><br></pre></td></tr></table></figure></p><p>这种嵌套调用的写法好像看不出有什么优势。<br>但有一点可以明确：一个函数的输出(<code>excellentStudents</code>)直接成为另一个函数的输入(<code>emails</code>)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> x =&gt; f(g(x));</span><br></pre></td></tr></table></figure><p>我们引入另外一个函数：<code>compose</code>，其入参为两个单参数函数(<code>f</code>、<code>g</code>)，输出还是一个单参数函数(<code>x =&gt; f(g(x))</code>)。<br>通过<code>compose</code>来改写<code>excellentStudentEmails</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> excellentStudentEmails_C = compose(emails, excellentStudents);</span><br></pre></td></tr></table></figure></p><p>相比嵌套调用版本<code>excellentStudentEmails_N</code>，组合版本<code>excellentStudentEmails_C</code>具有以下两点优势：</p><ul><li>可读性更好，从右往左而不是由内而外的阅读顺序更符合我们的思维习惯；</li><li><code>excellentStudentEmails_C</code>版本自始至终从未提及要操作的数据，减少了中间状态信息(状态越多越容易出错)。</li></ul><p>没有中间状态，没有参数，数据直接在组合的函数间流动，这也是 Pointfree 最直接的定义。<br>从本质上说，Pointfree 就是通过一系列『通用函数的组合』来完成更复杂的任务，其设计理念：</p><ul><li>鼓励写高内聚、可复用的『小』函数；</li><li>强调『组合』，而非『耦合』，复杂任务通过小任务组合完成，而不是将所有操作耦合在一个『大』函数里。</li></ul><p>组合后的函数就像是用管道连接的一样，数据在其中自由流动，无须外界干预：</p><p><img src="/img/pipe.png" alt=""></p><blockquote><p>在 UNIX shell 命令中有专门的管道命令 ‘|’，如：ls | grep Podfile，组合了 ls 与 grep 命令，用于判断当前目录下是否有 Podfile 文件。</p></blockquote><blockquote><p>注意，对于<code>excellentStudentEmails</code>来说，<code>excellentStudentEmails_F</code>版本是更好的写法，<code>excellentStudentEmails_C</code>只是用于解说 Pointfree 的概念。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>我们不奢望，也没办法做到纯函数式的编程，但函数式编程中很多优秀的设计理念都值得我们去学习和借鉴：</p><ul><li>状态不可变，避免过多的中间状态；</li><li>纯函数；</li><li>高内聚的小函数；</li><li>多用组合；</li><li>做好抽象，屏蔽细节；</li><li>…</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://legacy.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details" target="_blank" rel="noopener">JS 函数式编程指南</a><br><a href="https://book.douban.com/subject/26587213/" target="_blank" rel="noopener">函数式编程思维</a><br><a href="https://www.zhihu.com/question/28292740" target="_blank" rel="noopener">什么是函数式编程思维</a><br><a href="https://martinfowler.com/articles/collection-pipeline/" target="_blank" rel="noopener">Collection Pipeline</a><br><a href="https://github.com/getify/Functional-Light-JS" target="_blank" rel="noopener">Functional-Light JavaScript</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数式编程中有很多优秀的设计理念值得我们去学习，本文对函数式编程中的基础理念进行了简要的介绍，但更重要的是思考、总结如何将它们应用到我们日常开发中，帮助我们去提升代码的可读性、可维护性等。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://zxfcumtcs.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="函数式" scheme="http://zxfcumtcs.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS 高效开发解决方案</title>
    <link href="http://zxfcumtcs.github.io/2018/12/22/Efficient-Development-Solutions/"/>
    <id>http://zxfcumtcs.github.io/2018/12/22/Efficient-Development-Solutions/</id>
    <published>2018-12-22T09:36:54.000Z</published>
    <updated>2018-12-23T16:21:35.228Z</updated>
    
    <content type="html"><![CDATA[<p>本文作为 QQ 阅读 7.0 改版总结，从架构、页面元素模块化、UI 组件化、基于 iOS 系统响应链的事件处理、业务模板化等方面阐述了一套高效的列表类应用开发解决方案。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><hr><p>QQ 阅读迎来了7.0版本，作为惯例大版本需要大动作——『UI大改版』。<br>本文主要是对这次改版的一个总结并提炼出一套通用的『列表类业务』开发解决方案。<br>本文将从以下几个方面展开讨论：</p><ul><li>架构</li><li>页面元素模块化</li><li>UI 组件化</li><li>基于响应链的事件处理</li><li>业务模板化</li></ul><blockquote><p>本文部分内容来自<a href="https://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/">列表类应用场景模板化</a>和<a href="https://zxfcumtcs.github.io/2017/03/04/CustomUIControls/">自定义 UI 组件库</a></p></blockquote><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><hr><p>列表类业务应该说是大多数 App 的主要业务场景，如朋友圈、新闻类 App 首页、各类个性化推荐页、微博首页以及我们的书城等等。</p><p>列表类业务其流程主要是：</p><ul><li>从网络或本地磁盘获取数据；</li><li>再将数据以列表(<code>UITableView</code>、<code>UICollectionView</code>)形式展示出来；</li><li>最主要的交互就是点击进入次级页面。</li></ul><p>对于列表类业务每个项目团队可能都有一套架构，在 QQ 阅读不断迭代的过程中也演化出一套架构。<br><img src="/img/ListSceneClassDiagram.png" alt=""><br><img src="/img/ListSceneTimingDiagram.png" alt=""><br>上面分别是我们这套架构的关键类图和时序图。整体上是由经典 MVC 模式演化而来：</p><ul><li>Manager(Interface)：对应 MVC 中的 Model 『层』，主要负责数据的获取、管理等业务逻辑；</li><li>Controller：各个模块的协调枢纽，页面的承载主体；</li><li>Cell\View：对应 MVC 中的 View，仅仅负责 UI 布局、展示逻辑；</li><li>ViewModel(Interface)：View 与具体业务的中间抽象层，使两者解耦，达到 View 只负责 UI 布局的目的，最终实现 View 的高可复用性；</li><li>Module(Interface)： 称其为『业务模块』，一个页面由多个不同或相同类型的模块组成。</li></ul><h1 id="页面元素模块化"><a href="#页面元素模块化" class="headerlink" title="页面元素模块化"></a>页面元素模块化</h1><hr><p>MVC 模式饱受诟病的一点就是：Controller 经常会变得过于臃肿(Massive View Controller)。<br>为了解决这一问题，业界提出了多种解决方案，大部分都是通过添加中间层，将 Controller 的功能分解到中间层上，如 MVP (Model View Presenter) 模式。</p><p>为了解决 Controller 臃肿问题，在我们的架构中将页面元素抽象成一个个的 Module。<br><img src="/img/bookcitymodules.png" alt=""><br>如上图，红色虚线分隔的就是不同的 Module。从此，页面的生成过程就是拼接组装 Module 的过程。</p><p>在 TableView 中一个 Module 对应一个 section。<br>Module 的职责主要有：</p><ul><li>解析、存储业务数据(如今日必读 Module 需要负责解析、存储今日必读这块业务数据)；</li><li>为 TableView 提供数据(即实现<code>UITableViewDataSource</code>协议)；</li><li>处理用户事件；</li><li>埋点；</li><li>…</li></ul><p>——即负责『模块』的所有逻辑(与 React Component 类似)。</p><h2 id="Manager-与-Module"><a href="#Manager-与-Module" class="headerlink" title="Manager 与 Module"></a>Manager 与 Module</h2><p>通过上述分析可知，Module 解析、存储业务数据，Manager 存储、管理 Module。</p><p>这种做法也存在弊端，由于将解析业务数据、控制 UI 展示的逻辑(创建 cell 等)都放在了 Module 中。使得 Module 违反了『单一职责原则』。</p><blockquote><p>『单一职责原则』(SRP)作为面向对象设计的五大原则『SOLID』之一，很容易理解，也很难把握！『就好像生活中的各种”适量”，适量放点盐、适量加点水…』<br> Bob大叔在《敏捷软件开发》中，将类的单一职责原则描述为『应该仅有一个引起它变化的原因』。</p></blockquote><p>在 Module 中，业务数据解析、UI 展示就是两个可变的因素——『同样的 UI 用于展示不同的网络协议返回的数据、同一协议返回的数据展示为不用的 UI』。<br>在 QQ 阅读中，书籍列表页就属于『同样的 UI 展示不同协议返回的数据』：<br><img src="/img/BookList.jpeg" alt=""><br>针对这种情况，无非就是将其中一个变化因子抽取出来，如将业务数据解析抽取为一个单独的类。<br>由于 Module 中这两个变化因子变动的概率并不大，为了降低复杂度，只有在真正需要时才将这两者分离开。</p><blockquote><p>『敏捷开发』的原则之一就是尽量保持代码简单、并在必要时进行重构，防止代码变坏。</p></blockquote><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    QRBaseModule *module = [<span class="keyword">self</span>.manager moduleAtIndex:indexPath.section];</span><br><span class="line">    <span class="keyword">return</span> [module heightForRow:indexPath.row];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    QRBaseModule *module = [<span class="keyword">self</span>.manager moduleAtIndex:section];</span><br><span class="line">    <span class="keyword">return</span> [module numberOfRows];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    QRBaseModule *module = [<span class="keyword">self</span>.manager moduleAtIndex:indexPath.section];</span><br><span class="line">    <span class="keyword">return</span> [module cellForRow:indexPath.row tableView:tableView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.manager moduleCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码，模块化后<code>UITableViewDelegate</code>、<code>UITableViewDataSource</code>的大部分方法都转发给相应的 Module 去处理，大大简化了 Controller 的复杂度。</p><p>另外，在页面上增删任何元素都只需在 Manager 中增删相应的 Module 即可，Controller 无需任何改动——在 Controller 层面遵守了开放-封闭原则『OCP』。</p><blockquote><p>模块化不仅简化了 Controller，同时也提高了代码的复用性。Module 可以在不同页面间复用。如果这些逻辑全部放在 Controller 里，基本没有复用性可言。</p></blockquote><p>模块化有没有缺点？<br>答案是肯定的😒<br>模块化会增加类的数量、方法的数量(每个 Module 都要实现<code>UITableViewDelegate</code>、<code>UITableViewDataSource</code>的部分方法)。</p><p>当然啦，个人认为利大于弊😊</p><h1 id="UI-组件化"><a href="#UI-组件化" class="headerlink" title="UI 组件化"></a>UI 组件化</h1><hr><p>QQ 阅读7.0改版，UI 修改的工作量占大头，涉及200多个页面的修改。<br>此时，充分体现出 UI 复用的重要性。</p><p>虽然，我们很早就提出通过 View-ViewModel 的方式实现 UI 组件化，提高复用性。<br>遗憾的是，由于历史原因，在我们的工程中依然存在大量重复的实现，即『同一 UI 样式，N 份实现』。这对于 UI 大改版是灾难性了！——「不仅工作量成倍增加，还有漏改的可能性」</p><p>为了避免灾难再次上演(8.0、9.0…)，此次改版过程中，我们严格要求所有 UI 都必须以 View-ViewModel 模式做成 UI 组件。</p><h2 id="UI-组件"><a href="#UI-组件" class="headerlink" title="UI 组件"></a>UI 组件</h2><p>在继续之前，我们简单描述一下什么是 UI 组件：</p><ul><li>可复用的 UI 单元；</li><li>UI 组件可包含子 UI 组件；</li></ul><p>同时，我们将 UI 组件分为外部 UI 组件、内部 UI 组件：</p><ul><li><p>外部 UI 组件——与视觉对接，默认含有上下左右边距，为了提高其复用性，需实现<code>QRExternalUIComponent</code>协议，使得业务方可灵活控制其边距；</p><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">QRExternalUIComponent</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setEdgeInsets:(<span class="built_in">UIEdgeInsets</span>)edgeInsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p>内部 UI 组件——肯定是子 UI 组件，用于构造更大的 UI 组件，为了提高其复用性，同时控制复杂度，切边实现。</p></li></ul><p><img src="/img/fourbookUIComponent.png" alt=""><br>如上图，整体是一个四书的对外 UI 组件，含有视觉要求的上下左右边距，业务方可直接使用。<br>其中，红色虚线框住的则是一个内部组件，切边实现——没有上下左右边距，四书组件就是由4个这样的内部组件拼接而成。</p><h2 id="复用粒度"><a href="#复用粒度" class="headerlink" title="复用粒度"></a>复用粒度</h2><p><strong><em>复用没把握好火候就变成耦合了。</em></strong><br><strong>例1.</strong><br><img src="/img/banner1.jpeg" alt=""><br><img src="/img/banner2.jpeg" alt=""><br>我们书城顶部 banner 有如上图的推书样式、通栏广告图样式、还有柱状图动画样式。<br>在实现的时候，通通将这些样式塞到一个类里面，通过<code>if...else...</code>区分，这就是严重的耦合，给后面的维护造成很大的困难。<br><strong>例2.</strong><br><img src="/img/fourbook.jpeg" alt=""><br><img src="/img/threebook.jpeg" alt=""><br>三书与四书 UI 也是通过<code>if...else...</code>区分，内部还要处理六书、八书的情况，还要兼容 iPad，内部实现异常复杂，导致大家都不敢去碰这块代码。</p><p>为此，我们制定了如下规则：</p><ul><li>UI 布局相同才复用内部实现，所谓布局相同是指 UI 组件在结构上是相同的，如左边都是一个书封，右边都是两行文字，但书封大小、文字字号不同，则认为布局相同；</li><li><p>UI 布局相同，内部细节不同的，通过 <strong><em>Template Method 模式</em></strong>实现代码复用，但对外提供的 UI 组件是独立的(简化业务层的使用)；</p><blockquote><p>Template Method: Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.<br>此例中 UI 布局就是 Template Method 中的算法结构，而布局的细节则可以通过子类去控制。</p></blockquote></li><li><p>横向展示数量可扩展、纵向固定不变，如三书、六书是同一个 UI 组件，四书、八书是同一个，因为它们可以通过传入的数量控制展示。</p></li></ul><h2 id="隔离变化"><a href="#隔离变化" class="headerlink" title="隔离变化"></a>隔离变化</h2><p>我们经常吐槽 QQ 阅读 UI 的多样性在业界能排 Top1。<br><img src="/img/singlebook.jpeg" alt=""><br>如上图单书组件，其中红框框住的部分就有15、16种变<strong><em>幻</em></strong>。<br>为此，我们将这部分抽取出来，作为单书组件的一个子组件由使用方负责构造该子组件并传给单书组件去展示。</p><p>好了，下面进入本节的正题，如何构造出复用性高的 UI 组件。</p><h2 id="以-View-ViewModel-形式构建-UI-组件"><a href="#以-View-ViewModel-形式构建-UI-组件" class="headerlink" title="以 View-ViewModel 形式构建 UI 组件"></a>以 View-ViewModel 形式构建 UI 组件</h2><p>高可复用的 UI 组件，至少要满足以下两点：</p><ul><li>UI 组件不能与具体业务数据相绑定；</li><li>UI 组件内部不能处理业务逻辑——其本职工作仅是 UI 布局。</li></ul><p>总之，UI 组件要与业务解耦。<br>此时，MVVM 模式进入我们的视线，在该模式中 ViewModel 的存在是不是很好的解决了上面的问题。<br>在 MVVM 模式中，ViewModel 向上为 View 提供展示数据（该数据已经在 ViewModel 中处理好了，View 无需任何处理，只要展示即可），向下接收来自业务层的数据，处理相关的业务展示逻辑。</p><p>可以看出，ViewModel 作为中间层很好地将业务与 UI 隔离开。<br>说到 MVVM，很多同学并不喜欢，觉得其中的 Data-Binding 很麻烦，但我们构建 UI 组件时用到的是 View-ViewModel 结构，并不要求一定是 MVVM，在 MVC 等模式下也可使用。</p><p>同时，我们采用的是面向接口的模式，View 对外依赖的是接口（protocol），而不是某个具体的 ViewModel。每个 UI 组件其结构如下：<br><img src="/img/ViewViewModel.png" alt=""><br>如上图所示，若某个 UI 组件被多个业务所复用，可以根据需求定义多个 ViewModel 以处理不同的业务逻辑，每个 ViewModel 都实现<code>ViewModelProtocol</code>协议为 View 提供数据。</p><p>如上文提到的单书 UI，我们抽取为一个组件<code>QRLeftPictureRightTextView</code>：<br><img src="/img/QRLeftPictureRightTextView.png" alt=""><img src="/img/QRLeftPictureRightTextViewModel.png" alt=""><br>该组件在信息流以及书城都有用到，为此定义了两个 ViewModel，以处理各自的业务逻辑：<br><img src="/img/QRLeftPictureRightText.jpg" alt=""></p><p>至此，UI 组件化部分的内容基本结束。<br>在 QQ 阅读7.0版本中，实现了『同一 UI 样式，只有一份实现』，个人看来是一件很有意义的事情：</p><ul><li>提高开发效率，不必重复造轮子，工程代码得到很好的规范；</li><li>减轻了设计师的工作，对于复用的组件，设计师只需在设计稿中标出组件编号即可；</li><li>降低了开发与设计师的沟通成本；</li><li>为下次大改版奠定了很好的基础。</li></ul><blockquote><p>Module 与 UI 组件在两个不同的层面实现复用。</p></blockquote><h1 id="基于响应链的事件处理"><a href="#基于响应链的事件处理" class="headerlink" title="基于响应链的事件处理"></a>基于响应链的事件处理</h1><hr><p>现有的事件处理方案有两大痛点，于是提出了基于响应链『Chain of Responsibility』的事件处理方案。</p><ul><li><p>痛点1<br><img src="/img/ViewHierarchy.png" alt=""><br>大多数场景下 View 的层级结构如上图所示。我们知道，View 一般不处理用户事件，需要逐级向上传递给 Controller，因此需要沿着上图的层级结构逐级传递处理事件的 delegate。这种单调、重复、琐碎的代码非常令人不悦：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell.delegate <span class="built_in">=</span> controller;</span><br><span class="line">view.delegate <span class="built_in">=</span> cell;</span><br><span class="line">…</span><br></pre></td></tr></table></figure></li><li><p>痛点2<br>随着版本的迭代，不同类型的 cell/view 极有可能出现不同的事件处理接口，如下图所示：<br><img src="/img/celldelegate.jpeg" alt=""><br>这严重违反了面向对象设计的开闭原则『OCP』——每增加一种 cell 类型此处都需要修改。</p></li></ul><p>尤其是第一点一直困扰着我。直到前不久在《Design Patterns》一书中看到在介绍『Chain of Responsibility』模式时的一句话：『Using existing links works well when the links support the chain you need. It saves you from defining links explicitly, and it saves space』。<br><code>UIResponder</code> 中的 <code>nextResponder</code>不正是这个『existing links』吗！<br>最上层 View 的事件通过<code>nextResponder</code>链就可以顺利传到 ViewController 中，从而也就省去了 delegate 的逐级传递了，痛点1、2随之化解。<br>为此，我们为 <code>UIResponder</code>添加了传递、处理事件的分类：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZSCEvent</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) __kindof <span class="built_in">UIResponder</span> *sender;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *indexPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *userInfo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIResponder</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIResponder</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.nextResponder respondEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>UIResponder</code>的实现只是简单地将事件传递给<code>nextResponder</code>。<br>由于 View 不包含业务数据，所以事件传递的过程中需要不断添加一些信息。</p><blockquote><p>因此，我们将<code>ZSCEvent#userInfo</code>定义为 mutable。正常情况下外露接口一般都是 immutable。</p></blockquote><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableViewCell</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.nextResponder respondEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>如，在<code>UITableViewCell</code>的<code>respondEvent:</code>中需要将<code>sender</code>设置为<code>self</code>，以便在<code>UIViewController</code>中可以通过<code>cell</code>找到对应的 Module。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([event.sender isKindOfClass:<span class="built_in">UITableViewCell</span>.class], <span class="string">@"event sender must be UITableViewCell"</span>);</span><br><span class="line">    <span class="keyword">if</span> (![event.sender isKindOfClass:<span class="built_in">UITableViewCell</span>.class]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = [_tableView indexPathForCell:event.sender];</span><br><span class="line">    <span class="keyword">id</span>&lt;ZSModule&gt; module = [<span class="keyword">self</span>.manager moduleAtIndex:indexPath.section];</span><br><span class="line">    </span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    event.indexPath = indexPath;</span><br><span class="line">    [event.userInfo setObject:_tableView</span><br><span class="line">                       forKey:ZSCEventUserInfoKeys.tableView];</span><br><span class="line">    </span><br><span class="line">    [module handleEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 View 中的事件处理代码可以这样：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_clickedButton:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    ZSCEvent *event = [[ZSCEvent alloc] init];</span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    [event.userInfo setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"clickedButton"</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> respondEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果一个 cell 中有多个事件需要处理，就需要在<code>userInfo</code>中加以区分，如上面代码第<code>5</code>行。</p></blockquote><p>总之，通过<code>UIResponder</code>的<code>nextResponder</code>响应链，不必再在 view 的层级间传递 delegate，减少了琐碎的代码，提高了开发效率。同时也统一规范了事件处理方案。</p><h1 id="业务模板化"><a href="#业务模板化" class="headerlink" title="业务模板化"></a>业务模板化</h1><hr><p><a href="https://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/">列表类应用场景模板化</a>一文对此有详细的描述，在此就不赘述了。<br>其效果还是不错的。<br>很多二级页，由于 Module 是完全复用的，通过模板化脚本<strong><em>半小时</em></strong>就能做好一个二级页✌️。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>简单、高效一直是软件开发、工程管理追求的目标，本文从实际项目经验出发，从架构、解耦、复用等角度总结出一套开发解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文作为 QQ 阅读 7.0 改版总结，从架构、页面元素模块化、UI 组件化、基于 iOS 系统响应链的事件处理、业务模板化等方面阐述了一套高效的列表类应用开发解决方案。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="UI 组件" scheme="http://zxfcumtcs.github.io/tags/UI-%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计原则『SOLID』在开发中的应用</title>
    <link href="http://zxfcumtcs.github.io/2018/10/04/solid/"/>
    <id>http://zxfcumtcs.github.io/2018/10/04/solid/</id>
    <published>2018-10-04T10:07:41.000Z</published>
    <updated>2018-12-31T07:17:39.281Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细分析了面向对象设计五大原则 S(单一职责原则『SRP』)、O(开放-封闭原则 『OCP』)、L(Liskov 替换原则『LSP』)、I(接口隔离原则『ISP』)、D(依赖倒置原则『DIP』)，并假以实例辅之。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>软件设计五大原则『SOLID』以及23种经典设计模式自成型以来已有些年头，目前在实际开发中对待它们有两种较为极端的态度：敬而远之、嗤之以鼻。<br>显然，笔者用了『极端』二字表明并不赞同这样的观点。<br>SOLID 以及经典设计模式是前人在长期的软件开发中总结出来的宝贵实践经验，值得我们学习和借鉴。当然，这并不意味着我们要时刻把它们挂在嘴边，以彰显我们的『内力』，也并不意味着就要把它们作为『最高律令』、『不可逾越的红线』早早地就套用在软件开发的过程中(这无疑将增加开发的复杂性)。<br><strong><em>应将其作为解决问题的方案。</em></strong><br>此时，有必要再谈谈『敏捷开发』：<br>在移动互联网时代大家都是以『小步快跑、快速迭代、快速试错』的节奏与时间赛跑、抢占流量。『敏捷开发』因而被时常提及，遗憾的是其大多数时候也仅是停留在嘴边。<br>在移动互联网时代，笔者认为敏捷开发的核心有两点：</p><ul><li>不做过度设计，始终尽力保持代码简洁、易理解、好维护(不用一开始就套用各种原则、设计模式，徒增复杂)；</li><li>拥抱变化，无论是因需求还是其他原因引起变化导致现有代码结构不能满足需要时，要积极地对代码进行重构，始终保持良好的代码结构，对代码的腐朽保持零容忍(出现问题后可借鉴 SOLID、设计模式等去解决问题)。</li></ul><p>从上述两点可以看出：<strong>敏捷开发是一个持续的过程，而非一个心血来潮的事件。</strong></p><blockquote><p>ps：重构不一定是翻天覆地的大改，重命名变量、分解复杂方法等等都是重构。</p></blockquote><p>本文将以 SOLID 五大设计原则为主线，辅以设计模式为解决方案，谈谈 QQ 阅读、iOS 系统 API 在代码设计上的得失(失主要是对 QQ 阅读个别代码的反思)。</p><h1 id="单一职责原则『SRP』"><a href="#单一职责原则『SRP』" class="headerlink" title="单一职责原则『SRP』"></a>单一职责原则『SRP』</h1><hr><p>SRP 非常好理解，与『内聚性』表达的是同样的关注点。<br>SRP 在 SOLID 五大原则中可以说是最简单、最基础的原则。然而在实际开发中，对 SRP 的把握又是最难的。单一职责，到底什么是职责？单一的粒度如何？总之不好把握，就像生活中的各种适量『煮饭时适量加点水、做菜时适量放点盐』(经常让人抓狂 v_v)。<br>Bob 大叔在《敏捷软件开发》一书中将职责定义为：<strong><em>变化的原因</em></strong>，单一职责即为：<strong><em>仅有一个引起实体(模块、类、方法等)变化的原因</em></strong>。在把握单一职责时，这不失为一个很好的抓手，通过观察、思考设计的实体是否有一个以上的变化原因来判断其职责是否单一。</p><blockquote><p>后文为叙述方便，如无特别说明，实体指模块、类、方法等功能代码块。</p></blockquote><p>笔者认为 SRP 作为最基础的设计原则，主要有两点收益：</p><ul><li>降低实体的复杂度，提升可维护性；</li><li>提高实体的可复用性，当一个实体中耦合了多个职责时，其可复用性必然受到影响。即使多处复用了，其中一个职责的变化对复用其他职责的实体也会造成意想不到的影响，这不是我们想看到的。这也是 Bob 大叔将职责定义为『变化』的原因。</li></ul><h2 id="例1-UIView-与-CALayer"><a href="#例1-UIView-与-CALayer" class="headerlink" title="例1 UIView 与 CALayer"></a>例1 UIView 与 CALayer</h2><p>在 UIView 的层级结构中，我们知道每个 View 背后都有一个 CALayer 与之对应。<br>其中，UIView 的主要职责是处理用户交互，CALayer 则是布局、渲染以及动画等。<br>Apple 之所以要设计 UIView 与 CALayer 两套体系，就是为了使它们的职责更加单一，能更好的复用。<br>在 iOS 与 Mac OS 上，用户交互处理方式有本质的区别，然而在布局、渲染、动画等方面又是一致的。因此，通过将上述职责分离，CALayer 可以很好地在 iOS 与 Mac OS 间复用，而用户交互的处理则各自独立，于是有了 UIKit、AppKit。</p><h2 id="例2-View-与-ViewModel"><a href="#例2-View-与-ViewModel" class="headerlink" title="例2 View 与 ViewModel"></a>例2 View 与 ViewModel</h2><p>例1中的 View 与 Layer 属于系统实现层面，在应用层面 UIView 的职责是明确的、单一的：<strong>UI 布局</strong>。然而在实际开发中有大量展示相关的业务逻辑写到了 View 里面，严重影响了 View 的可复用性。究其原因，在非 MVVM 模式下，展示逻辑只能放在 Controller 中，势必造成 Controller 过于臃肿。于是，在 QQ 阅读中我们提出以 View-ViewModel 模式构建 UI 组件，将展示逻辑放到 ViewModel 中，View 仅处理布局逻辑。目前看效果良好，View 的逻辑更加清晰、可复用性得到很大提高。详细信息请参看<a href="https://zxfcumtcs.github.io/2017/03/04/CustomUIControls/">『自定义 UI 组件库』</a>一文。</p><h1 id="开放-封闭原则-『OCP』"><a href="#开放-封闭原则-『OCP』" class="headerlink" title="开放-封闭原则 『OCP』"></a>开放-封闭原则 『OCP』</h1><hr><p>『唯有变化才是永恒』，对于软件开发来说更是如此，一个模块、类、方法等实体几乎不可能在第一个版本开发出来后就一直保持不变。因此，变化是开发人员必须要面对的问题(可谓爱之恨之)。<br>OCP 就是用于指导我们如何应对变化。<br>OCP 的含义是：『对扩展开放，对修改封闭』。<br>具体说，实体的功能可以不断扩展(变化)，但实体的源码不允许修改。<br>看似十分矛盾！就像『东西可以随便买，但钱不允许花』。<br>仔细分析，OCP 的重点是<strong>扩展新功能</strong>，也就是扩展新功能时可以添加新代码，但不能修改已有代码。因为对已有代码的修改带来的影响是难于预料的，如果修改导致链锁反应，后果更是灾难性的。<br>如何做到？<br><strong>关键在抽象</strong>。<br>『面向接口编程，而非实现编程』这是我们经常挂在嘴边的话。<br>面向接口编程，也就是说依赖的是抽象接口，为的就是可以灵活的替换接口背后的实现。这不正是 OCP 需要的吗！</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>在23种经典设计模式中『Template Method 模式』以及『Strategy 模式』都可以很好地实现 OCP，其中 Template Method 模式的实现依赖于继承，Strategy 模式使用的委托(接口)。</p><h3 id="Template-Method-模式"><a href="#Template-Method-模式" class="headerlink" title="Template Method 模式"></a>Template Method 模式</h3><p><img src="/img/TemplateMethod.png" alt=""><br>Template Method 模式类图如上图所示(来自 GoF 的《Design patterns》)。<br>Template Method 模式在抽象基类中定义 <code>TemplateMethod</code>方法，但该方法并不做实际工作，只是调用其它方法(<code>PrimitiveOperation...</code>，C++中须是虚函数)来完成具体的工作。<br>可见，<code>TemplateMethod</code>方法只是定义了一个任务或算法的骨架、执行步骤。<br>因此，可以通过派生新的子类，并实现<code>PrimitiveOperation...</code>方法来扩展功能。</p><h3 id="Strategy-模式"><a href="#Strategy-模式" class="headerlink" title="Strategy 模式"></a>Strategy 模式</h3><p><img src="/img/Strategy.png" alt=""><br>Strategy 模式类图如上图所示(来自 GoF 的《Design patterns》)。<br>Strategy 模式是典型的面向接口编程，通过接口使得业务层(使用方)与实现细节完全解耦，从而可以很方便地通过扩展实现来扩展新功能，而无须对业务层进行修改。<br>纵观 Template Method 与 Strategy 模式，前者通过继承并重写方法(C++中的虚函数)来扩展新功能，后者通过新增实现了特定接口的类开添加新功能。<br>两者无谓优劣，不同的场景使用不同的方案。但是，继承会增加复杂度，这是共识，在使用 Template Method 模式时需要考虑到这点。</p><h2 id="例1-QQ-阅读登录模块"><a href="#例1-QQ-阅读登录模块" class="headerlink" title="例1 QQ 阅读登录模块"></a>例1 QQ 阅读登录模块</h2><p>QQ 阅读起初只有 QQ 一种登录方式，突然有一天 Apple 爸爸说不得强制用户必须登录才能使用 App。无奈之下，我们添加了游客登录模式。<br><img src="/img/OldLoginClassDiagram.png" alt=""><br>上图就是增加游客登录后的结构简图。QQ 登录、游客登录看似相安无事。<br>但，<strong>众多业务模块</strong>直接与两种登录方式交互，严重破坏了 OCP。<br>后果如何？<br>后果是严重的！后面如果要增加其他登录方式，所有与登录态有关的模块全都要改一遍！</p><blockquote><p>问题出在哪里？笔者认为最初业务层直接与 QQ 登录交互并无大碍，关键是在添加游客登录时需要察觉到其中的问题，并立即做出重构，而不是在现有代码基础上糊乱堆叠代码。</p></blockquote><p>果不其然，没多久产品要求添加微信登录。于是趁机对登录做了一次彻底的重构。<br><img src="/img/NewLoginClassDiagram.png" alt=""><br>重构过程中，我们添加了『鉴权中心』模块<code>QRAuthenticatonCenter</code>统一处理登录相关的问题，同时使用了 Strategy 模式将各种登录方式的实现细节与<code>QRAuthenticatonCenter</code>以及业务层隔离开来。<br>不久之后，我们又添加了起点登录、QQ 登录也由原来腾讯内部的 Wlogin 登录方式切换到统一互联登录。<br>针对这两个变动，业务层无任何修改，<code>QRAuthenticatonCenter</code>也只是添加了初始化<code>QRYWAuthenticator</code>、<code>QROpenQQAuthenticator</code>的代码。变动的主要工作就是按照<code>QRAuthenticatorDelegate</code>接口分别去实现<code>QRYWAuthenticator</code>以及<code>QROpenQQAuthenticator</code>。</p><blockquote><p>通过 Abstract Factory 模式，可以使得在添加新登录方式时<code>QRAuthenticatonCenter</code>也无需修改，但笔者认为在该场景下其带来的收益不足以弥补其复杂性，即弊大于利，故弃之。</p></blockquote><p>上述可见，通过 Strategy 模式重构后的登录模块实现了 OCP，也在后续迭代变更过程中充分享受了其带来的收益。</p><h2 id="例2-QQ-阅读引擎模块"><a href="#例2-QQ-阅读引擎模块" class="headerlink" title="例2 QQ 阅读引擎模块"></a>例2 QQ 阅读引擎模块</h2><p>QQ 阅读的 txt 引擎是整个工程里面最核心，也是最古老的一个模块。<br>起初，引擎里面有两种类型的段落：文字、空段落，并通过一个<code>int</code>型变量<code>type</code>加以表示。<br>随着迭代，越来越多非内容本身的交互性元素加入阅读页，如：作者的话、大神说等等。目前<code>type</code>的值已扩展到十五、六类之多，每添加一种新类型都要在最核心的引擎里面修改一、二十处，可谓如覆薄冰。<br>这就是一个严重违反 OCP，并产生严重后果的例子。<br>找到了问题所在，重构方案也就变得明了：通过 Strategy 模式，将每种类型段落的逻辑抽取成一个类，并遵守相同的接口，txt 引擎依赖抽象接口，使之遵守 OCP。</p><h1 id="Liskov-替换原则『LSP』"><a href="#Liskov-替换原则『LSP』" class="headerlink" title="Liskov 替换原则『LSP』"></a>Liskov 替换原则『LSP』</h1><hr><p>LSP：子类型必须能够替换其基类型。<br>直白点，就是任何使用基类类型的地方(如调用方法时的入参)都能替换成其子类类型，而不会出现意想不到的错误。<br>看完 LSP 的定义，不禁要问：其有何用？<br>为了回答这个问题，不防从反面思考一下：若不遵守 LSP 如何？<br>以方法参数为例：若方法 <code>M</code> 有一个类型为类 <code>B</code> 的参数，如果类 <code>B</code> 的子类没有遵守 LSP，在调用方法 <code>M</code> 时传入了一个类 <code>B</code> 的子类，<code>M</code> 会出错。此时，为了不出错，方法 <code>M</code> 势必要对 <code>B</code> 的子类作特殊处理(<code>if...else...</code>)。<br>熟悉的味道！这是不是违反了 OCP！</p><blockquote><p>引自《敏捷软件开发》：对于 LSP 的违反往往会导致以明显违反 OCP 的方式使用运行时类型识别『RTTI』。</p></blockquote><h2 id="例1-正方形与长方形"><a href="#例1-正方形与长方形" class="headerlink" title="例1 正方形与长方形"></a>例1 正方形与长方形</h2><p>Bob 大叔在《敏捷软件开发》中有一个关于正方形和长方形的例子。<br>『正方形是一种特殊的长方形』，这可谓是常识。因此，让正方形类<code>Square</code>继承自长方形类<code>Rectangle</code>再合理不过。<br>然而在对待长度、宽度上，正方形与长方形似乎不那么一致：<br>正方形的长、宽必须相等，因此<code>Square</code>类必须重写其基类<code>Rectangle</code>的<code>setWidth</code>、<code>setHeight</code>方法来保证每次调用这两个方法后正方形的长宽依然相等。这看上去似乎也并无不妥，然而在下面这个方法中就有问题了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Rectangle &amp;r)</span> </span>&#123;</span><br><span class="line">    r.setWidth(<span class="number">5</span>);</span><br><span class="line">    r.setHeight(<span class="number">4</span>);</span><br><span class="line">    assert(r.area() == <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数<code>g</code>对于长方形的认知完全正确，然而若调用函数<code>g</code>时传入的是个<code>Square</code>类型的引用，就出错了！<br>很明显，<code>Square</code>与<code>Rectangle</code>间的继承关系违反了 LSP。</p><blockquote><p>引自《敏捷软件开发》：LSP 让我们得出一个非常重要的结论：一个模型，如果孤立地看，并不具有真正意义上的有效性。<strong>模型的有效性只能通过它的客户程序来表现。</strong>在考虑一个特定设计是否恰当时，不能完全孤立地来看这个解决方案。必须要根据该设计的使用者所做出的合理假设来审视它。<br><strong><em>因此，是否违反 LSP，在很大程度上取决于客户程序。</em></strong></p></blockquote><p><code>Square</code>与<code>Rectangle</code>间的继承之所以会违反 LSP，是因为在设置长、宽的行为上它们间不具备”IS-A”关系。</p><blockquote><p>引自《敏捷软件开发》：从行为方式的角度来看，<code>Square</code>不是<code>Rectangle</code>，对象的行为方式才是软件真正所关注的问题。LSP 清楚地指出，OOD 中 IS-A 关系是就行为方式而言的，行为方式是可以进行合理假设的，是客户程序所依赖的。</p></blockquote><h2 id="LSP-与多态"><a href="#LSP-与多态" class="headerlink" title="LSP 与多态"></a>LSP 与多态</h2><p>讨论 LSP 的前提就是多态，否则无从谈起。<br>然而，多态本质上就是子类的方法覆盖基类的虚函数。这与 LSP 要求的子类可以替换基类是否矛盾？因为通过基类指针最终调用的是子类的方法。<br>答案自是不矛盾，相反 LSP 能够更好地指导我们如何使用继承。<br>为了满足 LSP，子类只能对基类的功能进行扩展，而不能『篡改』。<br>这不正是『继承』的本质内涵吗！</p><p>因此，LSP至少有三点作用：</p><ul><li>实现 OCP 的重要保障之一；</li><li>降低继承带来的复杂度，继承只能扩展基类的功能，而非『篡改』(可以无差别的对待基类及其所有子类)；</li><li>在决定使用继承前，可以更好地判别两者是否真具有”IS-A”的关系。</li></ul><h2 id="启发式判断规则与改进方案"><a href="#启发式判断规则与改进方案" class="headerlink" title="启发式判断规则与改进方案"></a>启发式判断规则与改进方案</h2><p>LSP 有时是很微妙的，在开发过程中往往难于察觉。<br>Bob 大叔提出两个启发式规则供大家参考：</p><ul><li><p>派生类存在退化函数，如下述代码基类<code>Base</code>中的方法<code>f</code>是有功能的，但到其子类<code>Derived</code>中<code>f</code>退化为空方法，这往往预示违反了 LSP，值得警惕：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/*some code*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> calss Derived : Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从派生类中抛出异常，即从派生类的方法中抛出了基类不会抛出的异常，这往往是调用方不曾预料的。</p></li></ul><p>违反 LSP 说明继承已经不适合了，此时可以将这对『父子』中公共的代码提取出来。<br>之后要么让他们成为『兄弟』，都从提取的代码派生、要么以组合的方式集成提取的代码。</p><h1 id="接口隔离原则『ISP』"><a href="#接口隔离原则『ISP』" class="headerlink" title="接口隔离原则『ISP』"></a>接口隔离原则『ISP』</h1><hr><p> ISP：不应迫使客户程序依赖于它们不需要的接口。即，客户程序依赖的类中不应该含有其不需要的方法，从而降低系统的复杂度，减少类之间的耦合。<br>相反，若某客户程序依赖的类含有大量其不需要的方法，而这些方法又是其他客户程序所需的，当这些方法因需求需要变化时或需要添加新方法时，势必会殃及不需要这些方法的客户程序，从而增加系统的耦合度。<br>怎么解决？<br>当然是『隔离、拆分』接口了！<br>在支持接口/协议的语言(如Objective-C)中，很好处理，将类的公共方法分解到多个接口中；<br>而在像 C++ 这样不支持接口的语言中，可通过多继承、委托等方式分解接口。</p><h2 id="例1-UITableView-之-DataSource、Delegate"><a href="#例1-UITableView-之-DataSource、Delegate" class="headerlink" title="例1 UITableView 之 DataSource、Delegate"></a>例1 UITableView 之 DataSource、Delegate</h2><p>iOS 开发对 UITableView 恐是再熟悉不过了，其提供了两套接口：<code>UITableViewDataSource</code>、<code>UITableViewDelegate</code>。<br>从场景上说，这两套接口都是为 UITableView 提供服务的。<br>之所以要把它们分开，就是为了可以将为 UITableView 提供数据、处理用户交互的职责拆分到不同的类中。</p><h2 id="例2-QQ-阅读登录接口"><a href="#例2-QQ-阅读登录接口" class="headerlink" title="例2 QQ 阅读登录接口"></a>例2 QQ 阅读登录接口</h2><p>在『OCP』一节，简要介绍了 QQ 阅读的登录模块，我们知道具体的登录细节由<code>QRQQAuthenticator</code>、<code>QRWechatAuthenticator</code>以及<code>QRGuestAuthenticator</code>等处理。这些<code>Authenticator</code>都实现了<code>QRAuthenticatorDelegate</code>接口：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">QRAuthenticatorDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主动登录</span></span><br><span class="line">- (<span class="keyword">void</span>)authenticateWithCompletion:(QRAuthenticateCompletion)completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 续期</span></span><br><span class="line">- (<span class="keyword">void</span>)refreshTokenWithCompletion:(QRAuthenticateCompletion)completion;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>然而，对于 QQ 登录，在没有安装 QQ 时，需要<code>QRQQAuthenticator</code>作特殊处理。<br>由于这样的特殊处理只是 QQ 登录需要，因此把对应的接口放到<code>QRAuthenticatorDelegate</code>中是不合适的。<br>最终，我们将其定义为独立的接口<code>QRQQManuallyAuthenticationDelegate</code>：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">QRQQManuallyAuthenticationDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)manuallyAuthenticateWithAccount:(Account *)account;</span><br><span class="line">- (<span class="keyword">void</span>)checkVerifyCode:(<span class="built_in">NSString</span> *)verifyCode account:(Account *)account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>并让<code>QRQQAuthenticator</code>实现这两个接口：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QRQQAuthenticator</span> : <span class="title">NSObject</span>&lt;<span class="title">QRAuthenticatorDelegate</span>, <span class="title">QRQQManuallyAuthenticationDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>而<code>QRWechatAuthenticator</code>、<code>QRGuestAuthenticator</code>等只需实现<code>QRAuthenticatorDelegate</code>即可。</p><blockquote><p>对于 ISP 大家可能会有疑问：根据 SRP，类的职责应该是单一的，为何需要实现多个接口？<br>在现实中，确实存在从接口层面内聚性较低的类。如，例2中的<code>QRQQAuthenticator</code>类，正常的登录、续期需要处理，手动登录同样需要处理，在接口上就不具备高内聚的特征。<br>ISP 就是用于在此情况下指导如何拆分接口。</p></blockquote><h1 id="依赖倒置原则『DIP』"><a href="#依赖倒置原则『DIP』" class="headerlink" title="依赖倒置原则『DIP』"></a>依赖倒置原则『DIP』</h1><hr><p>在开发中，较大的模块一般会由几位同学协同开发，分工一般会按分层的方式进行。<br>此时，经常会听到负责低层模块的同学向负责高层模块的同学说：『我给你提供了这这几个方法，代码已提交，你看一下。』<br>从 DIP 的角度看，犯了两个错误！<br>其一，在制定双方接口上低层模块起了主导作用；其二，两者间缺少抽象。<br>DIP：</p><ul><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；</li><li>抽象不应该依赖于细节，细节应该依赖于抽象。</li></ul><p>依赖倒置原则其中的『倒置』强调的就是高层模块与低层模块间的关系：<strong>高层模块作为需求方提出需求(提出接口)，低层模块去实现高层模块提出的需求(接口)。</strong><br>为何？</p><ul><li>高层模块不应知道低层模块的细节；</li><li>若是由低层模块制定接口，很可能不由自主地将实现细节曝露在接口中，这是我们不希望看到的。</li></ul><h2 id="例1-分页加载"><a href="#例1-分页加载" class="headerlink" title="例1 分页加载"></a>例1 分页加载</h2><p>在<a href="https://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/">列表类应用场景模板化</a>一文中，我们提到『大多数 App 的大多数应用场景都是列表类的』，分页加载是列表类应用场景的标配。<br>那么在制定接口时，若由低层模块(Model)负责，很可能会将分页的细节曝露在接口中：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestMoreDataWithPageStamp:(<span class="built_in">NSInteger</span>)pageStamp completion:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *, <span class="keyword">id</span>))completion;</span><br></pre></td></tr></table></figure></p><p>很明显，<code>pageStamp</code>是 Model 与服务端交互的细节，是高层模块不关心，也不应关心的问题。<br>若是由高层模块(Controller)提出需求(接口），接口可能会是这样：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestMoreDataWithCompletion:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *, <span class="keyword">id</span>))completion;</span><br></pre></td></tr></table></figure></p><p>当然，这个例子较简单，稍有经验的开发人员也不会在接口中曝露pageStamp信息。<br>但，由低层模块制定接口会曝露细节的问题值得关注。</p><h2 id="例2-通过抽象解耦高、低层模块"><a href="#例2-通过抽象解耦高、低层模块" class="headerlink" title="例2 通过抽象解耦高、低层模块"></a>例2 通过抽象解耦高、低层模块</h2><p>同时，DIP 提出高层模块与低层模块不能直接有依赖关系，它们都应依赖于抽象(接口)。<br>如此可使得高层模块与低层模块解耦，促使高层模块具有更好的可复用性。<br><img src="/img/ListSceneClassDiagram.png" alt=""><br>上图是在<a href="https://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/">『列表类应用场景模板化』</a>一文中介绍的列表类模块的类图。<br>其中，Controller 与 Manager 、Controller 与 Module 间都是面向接口编程(依赖于抽象)。<br>在 QQ 阅读中，书籍分为 txt 和精排两种格式，它们都支持批量下载。在展示、用户交互上两者并无太大区别，但背后的业务逻辑却大不相同。<br>因此，批量下载的 Controller 可以复用，但 Manager 不可。<br>通过 DIP 可以很方便的隔离 Controller 与 Manager，使批量下载的 Controller 在两种格式间复用。</p><p>DIP 可以说是 SOLID 中实现成本最小的原则，但其带来的收益却十分可观，因此，DIP 应该是我们自始至终都应遵守的原则。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>综观 S、O、L、I、D 五大原则，本质上它们都是帮助我们降低软件系统的复杂度。只不过，各自关注的维度不同：</p><ul><li>SRP：要求软件实体(模块、类、方法)只有单一的职责，降低实体的复杂度，提高实体的内聚性；</li><li>OCP：要求软件实体对扩展开放、对修改封闭，使得软件系统在扩展功能时，减少对系统已有部分的影响；</li><li>LSP：对继承关系提出要求，子类须可替换基类，降低继承带来的复杂度以及减少误用继承的可能；</li><li>ISP：将复杂接口拆分开来，避免强迫高层模块依赖于其不需要的接口，减少不必要的耦合；</li><li>DIP：避免由低层模块制定接口时无意曝露低层细节，通过抽象解耦高层与低层模块。</li></ul><p>对于 SOLID 以及其他的各种设计原则、模式，无须天天挂在嘴边，而是在遇到问题时，能通过它们解决问题。</p><p>参考资料：<br><a href="https://book.douban.com/subject/1140457/" target="_blank" rel="noopener">《敏捷软件开发——原则、模式与实践》</a><br><a href="https://book.douban.com/subject/1436745/" target="_blank" rel="noopener">《Design Patterns: Elements of Reusable Object-Oriented Software》</a><br><a href="https://book.douban.com/subject/1229923/" target="_blank" rel="noopener">《重构——改善既有代码的设计》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细分析了面向对象设计五大原则 S(单一职责原则『SRP』)、O(开放-封闭原则 『OCP』)、L(Liskov 替换原则『LSP』)、I(接口隔离原则『ISP』)、D(依赖倒置原则『DIP』)，并假以实例辅之。&lt;br&gt;
    
    </summary>
    
    
      <category term="OOD" scheme="http://zxfcumtcs.github.io/tags/OOD/"/>
    
      <category term="设计模式" scheme="http://zxfcumtcs.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="敏捷开发" scheme="http://zxfcumtcs.github.io/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
      <category term="SOLID" scheme="http://zxfcumtcs.github.io/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>列表类应用场景模板化</title>
    <link href="http://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/"/>
    <id>http://zxfcumtcs.github.io/2018/09/17/ListSceneTemplating/</id>
    <published>2018-09-17T15:05:02.000Z</published>
    <updated>2018-12-15T10:16:34.640Z</updated>
    
    <content type="html"><![CDATA[<p>由于列表类应用场景具有固定的流程和模式，本文首先简要介绍了 QQ 阅读中列表类应用场景的架构，然后提出对这一场景进行模板化，以便提高开发效率、减少沟通理解成本。<br>同时，提出一套基于 『Chain of Responsibility』 的事件处理方案，也在一定程度上提高了开发效率，减少了琐碎代码量。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>2009年作为移动互联网开发元年至今已过去十年，移动客户端开发技术也已从拓荒时代进化到成熟稳定阶段。十年间，数以万计的 App 被创造出来。然而，细观市面上的 App 会发现大多数及至绝大多数 App 的大多数及至绝大多数应用场景都是列表类的。<br>所谓列表类应用场景主要有以下几个特征：</p><ul><li>以 UITableView 展示多条数据；</li><li>数据不变，仅用于展示，或只有很少的状态变化；</li><li>没有复杂的用户交互(如：UGC)。</li></ul><p>从上述特征可知，所有列表类应用场景都具有『相同的代码结构』，也就意味着我们经常在做一些重复性的工作。<br>同时，『相同的代码结构』也意味着可以将其模板化。通过模板化列表类应用场景至少有以下两点收益：</p><ul><li>提高工作效率，减少重复性劳动；</li><li>统一代码结构，减少项目组内理解沟通成本。</li></ul><h1 id="QQ-阅读列表类应用场景架构简述"><a href="#QQ-阅读列表类应用场景架构简述" class="headerlink" title="QQ 阅读列表类应用场景架构简述"></a>QQ 阅读列表类应用场景架构简述</h1><hr><p>列表类应用场景其流程无外乎：从网络或本地磁盘获取数据，再将数据以列表(tableview)的形式展示出来，其中最主要的交互就是点击进入次级页面。<br>每个项目团队可能都有一套用于列表类场景的架构，在 QQ 阅读不断迭代的过程中我们也演化出了一套相关的架构。本文会以这套架构为例讲述模板化的思路。</p><blockquote><p>使用什么样的架构不是重点，重点是将使用的架构模板化的思路。</p></blockquote><p><img src="/img/ListSceneClassDiagram.png" alt=""><br><img src="/img/ListSceneTimingDiagram.png" alt=""><br>上图分别是我们这套架构的关键类图和时序图。整体上是由经典 MVC 模式演化而来：</p><ul><li>Manager(Interface)：对应 MVC 中的 Model 『层』，主要负责数据的获取、管理等；</li><li>Controller：各个模块的协调枢纽；</li><li>Cell/View：对应 MVC 中的 View，仅仅负责 UI 布局逻辑；</li><li>ViewModel：处理 UI 展示相关的业务逻辑(详细信息请参看之前的文章<a href="https://zxfcumtcs.github.io/2017/03/04/CustomUIControls/">『自定义 UI 组件库』</a>)；</li><li>Module(Interface)： 将其称之为『业务模块』，一个页面由多个不同或相同类型的模块组成。如 QQ 阅读精选页的『今日必读』、『今日秒杀』等都是模块。</li></ul><p><img src="/img/RecommendedToday.jpeg" alt=""><br><img src="/img/TodaySecondKill.jpeg" alt=""><br>当然 Module 也可以是一个简单的样式：<br><img src="/img/SimpleStyle.jpeg" alt=""><br>在 TableView 中一个 Module 对应一个 section。Module 的职责主要有：网络数据的解析、 为 TableView datasource 提供数据(如：创建 cell 等)、处理用户事件——即负责『模块』的所有业务逻辑(与 React Component 类似)。</p><blockquote><p>Module 的存在主要是减轻 Controller 的负担。</p></blockquote><p>通常情况下，Manager(Model)存储的是纯粹的业务数据(从网络拉取的数据)，这样就需要在业务数据与 Module『模块』 间建立映射关系。为了省去这层映射，直接由 Module 解析、存储业务数据。<br>这种做法也存在弊端，由于将网络数据的解析、控制 UI 展示的逻辑(创建 cell 等)都放在了 Module 中。使得 Module 违反了『单一职责原则』。</p><blockquote><p>『单一职责原则』(SRP)作为面向对象设计的五大原则『SOLID』之一，很容易理解，也很难把握！『就好像生活中的各种”适量”，适量放点盐、适量加点水…』<br> Bob大叔在《敏捷软件开发》中，将类的单一职责原则描述为『应该仅有一个引起它变化的原因』。</p></blockquote><p>在 Module 中，网络数据解析、UI 展示就是两个可变的原因——『同样的 UI 用于展示不同的网络协议返回的数据、同一协议返回的数据展示为不用的 UI』。<br>在 QQ 阅读中，书籍列表页就属于『同样的 UI 展示不同协议返回的数据』：<br><img src="/img/BookList.jpeg" alt=""><br>针对这种情况，无非就是将其中一个变化因子抽取出来，可以将网络数据解析抽取为一个单独的类。<br>由于Module 中这两个变化因子变动的概率并不大，为了降低复杂度，在模板中并没有将这两者分离开。</p><blockquote><p>『敏捷开发』的原则之一就是尽量保持代码简单、并在必要时进行重构，防止代码变坏。</p></blockquote><h1 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h1><hr><p>通过上述介绍可知，Controller、Manager、API 的代码基本是固定的——可以模板化，另外 View-ViewModel 是可以高度复用的。所以模板化后新增一个列表类应用场景的主要工作集中在 Module 上。</p><blockquote><p>所谓模板化就是提供一套代码模板，在实例化时将模板中的『Template』关键字替换成业务名。</p></blockquote><p>我们这套模板中有：Manager、Module、View 以及 API 四个目录，ZSTemplateManager.m(.h)、ZSTemplateViewController.m(.h) 以及 ZSTemplateAPI.m(.h)六个文件，其中可以模板化的代码主要有：</p><ul><li>Controller：设置 tableview(含下拉、上拉、datasource、delegate)、设置导航栏、错误\空数据处理、向 manager 发送请求数据的调用、事件处理等；</li><li>Manager：管理 module、向 API 发送网络请求、缓存处理等；</li><li>API：发送网络请求。</li></ul><p>也就是模板化后上述功能可以通过转换脚本一键生成，不用重复地写这些代码。尤其是 Controller 基本可以直接使用。</p><blockquote><p>转换脚本、demo 已提交到 github 上<a href="https://github.com/zxfcumtcs/ZSTemplatedListScene" target="_blank" rel="noopener">『ZSTemplatedListScene』</a>。转换脚本的功能就是将模板中的『Template』关键字替换为业务名(包括代码和文件名中的)。如，demo 中的通信录业务：<img src="/img/transformsh.jpeg" alt="">注：demo 中的模板仅是个『demo』，其中的网络请求、缓存等功能可替换为项目中统一的模块。</p></blockquote><p>总之，通过转换脚本可以一键生成部分代码，提高了开发效率。同时，通过模板也规范了代码结构，减少了项目组沟通理解成本。</p><h1 id="基于-Chain-of-Responsibility-事件处理方案"><a href="#基于-Chain-of-Responsibility-事件处理方案" class="headerlink" title="基于 Chain of Responsibility 事件处理方案"></a>基于 Chain of Responsibility 事件处理方案</h1><hr><p>目前的事件处理有2个痛点，于是才有了基于 Chain of Responsibility 的事件处理方案。</p><ul><li><p>痛点1<br><img src="/img/ViewHierarchy.png" alt=""><br>大多数场景下 View 的层级结构如上图所示。我们知道，View 一般不处理用户事件，需要逐级传递给 Controller，因此需要沿着上图的层级结构逐级传递处理事件的 delegate。这种单调重复琐碎的代码有种令人不悦的感觉：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell.delegate <span class="built_in">=</span> controller;</span><br><span class="line">view.delegate <span class="built_in">=</span> cell;</span><br><span class="line">…</span><br></pre></td></tr></table></figure></li><li><p>痛点2<br>随着版本的迭代，不同类型的 cell/view 极有可能出现不同的事件处理接口，如下图所示：<br><img src="/img/celldelegate.jpeg" alt=""><br>这严重违反了面向对象设计的开闭原则(Open-Closed)——每增加一种 cell 类型此处都需要修改。</p></li></ul><p>尤其是第一点一直困扰着我。直到前不久在《Design Patterns》一书中看到在介绍『Chain of Responsibility』模式时的一句话：『Using existing links works well when the links support the chain you need. It saves you from defining links explicitly, and it saves space』。<br><code>UIResponder</code> 中的 <code>nextResponder</code>不正是这个『existing links』吗！<br>最上层 View 的事件通过<code>nextResponder</code>链就可以顺利传到 ViewController 中，从而也就省去了 delegate 的逐级传递了，痛点1、2随之化解。<br>为此，我们为 <code>UIResponder</code>添加了传递、处理事件的分类：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZSCEvent</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) __kindof <span class="built_in">UIResponder</span> *sender;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *indexPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *userInfo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIResponder</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIResponder</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.nextResponder respondEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>UIResponder</code>的实现只是简单地将事件传递给<code>nextResponder</code>。<br>由于 View 不包含业务数据，所以事件传递的过程中需要不断添加一些信息。</p><blockquote><p>因此，我们将<code>ZSCEvent#userInfo</code>定义为 mutable。正常情况下外露接口一般都是 immutable。</p></blockquote><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableViewCell</span> (<span class="title">ZSCEvent</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.nextResponder respondEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>如，在<code>UITableViewCell</code>的<code>respondEvent:</code>中需要将<code>sender</code>设置为<code>self</code>，以便在<code>UIViewController</code>中可以通过<code>cell</code>找到对应的 module。<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)respondEvent:(<span class="built_in">NSObject</span>&lt;ZSCEvent&gt; *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([event.sender isKindOfClass:<span class="built_in">UITableViewCell</span>.class], <span class="string">@"event sender must be UITableViewCell"</span>);</span><br><span class="line">    <span class="keyword">if</span> (![event.sender isKindOfClass:<span class="built_in">UITableViewCell</span>.class]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = [_tableView indexPathForCell:event.sender];</span><br><span class="line">    <span class="keyword">id</span>&lt;ZSModule&gt; module = [<span class="keyword">self</span>.manager moduleAtIndex:indexPath.section];</span><br><span class="line">    </span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    event.indexPath = indexPath;</span><br><span class="line">    [event.userInfo setObject:_tableView</span><br><span class="line">                       forKey:ZSCEventUserInfoKeys.tableView];</span><br><span class="line">    </span><br><span class="line">    [module handleEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 View 中的事件处理代码可以这样：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_clickedButton:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    ZSCEvent *event = [[ZSCEvent alloc] init];</span><br><span class="line">    event.sender = <span class="keyword">self</span>;</span><br><span class="line">    [event.userInfo setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"clickedButton"</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> respondEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果一个 cell 中有多个事件需要处理，就需要在<code>userInfo</code>中加以区分，如上面代第<code>5</code>行。</p></blockquote><p>总之，通过<code>UIResponder</code>的<code>nextResponder</code>响应链，不必再在 view 的层级间传递 delegate，减少了琐碎的代码，提高了开发效率。同时也统一规范了事件处理方案。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>提升开发效率、规范代码结构一直是我们追求的目标。文本通过对列表类应用场景模板化以及通过『Chain of  Responsibility』机制处理用户事件，在一定程度上提高了开发效率并规范了代码结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于列表类应用场景具有固定的流程和模式，本文首先简要介绍了 QQ 阅读中列表类应用场景的架构，然后提出对这一场景进行模板化，以便提高开发效率、减少沟通理解成本。&lt;br&gt;同时，提出一套基于 『Chain of Responsibility』 的事件处理方案，也在一定程度上提高了开发效率，减少了琐碎代码量。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://zxfcumtcs.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>简述 ReactNative Bundle</title>
    <link href="http://zxfcumtcs.github.io/2018/05/11/RNBundle/"/>
    <id>http://zxfcumtcs.github.io/2018/05/11/RNBundle/</id>
    <published>2018-05-11T15:04:48.000Z</published>
    <updated>2018-12-08T08:41:32.860Z</updated>
    
    <content type="html"><![CDATA[<p>本文因项目实际问题而起，简要分析了 RN Bundle 的结构。<br><a id="more"></a><br>©原创文章，转载请注明出处！</p><h1 id="引"><a href="#引" class="headerlink" title="引"></a>引</h1><hr><p>原本计划在完成『<a href="https://zxfcumtcs.github.io/2018/02/03/RNRendering/">ReactNative源码解析——渲染机制详解</a>』一文后，暂停 RN 相关的总结分享，谁料项目中通过RN分包同时加载两个业务 bundle 时出错了！索性对 RN Bundle 研究一番，遂总结出此文。</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><hr><p>使用 ReactNative 开发的业务，无论是通过内置还是动态下发的方式发布，都需要将业务 JavaScript 代码打包成 bundle。<br>JavaScript 作为一门静态脚本语言，为何需要打包这个过程？<br>打包主要有以下几个用途：</p><ul><li>开发 RN 业务时，一般会使用 JSX 语法『糖』描述 UI 视图，然而标准的 JS 引擎显然不支持 JSX，所以需要将 JSX 语法转换成标准的 JS 语法；</li><li>开发 RN 业务时，通常使用的是 ES 6，目前 iOS、Android 上的 JS 引擎还不支持 ES 6，因此需要转换；</li><li>JS 业务代码会依赖多个不同的模块(JS 文件)，RN 在打包时将所有依赖的模块打包到一个 bundle 文件中，较好地解决了这种复杂的依赖关系；</li><li>JS 代码的混淆。</li></ul><blockquote><p>RN 打包过程中的转码主要依赖 <a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 实现。</p></blockquote><h1 id="ReactNative-Bundle"><a href="#ReactNative-Bundle" class="headerlink" title="ReactNative Bundle"></a>ReactNative Bundle</h1><hr><p>RN Bundle 从本质上讲是一个 JS 文件，其主要由三部分组成：polyfills、module 定义、require 调用。<br><img src="/img/RNBundle.png" alt=""></p><h2 id="Polyfills"><a href="#Polyfills" class="headerlink" title="Polyfills"></a>Polyfills</h2><p>polyfills 部分主要是在 JS context 中做一些准备工作，如：声明 ES 6 语法中新增接口、定义模块方法(如：模块声明方法<code>__d</code>、模块引用方法<code>require</code>等)、设置<code>global.__DEV__</code>变量等。<br><img src="/img/Polyfills.jpeg" alt=""><br>如上图，polyfills 都闭包方法，定义的同时被调用。<br>polyfill具体规则定义在node_modules/metro-bundler/src/defaults.js中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">exports.polyfills = [</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Object.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/console.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/error-guard.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Number.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/String.prototype.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Array.prototype.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Array.es6.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/Object.es7.js'</span>),</span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./Resolver/polyfills/babelHelpers.js'</span>)];</span><br></pre></td></tr></table></figure></p><blockquote><p>defaults.js中还有其他有意思的信息^_^</p></blockquote><h2 id="module-definitions"><a href="#module-definitions" class="headerlink" title="module definitions"></a>module definitions</h2><p>为了更直观的了解 RN Bundle 中模块的定义，我们先来看一个例子：<br><img src="/img/RNDemo.jpeg" alt=""><br>如上图一个非常简单的 RN Demo，在打包生成的 bundle 中变成如下的格式：<br><img src="/img/RNMoudleBundle.jpeg" alt=""><br>很明显，为了看懂上图所示的打包结果，必须先了解一下<code>__d</code>为何物，细心的同学，可能已经在 polyfills 小节中发现了<code>__d</code>的定义(第<code>12</code>行)，即<code>__d</code>就是<code>define</code>方法，其完整的源码定义在：<code>node_modules/metro-bundler/src/Resolver/polyfills/require.js</code>中(代码略有删减)：<br><figure class="highlight js"><figcaption><span>node_modules/metro-bundler/src/Resolver/polyfills/require.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">global.require = <span class="built_in">require</span>;</span><br><span class="line">global.__d = define;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> modules = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">factory, moduleId, dependencyMap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (moduleId <span class="keyword">in</span> modules) &#123;</span><br><span class="line">        <span class="comment">// that are already loaded</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    modules[moduleId] = &#123;</span><br><span class="line">        dependencyMap,</span><br><span class="line">        exports: <span class="literal">undefined</span>,</span><br><span class="line">        factory,</span><br><span class="line">        hasError: <span class="literal">false</span>,</span><br><span class="line">        isInitialized: <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到<code>define</code>方法前三个参数分别为：<code>factory</code> 方法、module ID以及dependencyMap。<br><strong>调用<code>define</code>方法定义模块，实质就是以 moduleID 为 key 向模块注册表(<code>modules</code>)中注册模块相关的信息(<code>exports</code>、模块<code>factory</code>方法、<code>isInitialized</code>等)。</strong><br>好了，下面我们再次回到 RN Bundle 中 module definition。</p><h3 id="module-ID"><a href="#module-ID" class="headerlink" title="module ID"></a>module ID</h3><p>在 RN 中，为了唯一标识每个模块，解决模块间的依赖问题，在打包生成 bundle 时，为每个 module 生成一个唯一的 moduleID，moudleID 为从0开始递增的数字。<br>另外，RN 在打包 bundle 时，按模块间依赖关系深度遍历(弦外之音就是，根组件的 moduleID 为0)。</p><h3 id="module-factory"><a href="#module-factory" class="headerlink" title="module factory"></a>module factory</h3><p>从上图可知，module factory 方法主要做了以下几件事：</p><ul><li><strong>所有 <code>import</code> 转换为<code>require</code>方法调用(<code>import</code>是 ES 6新增语法，需要转换)(第<code>58</code>、<code>60</code>行)；</strong></li><li><strong>创建组件类(第<code>62~83</code>行)，其中最关键的方法就是<code>render</code>；</strong></li><li><strong>导出(exports)组件类(第<code>85</code>行)；</strong></li><li><strong>注册根组件(第<code>87~89</code>行)，详细信息请参看<a href="https://zxfcumtcs.github.io/2018/02/03/RNRendering/">ReactNative源码解析——渲染机制详解</a>一文。</strong></li></ul><blockquote><p>通过 module factory 中的 <code>render</code>方法，再次看到 JSX 标签被转换成了<code>createElement</code>方法调用。</p></blockquote><h2 id="require-calls"><a href="#require-calls" class="headerlink" title="require calls"></a>require calls</h2><p>RN Bundle 最后部分是 require calls：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;<span class="built_in">require</span>(<span class="number">50</span>);  <span class="comment">// InitializeCore.js</span></span><br><span class="line">;<span class="built_in">require</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p><code>require</code>方法参数为 moduleID，RN Bundle 最后这两个<code>require</code>调用分别加载了<code>InitializeCore</code>以及<code>RNDemo</code>(根组件)模块。<br>下面我们来看看，<code>require</code>具体做了哪些事(与模块定义方法<code>define</code>定义在同一文件中)：<br><figure class="highlight js"><figcaption><span>node_modules/metro-bundler/src/Resolver/polyfills/require.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = modules[moduleId];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.isInitialized ?</span><br><span class="line">    <span class="built_in">module</span>.exports :</span><br><span class="line">    guardedLoadModule(moduleIdReallyIsNumber, <span class="built_in">module</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">guardedLoadModule</span>(<span class="params">moduleId, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadModuleImplementation(moduleId, <span class="built_in">module</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadModuleImplementation</span>(<span class="params">moduleId, module</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">module</span>.isInitialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> exports = <span class="built_in">module</span>.exports = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> _module = <span class="built_in">module</span>;</span><br><span class="line">    <span class="keyword">const</span> factory = _module.factory, dependencyMap = _module.dependencyMap;</span><br><span class="line">    <span class="keyword">const</span> moduleObject = &#123; exports &#125;;</span><br><span class="line">    factory(global, <span class="built_in">require</span>, moduleObject, exports, dependencyMap);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports = moduleObject.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上代码所示，<code>require</code>方法首先判断所要加载的模块是否已经存在并初始化完成。若是，则直接返回模块的<code>exports</code>，否则调用<code>guardedLoadModule</code>方法(最终调用的是<code>loadModuleImplementation</code>方法)。<br><code>loadModuleImplementation</code>方法获得模块的<code>factory</code>方法并调用，最终返回模块的<code>exports</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从上文的分析可知，加载一个 RN Bundle，主要完成三件事：</p><ul><li>准备 JS 执行环境(polyfills)；</li><li>定义所有需要的模块(module define)；</li><li>加载<code>InitializeCore</code>以及根组件模块(require)。</li></ul><p>通过上文分析，应该能清楚的区分模块定义与加载的关系：</p><ul><li>模块定义(define)：将模块相关的信息(其中最重要的就是<code>factory</code>方法)添加到模块注册表中，仅此而已；</li><li>模块加载(require)：在 JS context 中调用模块<code>factory</code>方法，创建模块类并在组件注册表中注册根组件。</li></ul><p>以盖房子作比喻：</p><ul><li>模块定义：将盖房子需要的材料运入场地；</li><li>模块加载：真正地将房子盖起来。</li></ul><p>ps：上文所示的 RN Bundle 都是开发环境下打出来的(打包命令中<code>--dev</code>为 true)，这样的 Bundle 是没有经过混淆的，其可读性较好。经过混淆的 Bundle，大概长这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;e.__DEV__=!<span class="number">1</span>,e.__BUNDLE_START_TIME__=e.nativePerformanceNow?e.nativePerformanceNow():<span class="built_in">Date</span>.now()&#125;(<span class="string">"undefined"</span>!=<span class="keyword">typeof</span> global?global:<span class="string">"undefined"</span>!=<span class="keyword">typeof</span> self?self:<span class="keyword">this</span>);</span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;<span class="string">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">r,e,t</span>)</span>&#123;e <span class="keyword">in</span> u||(u[e]=&#123;<span class="attr">dependencyMap</span>:t,<span class="attr">exports</span>:<span class="keyword">void</span> <span class="number">0</span>,<span class="attr">factory</span>:r,<span class="attr">hasError</span>:!<span class="number">1</span>,<span class="attr">isInitialized</span>:!<span class="number">1</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">r</span>)</span>&#123;<span class="keyword">var</span> e=r,t=u[e];<span class="keyword">return</span> t&amp;&amp;t.isInitialized?t.exports:i(e,t)&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">if</span>(!c&amp;&amp;r.ErrorUtils)&#123;c=!<span class="number">0</span>;<span class="keyword">var</span> i=<span class="keyword">void</span> <span class="number">0</span>;<span class="keyword">try</span>&#123;i=n(e,t)&#125;<span class="keyword">catch</span>(e)&#123;r.ErrorUtils.reportFatalError(e)&#125;<span class="keyword">return</span> c=!<span class="number">1</span>,i&#125;<span class="keyword">return</span> n(e,t)&#125;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">e,i</span>)</span>&#123;<span class="keyword">var</span> n=r.nativeRequire;<span class="keyword">if</span>(!i&amp;&amp;n&amp;&amp;(n(e),i=u[e]),!i)<span class="keyword">throw</span> o(e);<span class="keyword">if</span>(i.hasError)<span class="keyword">throw</span> a(e,i.error);i.isInitialized=!<span class="number">0</span>;<span class="keyword">var</span> c=i.exports=&#123;&#125;,d=i,s=d.factory,f=d.dependencyMap;<span class="keyword">try</span>&#123;<span class="keyword">var</span> l=&#123;<span class="attr">exports</span>:c&#125;;<span class="keyword">return</span> s(r,t,l,c,f),i.factory=<span class="keyword">void</span> <span class="number">0</span>,i.dependencyMap=<span class="keyword">void</span> <span class="number">0</span>,i.exports=l.exports&#125;<span class="keyword">catch</span>(r)&#123;<span class="keyword">throw</span> i.hasError=!<span class="number">0</span>,i.error=r,i.isInitialized=!<span class="number">1</span>,i.exports=<span class="keyword">void</span> <span class="number">0</span>,r&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">r</span>)</span>&#123;<span class="keyword">var</span> e=<span class="string">'Requiring unknown module "'</span>+r+<span class="string">'".'</span>;<span class="keyword">return</span> <span class="built_in">Error</span>(e)&#125;<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">r,e</span>)</span>&#123;<span class="keyword">var</span> t=r;<span class="keyword">return</span> <span class="built_in">Error</span>(<span class="string">'Requiring module "'</span>+t+<span class="string">'", which threw an exception: '</span>+e)&#125;r.require=t,r.__d=e;<span class="keyword">var</span> u=<span class="built_in">Object</span>.create(<span class="literal">null</span>),c=!<span class="number">1</span>&#125;(<span class="string">"undefined"</span>!=<span class="keyword">typeof</span> global?global:<span class="string">"undefined"</span>!=<span class="keyword">typeof</span> self?self:<span class="keyword">this</span>);</span><br><span class="line">__d(<span class="function"><span class="keyword">function</span>(<span class="params">e,t,r,l</span>)</span>&#123;<span class="built_in">Object</span>.defineProperty(l,<span class="string">"__esModule"</span>,&#123;<span class="attr">value</span>:!<span class="number">0</span>&#125;);<span class="keyword">var</span> n=t(<span class="number">12</span>),s=babelHelpers.interopRequireDefault(n),a=t(<span class="number">24</span>),o=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> babelHelpers.classCallCheck(<span class="keyword">this</span>,t),babelHelpers.possibleConstructorReturn(<span class="keyword">this</span>,(t.__proto__||<span class="built_in">Object</span>.getPrototypeOf(t)).apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>))&#125;<span class="keyword">return</span> babelHelpers.inherits(t,e),babelHelpers.createClass(t,[&#123;<span class="attr">key</span>:<span class="string">"render"</span>,<span class="attr">value</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> s.default.createElement(a.View,&#123;<span class="attr">style</span>:styles.container&#125;,s.default.createElement(a.Text,<span class="literal">null</span>,<span class="string">"This is a demo"</span>))&#125;&#125;]),t&#125;(s.default.Component);l.default=o,a.AppRegistry.registerComponent(<span class="string">"RNDemo"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> o&#125;)&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><hr><p>好了，本文既然是因问题而起，最后简要介绍一下遇到的问题：<br><img src="/img/RNDemoError.jpeg" alt=""><br>问题的描述很清楚是根组件没有注册，由于刚刚分析完 RN 的渲染机制，知道这个错误描述的出处(来自<code>AppRegistry</code>模块的<code>runApplication</code>方法)：<br><img src="/img/runApplicationError.jpeg" alt=""><br>问题也很明显是在组件注册表<code>runnables</code>中找不到要运行的根组件。<br>起初我们怀疑是因为两个业务 bundle 有冲突在加载时出错了。<br>但 debug 下来并没有出错提示。<br>最终请教相关人士，得知是两个业务 bundle ID 一样，导致第二个 bundle 没有被正确定义(<code>define</code>方法首先通过要定义的模块 ID 判断该 ID 是否已注册，若已注册直接返回)。</p><blockquote><p>两个业务 bundle ID 会一样与我们使用的拆包方案有关。</p></blockquote><p>问题清楚了，修改就简单了，在此不细述了。</p><blockquote><p>通过这个问题，也说明了对底层实现方案了解的必要性。了解的越深，在遇到问题时思考的视角就会越广。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文因项目实际问题而起，简要分析了 RN Bundle 的结构。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://zxfcumtcs.github.io/tags/iOS/"/>
    
      <category term="框架" scheme="http://zxfcumtcs.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ReactNative" scheme="http://zxfcumtcs.github.io/tags/ReactNative/"/>
    
  </entry>
  
</feed>
